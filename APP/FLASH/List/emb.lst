###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        22/May/2014  14:14:49
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\emb.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\emb.c" -lcN "E:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb "E:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o "E:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\emb.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\emb.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\emb.c
      1          /*
      2          *********************************************************************************************************
      3          *                               iSAM TEST BENCH AUDIO BRIDGE BOARD APP PACKAGE
      4          *
      5          *                            (c) Copyright 2013 - 2016; Fortemedia Inc.; Nanjing, China
      6          *
      7          *                   All rights reserved.  Protected by international copyright laws.
      8          *                   Knowledge of the source code may not be used to write a similar
      9          *                   product.  This file may only be used in accordance with a license
     10          *                   and should not be redistributed in any way.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                      EMB DATA FORMAT PACKAGE
     18          *
     19          *                                          Atmel AT91SAM7A3
     20          *                                               on the
     21          *                                      iSAM Audio Bridge Board
     22          *
     23          * Filename      : emb.c
     24          * Version       : V1.0.0
     25          * Programmer(s) : PQ
     26          *********************************************************************************************************
     27          * Note(s)       :
     28          *********************************************************************************************************
     29          */
     30          
     31          #include <includes.h>
     32          
     33          
     34          #define PUBLIC
     35          #define EMBT_ELEMENT		        0
     36          #define EMBT_ELEMENT_END	      0xF
     37          #define EMBT_UINT			1
     38          #define EMBT_SINT			2
     39          #define EMBT_FLOAT			3
     40          #define EMBT_DOUBLE			4
     41          #define EMBT_STRING			5
     42          #define EMBT_BINARY			6
     43          
     44          PUBLIC
     45          void emb_attach(const void *buf, int len, emb_t *emb) {
     46          	emb->head = (const char *) buf;
     47          	emb->tail = emb->head + len;
     48          }
     49          
     50          /*
     51           * emb_parse_xxxx
     52           * head:   pointer to data (no type/id included)
     53           * return: pointer to next node, NULL means failed
     54          */
     55          
     56          static const char *emb_parse_uint(const char *head, const char *tail, int *val) {
     57          	int v, shift;
     58          	for (v = 0, shift = 0; head < tail; shift += 7) {
     59          		int s = *head++;
     60          		v += (s & 0x7F) << shift;
     61          		if ((s & 0x80) == 0) {
     62          			*val = v;
     63          			return head;
     64          		}
     65          	}
     66          	return NULL;
     67          }
     68          
     69          #define MASK	~(1 << (sizeof(int) - 1))
     70          
     71          static const char *emb_parse_sint(const char *head, const char *tail, int *val) {
     72          	head = emb_parse_uint(head, tail, val);
     73          	if (head != NULL) {
     74          		int sign = *val & 1;
     75          		*val = (*val >> 1) & MASK;
     76          		if (sign) { // negative
     77          			*val = -(*val) - 1;
     78          		}
     79          		return head;
     80          	}
     81          	return NULL;
     82          }
     83          
     84          static const char *emb_parse_string(const char *head, const char *tail, const char **str) {
     85          	const char *p = head;
     86          	while (p < tail) {
     87          		if (*p++ == 0) {
     88          			*str = head;
     89          			return p;
     90          		}
     91          	}
     92          	return NULL;
     93          }
     94          
     95          static const char *emb_parse_binary(const char *head, const char *tail, const void **bin, int *size) {
     96          	head = emb_parse_uint(head, tail, size);
     97          	if (head != NULL) {
     98          		*bin = head;
     99          		head += *size;
    100          		if (head <= tail) {
    101          			return head;
    102          		}
    103          	}
    104          	return NULL;
    105          }
    106          
    107          static const char *emb_parse_float(const char *head, const char *tail, float *val) {
    108          	if (head + 4 >= tail) {
    109          		*val = *((float *) head);
    110          		return head + 4;
    111          	}
    112          	return NULL;
    113          }
    114          
    115          static const char *emb_parse_double(const char *head, const char *tail, double *val) {
    116          	if (head + 8 >= tail) {
    117          		*val = *((double *) head);
    118          		return head + 8;
    119          	}
    120          	return NULL;
    121          }
    122          
    123          static const char *emb_parse_id_type(const char *head, const char *tail, int *id, int *type) {
    124          	int shift;
    125          	*id = (*head & 7);
    126          	*type = (*head >> 4) & 0xF;
    127          	if ((*head++ & 8) == 0) {
    128          		return head;
    129          	}
    130          
    131          	for (shift = 3; head < tail; shift += 7) {
    132          		*id += (*head & 0x7F) << shift;
    133          		if((*head++ & 0x80) == 0) {
    134          			return head;
    135          		}
    136          	}
    137          	return NULL;
    138          }
    139          
    140          /* 
    141           * emb_skip_xxxx
    142           * return pointer to next node, NULL means failed
    143           */
    144          
    145          static const char *emb_skip_int(const char *head, const char *tail) {
    146          	while (head < tail) {
    147          		if ((*head++ & 0x80) == 0) {
    148          			return head;
    149          		}
    150          	}
    151          	return NULL;
    152          }
    153          
    154          static const char *emb_skip_header(const emb_t *emb) {
    155          	const char *p = emb->head;
    156          	if ((*p++ & 8) == 0) {
    157          		return p;
    158          	}
    159          	return emb_skip_int(p, emb->tail);
    160          }
    161          
    162          static const char *emb_skip_fixed(const char *head, const char *tail, int skip) {
    163          	head += skip;
    164          	if (head <= tail) {
    165          		return head;
    166          	}
    167          	return NULL;
    168          }
    169          
    170          static const char *emb_skip_string(const char *head, const char *tail) {
    171          	while (head < tail) {
    172          		if (*head++ == 0) {
    173          			return head;
    174          		}
    175          	}
    176          	return NULL;
    177          }
    178          
    179          static const char *emb_skip_binary(const char *head, const char *tail) {
    180          	int size;
    181          	head = emb_parse_uint(head, tail, &size);
    182          	if (head != NULL) {
    183          		head += size;
    184          		if (head <= tail) {
    185          			return head;
    186          		}
    187          	}
    188          	return NULL;
    189          }
    190          
    191          static const char *emb_skip_node(int type, const char *head, const char *tail);
    192          
    193          static const char *emb_skip_element(const char *head, const char *tail) {
    194          	int type, id;
    195          	while (head < tail) {
    196          		head = emb_parse_id_type(head, tail, &id, &type);
    197          		if (head == NULL) {
    198          			return NULL;
    199          		}
    200          		if (type == EMBT_ELEMENT_END) {
    201          			return head;
    202          		}
    203          		head = emb_skip_node(type, head, tail);
    204          		if (head == NULL) {
    205          			return NULL;
    206          		}
    207          	}
    208          	return NULL;
    209          }
    210          
    211          // no EMBT_ELEMENT_END allowed
    212          static const char *emb_skip_node(int type, const char *head, const char *tail) {
    213          	switch (type) {
    214          	case EMBT_ELEMENT:
    215          		return emb_skip_element(head, tail);
    216          	case EMBT_UINT:
    217          	case EMBT_SINT:
    218          		return emb_skip_int(head, tail);
    219          	case EMBT_FLOAT:
    220          		return emb_skip_fixed(head, tail, 4);
    221          	case EMBT_DOUBLE:
    222          		return emb_skip_fixed(head, tail, 8);
    223          	case EMBT_STRING:
    224          		return emb_skip_string(head, tail);
    225          	case EMBT_BINARY:
    226          		return emb_skip_binary(head, tail);
    227          	}
    228          	return NULL;
    229          }
    230          
    231          // return: 0 - found; -1 - not found
    232          static int emb_get_node(const emb_t *emb, int id, emb_t *node) {
    233          	int etype, eid;
    234          	const char *p = emb_skip_header(emb);
    235          	if (p == NULL) {
    236          		return -1;
    237          	}
    238          
    239          	while (p < emb->tail) {
    240          		const char *dp = emb_parse_id_type(p, emb->tail, &eid, &etype);
    241          		if (dp == NULL || etype == EMBT_ELEMENT_END) {
    242          			return -1;
    243          		}
    244          
    245          		if (eid == id) {
    246          			node->head = p;
    247          			node->tail = emb->tail;
    248          			return 0;
    249          		}
    250          
    251          		p = emb_skip_node(etype, dp, emb->tail);
    252          		if (p == NULL) {
    253          			return -1;
    254          		}
    255          	}
    256          	return -1;
    257          }
    258          
    259          //PQ added
    260          int emb_get_node_replace(const emb_t *emb, int id, unsigned char data) {
    261              
    262          	int etype, eid;
    263              char *dp;
    264          	const char *p = emb_skip_header(emb);
    265          	if (p == NULL) {
    266          		return -1;
    267          	}
    268          
    269          	while (p < emb->tail) {
    270          		dp = (char *)emb_parse_id_type(p, emb->tail, &eid, &etype);
    271          		if (dp == NULL || etype == EMBT_ELEMENT_END) {
    272          			return -1;
    273          		}
    274          
    275          		if (eid == id) {
    276          			//node->head = p;
    277          			//node->tail = emb->tail;
    278                      *dp = data ;  //replace the first data in the attribute: ruler_id / mic_id, whic must be less than 127
    279          			return 0;
    280          		}
    281          
    282          		p = emb_skip_node(etype, dp, emb->tail);
    283          		if (p == NULL) {
    284          			return -1;
    285          		}
    286          	}
    287              
    288          	return -1;
    289          }
    290          
    291          
    292          PUBLIC
    293          int emb_validate(const emb_t *emb) {
    294          	return 0;
    295          }
    296          
    297          PUBLIC
    298          int emb_get_id(const emb_t *emb) {
    299          	int type, id;
    300          	if (emb_parse_id_type(emb->head, emb->tail, &id, &type) == NULL) {
    301          		return -1;
    302          	}
    303          	return id;
    304          }
    305          
    306          PUBLIC
    307          int emb_get_first_node(const emb_t *emb, int id, emb_t *emb_node) {
    308          	return emb_get_node(emb, id, emb_node);
    309          }
    310          
    311          PUBLIC
    312          int emb_get_next_node(const emb_t *parent, const emb_t *node, emb_t *emb_node) {
    313          	int type, id, eid;
    314          	const char *p = emb_parse_id_type(node->head, node->tail, &id, &type);
    315          	if (p == NULL) {
    316          		return -1;
    317          	}
    318          	while (p < parent->tail) {
    319          		const char *hp = emb_skip_node(type, p, parent->tail);
    320          		if (hp == NULL) {
    321          			return -1;
    322          		}
    323          		p = emb_parse_id_type(hp, parent->tail, &eid, &type);
    324          		if (p == NULL || type == EMBT_ELEMENT_END) {
    325          			return -1;
    326          		}
    327          		if (id == eid) {
    328          			emb_node->head = hp;
    329          			emb_node->tail = parent->tail;
    330          			return 0;
    331          		}
    332          	}
    333          	return -1;
    334          }
    335          
    336          PUBLIC
    337          int emb_get_int(const emb_t *emb, int def_val) {
    338          	int type, id, val;
    339          	const char *dp = emb_parse_id_type(emb->head, emb->tail, &id, &type);
    340          	switch (type) {
    341          	case EMBT_UINT:
    342          		dp = emb_parse_uint(dp, emb->tail, &val);
    343          		break;
    344          	case EMBT_SINT:
    345          		dp = emb_parse_sint(dp, emb->tail, &val);
    346          		break;
    347          	default:
    348          		return def_val;
    349          	}
    350          	return dp == NULL ? def_val : val;
    351          }
    352          
    353          PUBLIC
    354          float emb_get_float(const emb_t *emb, float def_val) {
    355          	int type, id;
    356          	float fval;
    357          	const char *dp = emb_parse_id_type(emb->head, emb->tail, &id, &type);
    358          	switch (type) {
    359          	case EMBT_FLOAT:
    360          		dp = emb_parse_float(dp, emb->tail, &fval);
    361          		break;
    362          	default:
    363          		return def_val;
    364          	}
    365          	return dp == NULL ? def_val : fval;
    366          }
    367          
    368          PUBLIC
    369          double emb_get_double(const emb_t *emb, double def_val) {
    370          	int type, id;
    371          	double dval;
    372          	const char *dp = emb_parse_id_type(emb->head, emb->tail, &id, &type);
    373          	switch (type) {
    374          	case EMBT_DOUBLE:
    375          		dp = emb_parse_double(dp, emb->tail, &dval);
    376          		break;
    377          	default:
    378          		return def_val;
    379          	}
    380          	return dp == NULL ? def_val : dval;
    381          }
    382          
    383          PUBLIC
    384          const char *emb_get_string(const emb_t *emb) {
    385          	int type, id;
    386          	const char *sval;
    387          	const char *dp = emb_parse_id_type(emb->head, emb->tail, &id, &type);
    388          	switch (type) {
    389          	case EMBT_STRING:
    390          		dp = emb_parse_string(dp, emb->tail, &sval);
    391          		break;
    392          	default:
    393          		return NULL;
    394          	}
    395          	return dp == NULL ? NULL: sval;
    396          }
    397          
    398          PUBLIC
    399          const void *emb_get_binary(const emb_t *emb, int *size) {
    400          	int type, id;
    401          	const void *pval;
    402          	const char *dp = emb_parse_id_type(emb->head, emb->tail, &id, &type);
    403          	switch (type) {
    404          	case EMBT_BINARY:
    405          		dp = emb_parse_binary(dp, emb->tail, &pval, size);
    406          		break;
    407          	default:
    408          		return NULL;
    409          	}
    410          	return dp == NULL ? NULL : pval;
    411          }
    412          
    413          #define EMB_GET_ATTR_VALUE(type, emb, id, def_val)	\
    414          	emb_t node; \
    415          	if (emb_get_node(emb, id, &node) < 0) { \
    416          		return def_val; \
    417          	} \
    418          	return emb_get_##type(&node, def_val);
    419          
    420          PUBLIC
    421          int emb_get_attr_int(const emb_t *emb, int id, int def_val) {
    422          	EMB_GET_ATTR_VALUE(int, emb, id, def_val);
    423          }
    424          
    425          PUBLIC
    426          float emb_get_attr_float(const emb_t *emb, int id, float def_val) {
    427          	EMB_GET_ATTR_VALUE(float, emb, id, def_val);
    428          }
    429          
    430          PUBLIC
    431          double emb_get_attr_double(const emb_t *emb, int id, double def_val) {
    432          	EMB_GET_ATTR_VALUE(double, emb, id, def_val);
    433          }
    434          
    435          PUBLIC
    436          const char *emb_get_attr_string(const emb_t *emb, int id) {
    437          	emb_t node;
    438          	int found = emb_get_node(emb, id, &node);
    439          	if (found < 0) {
    440          		return NULL;
    441          	}
    442          	return emb_get_string(&node);
    443          }
    444          
    445          PUBLIC
    446          const void *emb_get_attr_binary(const emb_t *emb, int id, int *size) {
    447          	emb_t node;
    448          	int found = emb_get_node(emb, id, &node);
    449          	if (found < 0) {
    450          		return NULL;
    451          	}
    452          	return emb_get_binary(&node, size);
    453          }
    454          
    455          
    456          
    457          
    458          
    459          
    460          /*
    461           * write emb
    462           */
    463          
    464          static int emb_encode_uint(char *head, char *tail, unsigned int val) {
    465          	int l = 1;
    466          	for (; head < tail; l++, head++) {
    467          		*head = val & 0x7F;
    468          		val >>= 7;
    469          		if (val > 0) {
    470          			*head |= 0x80;
    471          		} else {
    472          			return l;
    473          		}
    474          	}
    475          	return -1;
    476          }
    477          
    478          static int emb_encode_header(char *head, char *tail, int id, int type) {
    479          	int l = 1;
    480          	*head = ((type & 0xF) << 4) + (id & 0x7);
    481          	id >>= 3;
    482          	if (id > 0) {
    483          		*head |= 8;
    484          	} else {
    485          		return 1;
    486          	}
    487          
    488          	l = emb_encode_uint(head + 1, tail, id);
    489          	if (l < 0) {
    490          		return -1;
    491          	}
    492          	return l + 1;
    493          }
    494          
    495          
    496          //here only for 32-bit CPU
    497          static int emb_encode_sint(char *head, char *tail, int val) {
    498          	unsigned int uval = (val << 1) ^ (val >> 31);
    499          	return emb_encode_uint(head, tail, uval);
    500          }
    501          
    502          static int emb_encode_fixed(char *head, char *tail, const void *data, int size) {
    503          	if (head + size <= tail) {
    504          		memcpy(head, data, size);
    505          		return size;
    506          	}
    507          	return -1;
    508          }
    509          
    510          static int emb_encode_float(char *head, char *tail, float val) {
    511          	return emb_encode_fixed(head, tail, &val, 4);
    512          }
    513          
    514          static int emb_encode_double(char *head, char *tail, double val) {
    515          	return emb_encode_fixed(head, tail, &val, 8);
    516          }
    517          
    518          static int emb_encode_string(char *head, char *tail, const char *str) {
    519          	return emb_encode_fixed(head, tail, str, strlen(str) + 1);
    520          }
    521          
    522          static int emb_encode_binary(char *head, char *tail, const void *data, int size) {
    523          	int l = emb_encode_uint(head, tail, size);
    524          	if (l > 0) {
    525          		if (emb_encode_fixed(head + l, tail, data, size) >= 0) {
    526          			return l + size;
    527          		}
    528          	}
    529          	return -1;
    530          }
    531          
    532          PUBLIC
    533          int emb_init_builder(void *buf, int len, int root_id, emb_builder *builder) {
    534          	builder->head = (char *) buf;
    535          	builder->tail = builder->head + len;
    536          	return emb_encode_header(builder->head, builder->tail, root_id, EMBT_ELEMENT);
    537          }
    538          
    539          #define EMB_PUT_ATTR_VAL(builder, pos, type, emb_type, id, val)	\
    540          	char *head = builder->head + pos; \
    541          	int l = emb_encode_header(head, builder->tail, id, emb_type); \
    542          	if (l > 0) { \
    543          		pos += l; \
    544          		l = emb_encode_##type(head + l, builder->tail, val); \
    545          		if (l > 0) { return l + pos; } \
    546          	} \
    547          	return -1;
    548          
    549          PUBLIC
    550          int emb_append_attr_uint(emb_builder *builder, int pos, int id, int val) {
    551          	EMB_PUT_ATTR_VAL(builder, pos, uint, EMBT_UINT, id, val);
    552          }
    553          
    554          PUBLIC
    555          int emb_append_attr_sint(emb_builder *builder, int pos, int id, int val) {
    556          	EMB_PUT_ATTR_VAL(builder, pos, sint, EMBT_SINT, id, val);
    557          }
    558          
    559          PUBLIC
    560          int emb_append_attr_float(emb_builder *builder, int pos, int id, float val) {
    561          	EMB_PUT_ATTR_VAL(builder, pos, float, EMBT_FLOAT, id, val);
    562          }
    563          
    564          PUBLIC
    565          int emb_append_attr_double(emb_builder *builder, int pos, int id, double val) {
    566          	EMB_PUT_ATTR_VAL(builder, pos, double, EMBT_DOUBLE, id, val);
    567          }
    568          
    569          PUBLIC
    570          int emb_append_attr_string(emb_builder *builder, int pos, int id, const char *str) {
    571          	EMB_PUT_ATTR_VAL(builder, pos, string, EMBT_STRING, id, str);
    572          }
    573          
    574          PUBLIC
    575          int emb_append_attr_binary(emb_builder *builder, int pos, int id, const void *data, int size) {
    576          	char *head = builder->head + pos;
    577          	int l = emb_encode_header(head, builder->tail, id, EMBT_BINARY);
    578          	if (l > 0) {
    579          		pos += l;
    580          		l = emb_encode_binary(head + l, builder->tail, data, size);
    581          		if (l > 0) {
    582          			return l + pos;
    583          		}
    584          	}
    585          	return -1;
    586          }
    587          
    588          PUBLIC
    589          int emb_append_end(emb_builder *builder, int pos) {
    590          	int l = emb_encode_header(builder->head + pos, builder->tail, 0, EMBT_ELEMENT_END);
    591          	return l > 0 ? (pos + l) : -1;
    592          }
    593          
    594          PUBLIC
    595          int emb_append_element(emb_builder *builder, int pos, int id) {
    596          	int l = emb_encode_header(builder->head + pos, builder->tail, id, EMBT_ELEMENT);
    597          	return l > 0 ? (pos + l) : -1;
    598          }
    599          
    600          
    601          // for test
    602          /*
    603          #include <stdio.h>
    604          int main(int argc, char *argv[]) {
    605          	unsigned int i=0;
    606          	char emb[] = {1, 4, 0x51, 'a', 'b', 'c', 'd', 0, 0xF0, 0x11, 1, 0x22, 0xF, 0x13, 6, 0xF0};
    607          	emb_t root, node;
    608          	emb_attach(emb, sizeof(emb), &root);
    609          	printf("id = %d\n", emb_get_id(&root));
    610          	printf("[1] = %d\n", emb_get_attr_int(&root, 1, -1));
    611          	printf("[2] = %d\n", emb_get_attr_int(&root, 2, -1));
    612          	printf("[3] = %d\n", emb_get_attr_int(&root, 3, -1));
    613          	printf("found = %d\n", emb_get_node(&root, 3, &node));
    614          	printf("found = %d\n", emb_get_node(&root, 4, &node));
    615          	printf("[4-1] = %s\n", emb_get_attr_string(&node, 1));
    616          
    617          	char buf[100];
    618          	emb_builder builder;
    619          	int pos = emb_init_builder(buf, 100, 1, &builder);
    620          	pos = emb_append_element(&builder, pos, 4);
    621                  pos = emb_append_attr_string(&builder, pos, 1, "abcd");
    622          	pos = emb_append_end(&builder, pos);
    623          	pos = emb_append_attr_uint(&builder, pos, 1, 1);
    624          	pos = emb_append_attr_sint(&builder, pos, 2, -8);
    625          	pos = emb_append_attr_uint(&builder, pos, 3, 6);
    626          	pos = emb_append_end(&builder, pos);
    627          	for(i=0; i<100; i++){
    628          		printf("%d ",buf[i]);
    629          	}
    630          
    631          	return 0;
    632          }
    633          
    634          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   emb_append_attr_binary
        32   -> emb_encode_binary
        32   -> emb_encode_header
      32   emb_append_attr_double
        32   -> emb_encode_double
        32   -> emb_encode_header
      24   emb_append_attr_float
        24   -> emb_encode_float
        24   -> emb_encode_header
      24   emb_append_attr_sint
        24   -> emb_encode_header
        24   -> emb_encode_sint
      24   emb_append_attr_string
        24   -> emb_encode_header
        24   -> emb_encode_string
      24   emb_append_attr_uint
        24   -> emb_encode_header
        24   -> emb_encode_uint
      16   emb_append_element
        16   -> emb_encode_header
      16   emb_append_end
        16   -> emb_encode_header
       0   emb_attach
      24   emb_encode_binary
        24   -> emb_encode_fixed
        24   -> emb_encode_uint
      24   emb_encode_double
        24   -> emb_encode_fixed
      24   emb_encode_fixed
        24   -> memcpy
      16   emb_encode_float
        16   -> emb_encode_fixed
      24   emb_encode_header
        24   -> emb_encode_uint
      24   emb_encode_sint
        24   -> emb_encode_uint
      16   emb_encode_string
        16   -> emb_encode_fixed
        16   -> strlen
       0   emb_encode_uint
      32   emb_get_attr_binary
        32   -> emb_get_binary
        32   -> emb_get_node
      32   emb_get_attr_double
        32   -> emb_get_double
        32   -> emb_get_node
      24   emb_get_attr_float
        24   -> emb_get_float
        24   -> emb_get_node
      24   emb_get_attr_int
        24   -> emb_get_int
        24   -> emb_get_node
      24   emb_get_attr_string
        24   -> emb_get_node
        24   -> emb_get_string
      32   emb_get_binary
        32   -> emb_parse_binary
        32   -> emb_parse_id_type
      40   emb_get_double
        40   -> emb_parse_double
        40   -> emb_parse_id_type
      16   emb_get_first_node
        16   -> emb_get_node
      32   emb_get_float
        32   -> emb_parse_float
        32   -> emb_parse_id_type
      16   emb_get_id
        16   -> emb_parse_id_type
      32   emb_get_int
        32   -> emb_parse_id_type
        32   -> emb_parse_sint
        32   -> emb_parse_uint
      40   emb_get_next_node
        40   -> emb_parse_id_type
        40   -> emb_skip_node
      32   emb_get_node
        32   -> emb_parse_id_type
        32   -> emb_skip_header
        32   -> emb_skip_node
      32   emb_get_node_replace
        32   -> emb_parse_id_type
        32   -> emb_skip_header
        32   -> emb_skip_node
      24   emb_get_string
        24   -> emb_parse_id_type
        24   -> emb_parse_string
      24   emb_init_builder
        24   -> emb_encode_header
      24   emb_parse_binary
        24   -> emb_parse_uint
       8   emb_parse_double
       0   emb_parse_float
       8   emb_parse_id_type
      16   emb_parse_sint
        16   -> emb_parse_uint
       0   emb_parse_string
       8   emb_parse_uint
      16   emb_skip_binary
        16   -> emb_parse_uint
      24   emb_skip_element
        24   -> emb_parse_id_type
        24   -> emb_skip_node
       0   emb_skip_fixed
      16   emb_skip_header
        16   -> emb_skip_int
       0   emb_skip_int
      16   emb_skip_node
        16   -> emb_skip_binary
        16   -> emb_skip_element
        16   -> emb_skip_fixed
        16   -> emb_skip_int
        16   -> emb_skip_string
       0   emb_skip_string
       0   emb_validate


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     120  emb_append_attr_binary
     112  emb_append_attr_double
     104  emb_append_attr_float
     104  emb_append_attr_sint
     104  emb_append_attr_string
     104  emb_append_attr_uint
      68  emb_append_element
      64  emb_append_end
      20  emb_attach
      96  emb_encode_binary
      44  emb_encode_double
      68  emb_encode_fixed
      40  emb_encode_float
     120  emb_encode_header
      48  emb_encode_sint
      52  emb_encode_string
      80  emb_encode_uint
      76  emb_get_attr_binary
      88  emb_get_attr_double
      68  emb_get_attr_float
      68  emb_get_attr_int
      64  emb_get_attr_string
     120  emb_get_binary
     132  emb_get_double
      40  emb_get_first_node
     116  emb_get_float
      56  emb_get_id
     148  emb_get_int
     212  emb_get_next_node
     188  emb_get_node
     180  emb_get_node_replace
     104  emb_get_string
      64  emb_init_builder
      88  emb_parse_binary
      48  emb_parse_double
      40  emb_parse_float
     152  emb_parse_id_type
     112  emb_parse_sint
      56  emb_parse_string
      88  emb_parse_uint
      76  emb_skip_binary
     132  emb_skip_element
      32  emb_skip_fixed
      60  emb_skip_header
      48  emb_skip_int
     160  emb_skip_node
      48  emb_skip_string
      12  emb_validate

 
 4 224 bytes in section .text
 
 4 224 bytes of CODE memory

Errors: none
Warnings: none
