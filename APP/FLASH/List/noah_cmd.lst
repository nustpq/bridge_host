###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        15/Dec/2014  17:50:02
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\noah_cmd.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\noah_cmd.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\FLASH\List\noah_cmd.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\noah_cmd.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\noah_cmd.c
      1          /*
      2          *********************************************************************************************************
      3          *                               iSAM TEST BENCH AUDIO BRIDGE BOARD APP PACKAGE
      4          *
      5          *                            (c) Copyright 2013 - 2016; Fortemedia Inc.; Nanjing, China
      6          *
      7          *                   All rights reserved.  Protected by international copyright laws.
      8          *                   Knowledge of the source code may not be used to write a similar
      9          *                   product.  This file may only be used in accordance with a license
     10          *                   and should not be redistributed in any way.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                        COMMUNICATION COMMANDS REALIZATION
     18          *
     19          *                                          Atmel AT91SAM7A3
     20          *                                               on the
     21          *                                      iSAM Audio Bridge Board
     22          *
     23          * Filename      : noah_cmd.c
     24          * Version       : V1.0.0
     25          * Programmer(s) : PQ
     26          *********************************************************************************************************
     27          * Note(s)       :
     28          *********************************************************************************************************
     29          */
     30          
     31          #include <includes.h>
     32          
     33          
     34          #define MAXBUFLEN   MsgUARTBody_SIZE
     35           
     36          
     37          extern EMB_BUF   Emb_Buf_Cmd;
     38          extern EMB_BUF   Emb_Buf_Data;
     39          
     40          
     41          /*
     42          *********************************************************************************************************
     43          *                                           Init_EMB_BUF()
     44          *
     45          * Description : Initialize EMB_BUF type data.
     46          * Argument(s) : pEBuf :
     47          * Return(s)   : None.
     48          *
     49          * Note(s)     : None.
     50          *********************************************************************************************************
     51          */
     52          void  Init_EMB_BUF (EMB_BUF  *pEBuf)
     53          {
     54              pEBuf->index   = 0;
     55              pEBuf->length  = 0;
     56              pEBuf->pdata   = NULL;
     57              pEBuf->state   = true;
     58          }
     59          
     60          
     61          /*
     62          *********************************************************************************************************
     63          *                                           Init_CMD_Read()
     64          *
     65          * Description : Initialize CMDREAD type data.
     66          * Argument(s) : pCMD_Read : 
     67          *               pOS_EVENT :
     68          * Return(s)   : None.
     69          *
     70          * Note(s)     : None.
     71          *********************************************************************************************************
     72          */
     73          void  Init_CMD_Read (CMDREAD   *pCMD_Read, 
     74                               OS_EVENT  *pOS_EVENT)
     75          {
     76              
     77              pCMD_Read->state_mac    = CMD_STAT_SYNC1 ;
     78              pCMD_Read->pRecvPtr     = NULL;
     79              pCMD_Read->PcCmdCounter = 0 ;
     80              pCMD_Read->PcCmdDataLen = 0 ;  
     81              pCMD_Read->pEvent       = pOS_EVENT ; 
     82              
     83          }
     84          
     85          
     86          /*
     87          *********************************************************************************************************
     88          *                                           Noah_CMD_Read()
     89          *
     90          * Description : Initialize CMDREAD type data.
     91          * Argument(s) : pCMD_Read :
     92          *               ch        :
     93          * Return(s)   : None.
     94          *
     95          * Note(s)     : None.
     96          *********************************************************************************************************
     97          */
     98          void  Noah_CMD_Read (CMDREAD    *pCMD_Read,
     99                               CPU_INT08U  ch)
    100          { 
    101              
    102              CPU_INT08U   err;    
    103              OS_MEM_DATA  MemInfo ;
    104              NOAH_CMD    *pNoahCmd = NULL ; 
    105              
    106              CPU_INT08U   state_mac       = pCMD_Read->state_mac ;
    107              CPU_INT08U  *pRecvPtr        = pCMD_Read->pRecvPtr;
    108              CPU_INT16U   PcCmdCounter    = pCMD_Read->PcCmdCounter;
    109              CPU_INT16U   PcCmdDataLen    = pCMD_Read->PcCmdDataLen;
    110              
    111              switch( state_mac ) {   
    112                  
    113                  case CMD_STAT_SYNC1 :        
    114                      if(ch == CMD_DATA_SYNC1)  {
    115                          state_mac = CMD_STAT_SYNC2 ;
    116                      }
    117                  break;
    118                  
    119                  case CMD_STAT_SYNC2 :
    120                      if(ch == CMD_DATA_SYNC2)  {             
    121                          err =   OSMemQuery( pMEM_Part_MsgUART,&MemInfo );	                
    122                          if( MemInfo.OSNFree > 1 && OS_ERR_NONE == err )  {
    123                              pRecvPtr = (void *)OSMemGet(pMEM_Part_MsgUART,&err);
    124                              if( NULL != pRecvPtr && OS_ERR_NONE == err )  {
    125                                  state_mac     =  CMD_STAT_FLAG;
    126                                  PcCmdCounter  = 0 ;                        
    127                              }
    128                          } 
    129                          
    130                      } else {
    131                        
    132                          state_mac = CMD_STAT_SYNC1;                
    133                      }
    134                  break ;
    135                  
    136                  case CMD_STAT_FLAG :            
    137                      *( pRecvPtr + PcCmdCounter++ ) = ch; //save in buf
    138                 
    139                      switch( GET_FRAME_TYPE(ch) )  {
    140                              case FRAM_TYPE_DATA :
    141                              case FRAM_TYPE_GDD_IIC :
    142                                  state_mac =  CMD_STAT_LENGTH ;
    143                                  break ;                
    144                              case FRAM_TYPE_ACK :
    145                              case FRAM_TYPE_NAK :
    146                              case FRAM_TYPE_EST :
    147                              case FRAM_TYPE_ESTA :
    148                                  *( pRecvPtr + PcCmdCounter++ ) = 0; //set datalen = 0
    149                                  state_mac =  CMD_STAT_CHECKSUM ;
    150                                  break;                    
    151                              default :
    152                                  break ;                        
    153                      }
    154                   
    155                  break ;
    156                  
    157                  case CMD_STAT_LENGTH :            
    158                      *( pRecvPtr + PcCmdCounter++ ) = ch;      
    159                       PcCmdDataLen = ch ; // global
    160                       state_mac    = CMD_STAT_DATA ;
    161                    
    162                  break ;
    163                  
    164                  case CMD_STAT_DATA :
    165                      *( pRecvPtr + PcCmdCounter++ ) = ch;
    166                      if( PcCmdCounter >= MAXBUFLEN ) { //check verflow             
    167                         state_mac = CMD_STAT_SYNC1; 
    168                         OSMemPut( pMEM_Part_MsgUART, pRecvPtr ); 
    169                      } else if(PcCmdCounter >= PcCmdDataLen + 2) { // data over, the check sum will be followed              
    170                          state_mac =  CMD_STAT_CHECKSUM ;
    171                      }
    172                  break ;
    173                  
    174                  case CMD_STAT_CHECKSUM :   
    175                      pNoahCmd = (NOAH_CMD *)pRecvPtr;             
    176                      pNoahCmd->checkSum = ch ;   //get check sum data            
    177                      
    178                      if( PcCmdCounter >= MAXBUFLEN ) { //check verflow            
    179                          state_mac = CMD_STAT_SYNC1; 
    180                          OSMemPut( pMEM_Part_MsgUART, pRecvPtr );
    181                          
    182                      }  else {         
    183                          state_mac    = CMD_STAT_SYNC1 ; //reset state machine  
    184                          PcCmdCounter = 0 ;  
    185                          PcCmdDataLen = 0 ;
    186                          
    187                          err  = OSQPost( pCMD_Read->pEvent, pRecvPtr); // EVENT_MsgQ_PCUART2Noah  //Send valid CMD inf to Uart2task0 Messege Queue
    188                          if( OS_ERR_NONE == err )  {              
    189                             pRecvPtr  = NULL;                 
    190                          } else {  
    191                             OSMemPut( pMEM_Part_MsgUART, pRecvPtr );              
    192                          }
    193                      }
    194                  break ;
    195                  
    196                  case CMD_STAT_FRAM :   
    197                  break;
    198                  
    199                  default :
    200                      state_mac     = CMD_STAT_SYNC1;
    201                      PcCmdCounter  = 0 ;
    202                  break ;
    203              }
    204              
    205              pCMD_Read->state_mac       = state_mac ;
    206              pCMD_Read->pRecvPtr        = pRecvPtr;
    207              pCMD_Read->PcCmdCounter    = PcCmdCounter;
    208              pCMD_Read->PcCmdDataLen    = PcCmdDataLen;    
    209              
    210          }
    211          
    212          
    213          
    214          /*
    215          *********************************************************************************************************
    216          *                                           CheckSum()
    217          *
    218          * Description : calculate check sum for a specified data 
    219          * Argument(s) : init_data :  check sum data for previous data
    220          *               pdata     :  pointer to the data address
    221          *               length    :  data length 
    222          * Return(s)   : checksum data: 1 byte 
    223          *
    224          * Note(s)     : None.
    225          *********************************************************************************************************
    226          */
    227          CPU_INT08U  CheckSum (CPU_INT08U   init_data, 
    228                                CPU_INT08U  *pdata, 
    229                                CPU_INT16U   length)
    230          {
    231              
    232              CPU_INT16U i;
    233              CPU_INT08U checksum;
    234              
    235              checksum = init_data;   
    236              
    237              for( i = 0; i < length; i++ ) {      
    238          	    if (checksum & 0x01) {
    239                	    checksum = (checksum >> 1) + 0x80 ;
    240                      
    241                  } else {
    242                      checksum >>= 1;
    243                      
    244                  }
    245          	    checksum += *pdata++;
    246                  
    247              }
    248              
    249              return( checksum ) ;
    250              
    251          }
    252          
    253          
    254          /*
    255          *********************************************************************************************************
    256          *                                           pcSendDateToBuf()
    257          *
    258          * Description : Code data as Noah protocol defines and send out to transmit task for transmission
    259          * Argument(s) : *pOS_EVENT     :  pointer to the event that load the data 
    260          *               frame_head     :  frame type flag
    261          *               *pdat          :  pointer to thd data to send
    262          *               data_length    :  data length in bytes
    263          *               msg_post_mode  :  for urgent transmit use, 0 - OS_POST_OPT_NONE, 1 - OS_POST_OPT_FRONT
    264          *               *pex_dat       :  extral data need to sent before data and after head bytes
    265          *               ex_data_length :  extral data length
    266          * Return(s)   : NO_ERR :   execute successfully
    267          *               others :   =error code . 
    268          *
    269          * Note(s)     : None.
    270          *********************************************************************************************************
    271          */
    272          CPU_INT08U  pcSendDateToBuf (OS_EVENT    *pOS_EVENT, 
    273                                       CPU_INT08U   frame_head, 
    274                                       CPU_INT08U  *pdat, 
    275                                       CPU_INT08U   data_length, 
    276                                       CPU_INT08U   msg_post_mode,
    277                                       CPU_INT08U  *pex_dat,
    278                                       CPU_INT08U   ex_data_length
    279                                       )
    280          {
    281              
    282              CPU_INT08U  *pSendPtr;
    283              CPU_INT08U  *pMemPtr;    
    284              CPU_INT08U  err;
    285              CPU_INT08U  i, opt;
    286              CPU_INT08U  frame_type;    
    287              
    288              err         = 0;  
    289              pSendPtr    = NULL;
    290              pMemPtr     = NULL;
    291              opt         = ( msg_post_mode == 0 ) ? OS_POST_OPT_NONE : OS_POST_OPT_FRONT ; 
    292              frame_type  = GET_FRAME_TYPE( frame_head );
    293              
    294              if( ( data_length == 0 || pdat == NULL || (data_length + ex_data_length > NOAH_CMD_DATA_MLEN) )  && 
    295                  (frame_type == FRAM_TYPE_DATA) )  {            
    296                  err = SEND_DATA_LEN_ERR;    
    297                  
    298              } else {  
    299                  
    300                  for( i = 0 ; i < 100 ; i++ ) { //delay 500ms waitting for free Mem 
    301                      pMemPtr = (void *)OSMemGet(pMEM_Part_MsgUART,&err);
    302                      if( OS_ERR_NONE == err ) {
    303                          break;
    304                      }
    305                      if( OS_ERR_MEM_NO_FREE_BLKS == err ) {
    306                          OSTimeDly(5);
    307                      } else {   
    308                          return err;    
    309                      }
    310                  }
    311                  if( i >= 100 ) {
    312                      return err;
    313                  }
    314                  pSendPtr  =  pMemPtr  ;   
    315                
    316                  if( frame_type == FRAM_TYPE_DATA) {      
    317                      *pSendPtr++ = frame_head;
    318                      *pSendPtr++ = data_length + ex_data_length;         
    319                       while(ex_data_length-- > 0) {
    320                          *pSendPtr++ = *pex_dat++ ;                 
    321                      }   
    322                      while(data_length-- > 0) {
    323                          *pSendPtr++ = *pdat++ ;                 
    324                      }    
    325                      *pSendPtr++ = 0; // here use 0 as checksum, and will do calcute sum in task uart tx  
    326                      
    327                  } else {
    328                      *pSendPtr++ = frame_head;   
    329                      *pSendPtr++ = frame_head; 
    330                      
    331                  } 
    332                  
    333                  err = OSQPostOpt( pOS_EVENT, pMemPtr, opt );   //EVENT_MsgQ_Noah2PCUART send data to Uart2task0 message queue       
    334                  if( OS_ERR_NONE != err )  {   
    335                      OSMemPut( pMEM_Part_MsgUART, pMemPtr ); 
    336                      
    337                  }
    338                  
    339              }
    340              
    341              return  err;
    342              
    343          }
    344          
    345          
    346          /*
    347          *********************************************************************************************************
    348          *                                           EMB_Data_Check()
    349          *
    350          * Description : Check the received data after Noah protocol decode if EMB format complete or not.
    351          * Argument(s) : *pNoahCmd :  pointer to the NOAH_CMD type structure that contains the data 
    352          *               *pEBuf    :  pointer to the EMB_BUF data where decoded data will be stored
    353          *                delay    :  extra data in NOAH_CMD buf that not needed
    354          * Return(s)   : NO_ERR :   execute successfully
    355          *               others :   =error code . 
    356          *
    357          * Note(s)     : None.
    358          *********************************************************************************************************
    359          */
    360          CPU_INT08U  EMB_Data_Check (NOAH_CMD   *pNoahCmd, 
    361                                      EMB_BUF    *pEBuf,
    362                                      CPU_INT08U  delay)
    363          {
    364            
    365              CPU_INT08U   err;
    366              CPU_INT16U   data_cmd_len;
    367              CPU_INT08U  *p_data_cmd;
    368            
    369              err          = NO_ERR;
    370              p_data_cmd   = pNoahCmd->Data ;
    371              data_cmd_len = pNoahCmd->DataLen ;   
    372              
    373              p_data_cmd  += delay;
    374              data_cmd_len-= delay;
    375              
    376              if( pEBuf->state ) { //new data pack        
    377               
    378                  if( *p_data_cmd++ == EMB_DATA_FRAME ) { //sync data          
    379                      pEBuf->index   = *p_data_cmd++ ;
    380                      pEBuf->index  += ((*p_data_cmd++)<<8) ; 
    381                      pEBuf->length  = pEBuf->index; //reserve length
    382                      if( pEBuf->length > EMB_BUF_SIZE ) {
    383                          APP_TRACE_INFO(("EMB data length exceed the Max %d B\r\n",EMB_BUF_SIZE));
    384                          return EMB_LEN_OERFLOW_ERR ;
    385                      }
    386                      pEBuf->pdata   = &(pEBuf->data[0]); 
    387                      if( pEBuf->index > (data_cmd_len - 3) ) { // big data package
    388                          pEBuf->index -= data_cmd_len - 3 ;
    389                          pEBuf->state = false; //session not done.
    390                      }
    391                      memcpy( pEBuf->pdata, p_data_cmd, data_cmd_len-3 );
    392                      pEBuf->pdata += data_cmd_len-3 ;
    393                      
    394                  } else {          
    395                      err = EMB_FORMAT_ERR; 
    396                      
    397                  }
    398                
    399              } else { //next data pack
    400          
    401                  if( pEBuf->index > data_cmd_len ) {
    402                      pEBuf->index -=  data_cmd_len;        
    403                      memcpy( pEBuf->pdata, p_data_cmd, data_cmd_len );
    404                      pEBuf->pdata += data_cmd_len ;
    405                  } else {
    406                      memcpy( pEBuf->pdata, p_data_cmd, pEBuf->index );
    407                      pEBuf->state = true;  //session done.           
    408                  }
    409                  
    410              }
    411              
    412              return err;
    413            
    414            
    415          }
    416          
    417          
    418          
    419          /*
    420          *********************************************************************************************************
    421          *                                           Noah_CMD_Parse_Ruler()
    422          *
    423          * Description : Process decoded data from ruler based on Noah protocol 
    424          * Argument(s) : *pNoahCmd      :  pointer to the NOAH_CMD type structure that contains the data 
    425          *               *pSessionDone  :  pointer to data that indicate if one command session is finished
    426          * Return(s)   : NO_ERR :   execute successfully
    427          *               others :   =error code . 
    428          *
    429          * Note(s)     : communication with ruler
    430          *               This routine do NOT support reentrance
    431          *********************************************************************************************************
    432          */
    433          CPU_INT08U  Noah_CMD_Parse_Ruler (NOAH_CMD    *pNoahCmd,                                 
    434                                            CPU_INT08U  *pSessionDone)
    435          {
    436              
    437              CPU_INT08U    err;
    438              CPU_INT08U    index;
    439              EMB_BUF      *pEBuf_Data;         
    440              
    441              err         = NO_ERR ;  
    442              index       = 0;    
    443              pEBuf_Data  = &Emb_Buf_Data;  //Global var      
    444               
    445              switch( pNoahCmd->Data[0] )  {         
    446                  case CMD_D_ACK : //CMD parse result 
    447                      if( pNoahCmd->DataLen == 2 ) {
    448                          err = pNoahCmd->Data[1];
    449                      }
    450                  break ;
    451                  
    452                  case CMD_G_ACK :
    453                      if( pNoahCmd->DataLen == 2 ) {
    454                          err = pNoahCmd->Data[1];
    455                          *pSessionDone = 1 ; //session done , not data back
    456                      }
    457                  break ;        
    458           
    459                  case RULER_CMD_READ_MIC_CALI_DATA :
    460                      index += 1;        
    461                  case RULER_CMD_RAED_RULER_INFO :  
    462                      index += 1;
    463                      err = EMB_Data_Check( pNoahCmd, pEBuf_Data, index );       
    464                      if( err != OS_ERR_NONE ) {
    465                          Init_EMB_BUF( pEBuf_Data ); 
    466                      } else {
    467                          if( pEBuf_Data->state ) { // EMB data complete               
    468                              *pSessionDone = 1 ; //session done , not data back 
    469                          }                    
    470                      }    
    471                  break ;
    472                  
    473                  case RULER_CMD_RAED_RULER_STATUS :
    474                      pEBuf_Data->data[0] = pNoahCmd->Data[1];
    475                      pEBuf_Data->data[1] = pNoahCmd->Data[2];
    476                      *pSessionDone = 1 ; 
    477                  break ;
    478          
    479                  case RULER_CMD_GET_RULER_TYPE :
    480                      pEBuf_Data->data[0] = pNoahCmd->Data[1];
    481                      *pSessionDone = 1 ; 
    482                  break ;   
    483             
    484                  case RULER_CMD_GET_RULER_VERSION :            
    485                      pEBuf_Data->length = pNoahCmd->DataLen;            
    486                      memcpy( pEBuf_Data->data, &(pNoahCmd->Data[1]), pNoahCmd->DataLen );
    487                      pEBuf_Data->data[pNoahCmd->DataLen] = '0';
    488                      *pSessionDone = 1 ; 
    489                  break ;
    490              
    491                  case RULER_CMD_SET_RULER :           
    492                       pEBuf_Data->data[0] = pNoahCmd->Data[1];
    493                      *pSessionDone = 1 ; 
    494                  break;
    495                  
    496                  default :
    497                      err = CMD_NOT_SURRPORT ;
    498                  break ;
    499                  
    500              }
    501                 
    502              return( err ) ;
    503              
    504          }
    505          
    506          
    507          /*
    508          *********************************************************************************************************
    509          *                                           Send_DACK()
    510          *
    511          * Description : Package and send DACK command  
    512          * Argument(s) : error_id :  error number as define
    513          * Return(s)   : None. 
    514          *
    515          * Note(s)     : None.
    516          *********************************************************************************************************
    517          */
    518          void  Send_DACK (CPU_INT08U  error_id)
    519          {
    520             
    521              CPU_INT08U   DAckBuf[2]; 
    522              
    523              DAckBuf[0] = CMD_D_ACK ;
    524              DAckBuf[1] = error_id ;
    525              APP_TRACE_DBG(("%2x ",error_id));
    526              pcSendDateToBuf( EVENT_MsgQ_Noah2PCUART, FRAM_TYPE_DATA, DAckBuf, 2, 0, NULL, 0 ) ; //send data: command error status  
    527             
    528              
    529          }
    530          
    531          
    532          /*
    533          *********************************************************************************************************
    534          *                                           Send_GACK()
    535          *
    536          * Description : Package and send GACK command  
    537          * Argument(s) : error_id :  error number as define
    538          * Return(s)   : None. 
    539          *
    540          * Note(s)     : None.
    541          *********************************************************************************************************
    542          */
    543          void  Send_GACK (CPU_INT08U  error_id)
    544          {
    545            
    546              CPU_INT08U   GAckBuf[2]; 
    547              
    548              GAckBuf[0] = CMD_G_ACK ;
    549              GAckBuf[1] = error_id ;
    550              APP_TRACE_DBG(("%2x ",error_id));
    551              pcSendDateToBuf( EVENT_MsgQ_Noah2PCUART, FRAM_TYPE_DATA, GAckBuf, 2, 0, NULL, 0 ) ; 
    552               
    553              
    554          }
    555          
    556          
    557          /*
    558          *********************************************************************************************************
    559          *                                           EMB_Data_Build()
    560          *
    561          * Description :  Code the data as EMB format for specified command 
    562          * Argument(s) : *pEBuf    :  pointer to the EMB_BUF type structure where built new data will be stored
    563          *                cmd_type :  commmand type that need the EMB data
    564          * Return(s)   : NO_ERR :   execute successfully
    565          *               others :   =error code . 
    566          *
    567          * Note(s)     : None.
    568          *********************************************************************************************************
    569          */
    570          static CPU_INT08U  EMB_Data_Build (EMB_BUF     *pEBuf, 
    571                                             CPU_INT08U   cmd_type)
    572          {
    573              
    574              CPU_INT08U   err;
    575              CPU_INT32S   pos;  
    576              CPU_INT08U  *pChar;
    577              emb_builder  builder;
    578              CPU_INT08U   ver_buf[25];  //sizeof(Audio_Version) + szieof(fw_version)
    579                  
    580              err      =  NO_ERR ;
    581              pChar    =  &(pEBuf->data[0]);    
    582              *pChar   =  EMB_DATA_FRAME;
    583              pChar   +=  3;
    584              
    585              switch( cmd_type ){      
    586          
    587                  case DATA_AB_STATUS :       	
    588                      pos = emb_init_builder(pChar, EMB_BUF_SIZE, cmd_type, &builder);
    589                      pos = emb_append_attr_uint(&builder, pos, 1, Global_Bridge_POST);
    590                      pos = emb_append_attr_uint(&builder, pos, 2, *(CPU_INT32U *)(&Global_Ruler_State) ); 
    591                      pos = emb_append_attr_uint(&builder, pos, 3, *(CPU_INT32U *)(&Global_Mic_State));    
    592                      pos = emb_append_end(&builder, pos);
    593                      pEBuf->data[1] = pos & 0xFF;    
    594                      pEBuf->data[2] = (pos>>8) & 0xFF; 
    595                      pEBuf->length = pos + 3;            
    596                  break;
    597                    
    598                  case DATA_AB_INFO : 
    599                      pos = emb_init_builder(pChar, EMB_BUF_SIZE, cmd_type, &builder);
    600                      pos = emb_append_attr_string(&builder, pos, 1, hw_model);
    601                      pos = emb_append_attr_string(&builder, pos, 2, hw_version); 
    602                      strcpy( (char*)ver_buf, (char*)fw_version );  
    603                      strcat( (char*)ver_buf, (char*)Audio_Version ); 
    604                      pos = emb_append_attr_string(&builder, pos, 3, (const char*)ver_buf);    
    605                      pos = emb_append_end(&builder, pos);
    606                      pEBuf->data[1] = pos & 0xFF;    
    607                      pEBuf->data[2] = (pos>>8) & 0xFF; 
    608                      pEBuf->length = pos + 3;          
    609                  break;
    610                  
    611              }     
    612           
    613              return err;
    614            
    615          }
    616          
    617          
    618          /*
    619          *********************************************************************************************************
    620          *                                           EMB_Data_Parse()
    621          *
    622          * Description : Decode EMB data and do the command in the data.
    623          * Argument(s) : *pEBuf_Cmd    :  pointer to the EMB_BUF type structure that contains the data 
    624          * Return(s)   : NO_ERR :   execute successfully
    625          *               others :   =error code . 
    626          *
    627          * Note(s)     : This routine do NOT support reentrance
    628          *********************************************************************************************************
    629          */
    630          CPU_INT08U  EMB_Data_Parse (EMB_BUF  *pEBuf_Cmd) 
    631          {
    632              
    633              CPU_INT08U    err; 
    634              CPU_INT08U    cmd_type; 
    635              CPU_INT32S    temp, temp2;      
    636              emb_t         root;
    637              PCCMDDAT      PCCmd;
    638              EMB_BUF      *pEBuf_Data;
    639              CPU_INT08U    buf[3];
    640              CPU_INT08U   *pdata;
    641              CPU_INT16U    data_length;
    642              
    643              err  =  NO_ERR;    
    644              pEBuf_Data = &Emb_Buf_Data; 
    645             
    646              emb_attach( &(pEBuf_Cmd->data[0]), pEBuf_Cmd->length, &root );        
    647              cmd_type = emb_get_id(&root);   
    648              
    649              switch( cmd_type )  {
    650                  
    651                  case PC_CMD_SET_AUDIO_CFG : 
    652                      Send_DACK(err);
    653                      temp = emb_get_attr_int(&root, 1, -1);
    654                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }
    655                      PCCmd.audio_cfg.type = (CPU_INT08U)temp;            
    656                      temp = emb_get_attr_int(&root, 2, -1);
    657                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }
    658                      PCCmd.audio_cfg.sr = (CPU_INT16U)temp;            
    659                      temp = emb_get_attr_int(&root, 3, -1);
    660                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }
    661                      PCCmd.audio_cfg.channels = (CPU_INT08U)temp; 
    662                      temp = emb_get_attr_int(&root, 4, 0);            
    663                      PCCmd.audio_cfg.lin_ch_mask = (CPU_INT08U)temp; 
    664                      err = Setup_Audio( &PCCmd.audio_cfg );
    665                      Send_GACK(err);
    666             
    667                  break ;
    668                  
    669                  case PC_CMD_START_AUDIO :
    670                      Send_DACK(err);
    671                      temp = emb_get_attr_int(&root, 1, -1);
    672                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }
    673                      PCCmd.start_audio.type = (CPU_INT08U)temp;             
    674                      temp = emb_get_attr_int(&root, 2, -1);
    675                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }
    676                      PCCmd.start_audio.padding = (CPU_INT08U)temp; 
    677                      err = Ruler_Active_Control(1);              
    678                      if( err != NO_ERR ) { Send_GACK(err); break; }            
    679                      err = Start_Audio( PCCmd.start_audio );
    680                      Send_GACK(err);
    681                  break ;
    682                  
    683                  case PC_CMD_STOP_AUDIO :
    684                      Send_DACK(err);  
    685                      err = Ruler_Active_Control(0);                 
    686                      if( err != NO_ERR ) { Send_GACK(err); break; }
    687                      err = Stop_Audio(); 
    688                      Send_GACK(err);
    689                  break ;    
    690                  
    691                  case PC_CMD_RESET_AUDIO :
    692                      Send_DACK(err);           
    693                      err = Reset_Audio(); 
    694                      Send_GACK(err);
    695                  break ; 
    696                  ////////////////////////////////////////////////////////////////////////
    697                  case PC_CMD_RAED_RULER_INFO : 
    698                      Send_DACK(err);             
    699                      temp = emb_get_attr_int(&root, 1, -1);
    700                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }            
    701                      err = Read_Ruler_Info( temp );              
    702                      if( err != NO_ERR ) { Send_GACK(err); break; }  
    703                      emb_attach( &(pEBuf_Data->data[0]), pEBuf_Data->length, &root );
    704                      emb_get_node_replace(&root, 1, temp);
    705                      buf[0] = EMB_DATA_FRAME ;
    706                      buf[1] = (pEBuf_Data->length) & 0xFF;    
    707                      buf[2] = ((pEBuf_Data->length)>>8) & 0xFF;  
    708                      err = pcSendDateToBuf( EVENT_MsgQ_Noah2PCUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ;            
    709                      if( OS_ERR_NONE == err ) {  
    710                          pdata = pEBuf_Data->data;
    711                          data_length = pEBuf_Data->length;
    712                          while( data_length > 0 ){        
    713                              temp = data_length > NOAH_CMD_DATA_MLEN ? NOAH_CMD_DATA_MLEN : data_length ; 
    714                              err = pcSendDateToBuf( EVENT_MsgQ_Noah2PCUART, FRAM_TYPE_DATA, pdata, temp, 0, NULL, 0 ) ; 
    715                              if( OS_ERR_NONE != err ) { break;}
    716                              data_length -= temp;
    717                              pdata += temp;
    718                          }  
    719                      }  
    720                      Send_GACK(err);          
    721                  break ;
    722                 
    723                  case PC_CMD_WRITE_RULER_INFO : 
    724                      Send_DACK(err); 
    725                      temp = emb_get_attr_int(&root, 1, -1);            
    726                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }            
    727                      err = Write_Ruler_Info( temp ); 
    728                      Send_GACK(err);             
    729                  break ;
    730          
    731                  ////////////////////////////////////////////////////////////////////////
    732                  case PC_CMD_READ_MIC_CALI_DATA :  
    733                      Send_DACK(err);             
    734                      temp = emb_get_attr_int(&root, 1, -1);
    735                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR);  break; } 
    736                      temp2 = emb_get_attr_int(&root, 2, -1);            
    737                      if(temp2 == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }            
    738                      err = Read_Mic_Cali_Data( temp, temp2 );             
    739                      if( err != NO_ERR ) { Send_GACK(err); break; }  
    740                      emb_attach( &(pEBuf_Data->data[0]), pEBuf_Data->length, &root );
    741                      emb_get_node_replace(&root, 1, temp);
    742                      emb_get_node_replace(&root, 2, temp2);
    743                      buf[0] = EMB_DATA_FRAME ;
    744                      buf[1] = (pEBuf_Data->length) & 0xFF;    
    745                      buf[2] = ((pEBuf_Data->length)>>8) & 0xFF;  
    746                      err = pcSendDateToBuf( EVENT_MsgQ_Noah2PCUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ;            
    747                      if( OS_ERR_NONE == err ) {  
    748                          pdata = pEBuf_Data->data;
    749                          data_length = pEBuf_Data->length;
    750                          while( data_length > 0 ){        
    751                              temp = data_length > NOAH_CMD_DATA_MLEN ? NOAH_CMD_DATA_MLEN : data_length ; 
    752                              err = pcSendDateToBuf( EVENT_MsgQ_Noah2PCUART, FRAM_TYPE_DATA, pdata, temp, 0, NULL, 0 ) ; 
    753                              if( OS_ERR_NONE != err ) { break;}
    754                              data_length -= temp;
    755                              pdata += temp;
    756                          }  
    757                      }
    758                      Send_GACK(err);            
    759                  break ;
    760          
    761                  case PC_CMD_WRITE_MIC_CALI_DATA :   
    762                      Send_DACK(err); 
    763                      temp = emb_get_attr_int(&root, 1, -1);            
    764                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }   
    765                      temp2 = emb_get_attr_int(&root, 2, -1);            
    766                      if(temp2 == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }          
    767                      err = Write_Mic_Cali_Data( temp, temp2 ); 
    768                      Send_GACK(err);              
    769                  break ;
    770                  ////////////////////////////////////////////////////////////////////////
    771                  case PC_CMD_TOGGLE_MIC : 
    772                      Send_DACK(err);
    773                      temp = emb_get_attr_int(&root, 1, -1);
    774                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR); break; }
    775                      PCCmd.toggle_mic.ruler_id = (CPU_INT08U)temp;
    776                      temp = emb_get_attr_int(&root, 2, -1);
    777                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR); break; }
    778                      PCCmd.toggle_mic.mic_id = (CPU_INT08U)temp;
    779                      temp = emb_get_attr_int(&root, 3, -1);
    780                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR); break; }
    781                      PCCmd.toggle_mic.on_off = (CPU_INT08U)temp;      
    782                      err = Toggle_Mic( &PCCmd.toggle_mic ) ;
    783                      Send_GACK(err);    
    784                  break ;
    785                  
    786                  case PC_CMD_RESET_MIC :
    787                      Send_DACK(err);
    788                      temp = emb_get_attr_int(&root, 1, -1);
    789                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR); break; }            
    790                      err = Reset_Mic_Mask( (unsigned int*)&temp ) ;
    791                      Send_GACK(err);    
    792                  break ;
    793            
    794                  case PC_CMD_SET_VOLUME :
    795                      Send_DACK(err);
    796                      temp = emb_get_attr_int(&root, 1, -1);
    797                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR); break; }
    798                      PCCmd.set_volume.mic = (CPU_INT32U)temp;
    799                      temp = emb_get_attr_int(&root, 2, -1);
    800                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR); break; }
    801                      PCCmd.set_volume.lout = (CPU_INT32U)temp;
    802                      temp = emb_get_attr_int(&root, 3, -1);
    803                      if(temp == -1 ) { Send_GACK(EMB_CMD_ERR); break; }
    804                      PCCmd.set_volume.spk = (CPU_INT32U)temp;      
    805                      err = Set_Volume( &PCCmd.set_volume ) ;
    806                      Send_GACK(err);    
    807                  break ;
    808                  
    809                  case PC_CMD_READ_AB_STATUS : 
    810                       Send_DACK(err);             
    811                       err = EMB_Data_Build( pEBuf_Data, DATA_AB_STATUS );               
    812                       pcSendDateToBuf( EVENT_MsgQ_Noah2PCUART, FRAM_TYPE_DATA, pEBuf_Data->data, pEBuf_Data->length, 0, NULL, 0 ) ; 
    813                       Send_GACK(err);            
    814                  break ;
    815            
    816                  case PC_CMD_RAED_AB_INFO :   
    817                       Send_DACK(err);             
    818                       err = EMB_Data_Build( pEBuf_Data, DATA_AB_INFO );             
    819                       pcSendDateToBuf( EVENT_MsgQ_Noah2PCUART, FRAM_TYPE_DATA, pEBuf_Data->data, pEBuf_Data->length, 0, NULL, 0 ) ; 
    820                       Send_GACK(err);            
    821                  break ;      
    822                  ////////////////////////////////////////////////////////////////////////
    823                  case PC_CMD_RAW_DATA_TRANS :   
    824                       Send_DACK(err);  
    825                       
    826                       Send_GACK(err);              
    827                  break ;  
    828                 
    829                  case PC_CMD_DOWNLOAD_RULER_FW :
    830                       Send_DACK(err);   
    831                       temp = emb_get_attr_int(&root, 1, -1);            
    832                       if(temp == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }  
    833                       unsigned char *pBin,*pStr;
    834                       unsigned int   size; 
    835                       pBin = (unsigned char *)emb_get_attr_binary(&root, 2, (int *)&size);            
    836                       if(pBin == NULL ) { Send_GACK(EMB_CMD_ERR);  break; }              
    837                       pStr = (unsigned char *)emb_get_attr_string(&root, 3);            
    838                       if(pStr == NULL ) { Send_GACK(EMB_CMD_ERR);  break; }            
    839                       err = Save_Ruler_FW( temp, pBin, pStr, size );             
    840                       Send_GACK(err);             
    841                  break ; 
    842                  
    843                  case PC_CMD_UPDATE_RULER_FW :   
    844                       Send_DACK(err);   
    845                       temp = emb_get_attr_int(&root, 1, -1);            
    846                       if(temp == -1 ) { Send_GACK(EMB_CMD_ERR);  break; }                  
    847                       err = Update_Ruler_FW( temp );          
    848                       Send_GACK(err);             
    849                  break ;  
    850                  
    851                  case PC_CMD_UPDATE_AB_FW :   
    852                       Send_DACK(err);  
    853                       
    854                       Send_GACK(err);               
    855                  break ;         
    856                  
    857                  default :            
    858                      err = CMD_NOT_SURRPORT ;
    859                      Send_DACK(err);
    860                      
    861                  break ;
    862                  
    863              }
    864              
    865              return err;
    866          
    867          }
    868          
    869          /*
    870          *********************************************************************************************************
    871          *                                           AB_Status_Change_Report()
    872          *
    873          * Description : Check ruler status, and report to PC only if any ruler's  attach/detach  status changed 
    874          * Argument(s) : None.
    875          * Return(s)   : NO_ERR :   execute successfully
    876          *               others :   =error code . 
    877          * Note(s)     : None.
    878          *********************************************************************************************************
    879          */
    880          static CPU_INT08U Ruler_State_Previous[4];    //ruler previous status 
    881          
    882          CPU_INT08U  AB_Status_Change_Report (void)
    883          {
    884              
    885              CPU_INT08U    err; 
    886              EMB_BUF      *pEBuf;   
    887              CPU_INT08U    flag; 
    888              CPU_INT08U    i;   
    889              
    890              err   = NO_ERR;   
    891              pEBuf = &Emb_Buf_Cmd;
    892              flag  = 0;    
    893          
    894              for( i = 0; i < 4; i++ ) {
    895                  if( (Ruler_State_Previous[i] == 0) && (Global_Ruler_State[i] > 1) ||
    896                      (Ruler_State_Previous[i] > 1)  && (Global_Ruler_State[i] == 0) ) {
    897                      flag = 1; 
    898                      Ruler_State_Previous[i] =  Global_Ruler_State[i];   
    899                  }
    900              }
    901              
    902              if( flag == 0 ) {//no state changed
    903                 return err;
    904              }
    905              
    906              if( Global_Conn_Ready == 0 || Global_Idle_Ready == 0) { //no connection setup, or commu busy
    907                  return err;
    908              } 
    909              Global_Idle_Ready = 0 ;
    910              
    911              err = EMB_Data_Build( pEBuf, DATA_AB_STATUS );  
    912              if( err != NO_ERR ) {
    913                  return err;
    914              }
    915              
    916              err = pcSendDateToBuf( EVENT_MsgQ_Noah2PCUART, FRAM_TYPE_DATA, pEBuf->data, pEBuf->length, 0, NULL, 0 ) ;   
    917              
    918              return err;
    919            
    920          }
    921          
    922              
    923          
    924          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   AB_Status_Change_Report
        32   -> EMB_Data_Build
        32   -> pcSendDateToBuf
       4   CheckSum
      64   EMB_Data_Build
        64   -> emb_append_attr_string
        64   -> emb_append_attr_uint
        64   -> emb_append_end
        64   -> emb_init_builder
        64   -> strcat
        64   -> strcpy
      32   EMB_Data_Check
        32   -> BSP_Ser_Printf
        32   -> memcpy
     176   EMB_Data_Parse
       176   -> EMB_Data_Build
       176   -> Read_Mic_Cali_Data
       176   -> Read_Ruler_Info
       176   -> Reset_Audio
       176   -> Reset_Mic_Mask
       176   -> Ruler_Active_Control
       176   -> Save_Ruler_FW
       176   -> Send_DACK
       176   -> Send_GACK
       176   -> Set_Volume
       176   -> Setup_Audio
       176   -> Start_Audio
       176   -> Stop_Audio
       176   -> Toggle_Mic
       176   -> Update_Ruler_FW
       176   -> Write_Mic_Cali_Data
       176   -> Write_Ruler_Info
       176   -> emb_attach
       176   -> emb_get_attr_binary
       176   -> emb_get_attr_int
       176   -> emb_get_attr_string
       176   -> emb_get_id
       176   -> emb_get_node_replace
       176   -> pcSendDateToBuf
       0   Init_CMD_Read
       0   Init_EMB_BUF
      24   Noah_CMD_Parse_Ruler
        24   -> EMB_Data_Check
        24   -> Init_EMB_BUF
        24   -> memcpy
      64   Noah_CMD_Read
        64   -> OSMemGet
        64   -> OSMemPut
        64   -> OSMemQuery
        64   -> OSQPost
      24   Send_DACK
        24   -> pcSendDateToBuf
      24   Send_GACK
        24   -> pcSendDateToBuf
      48   pcSendDateToBuf
        48   -> OSMemGet
        48   -> OSMemPut
        48   -> OSQPostOpt
        48   -> OSTimeDly


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      40  ?<Constant "EMB data length excee...">
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
     396  AB_Status_Change_Report
     108  CheckSum
     404  EMB_Data_Build
     460  EMB_Data_Check
    2900  EMB_Data_Parse
      40  Init_CMD_Read
      36  Init_EMB_BUF
     388  Noah_CMD_Parse_Ruler
     784  Noah_CMD_Read
       4  Ruler_State_Previous
      76  Send_DACK
      76  Send_GACK
     508  pcSendDateToBuf

 
     4 bytes in section .bss
    40 bytes in section .rodata
 6 236 bytes in section .text
 
 6 236 bytes of CODE  memory
    40 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
