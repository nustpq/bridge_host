###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        15/Dec/2014  17:50:05
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\twid.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\twid.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\twid.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\twid.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\twid.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include <bsp.h>
     35          #include "twi.h" 
     36          #include "twid.h" 
     37          
     38          
     39          /// TWI peripheral redefinition if needed
     40          #if !defined(AT91C_BASE_TWI) && defined(AT91C_BASE_TWI0)
     41              #define AT91C_BASE_TWI      AT91C_BASE_TWI0
     42              #define AT91C_ID_TWI        AT91C_ID_TWI0
     43              #define PINS_TWI            PINS_TWI0
     44          #endif
     45          
     46          
     47          #define TWITIMEOUTMAX   48000  // 1ms timeout @ 48MHz MIP
     48          //#define TWI_V3XX   // send stop, A3 no need to do this
     49          #define TWI_ASYNC_MODE // Asynchronous transfer enabled
     50          
     51          
     52          /// Pio pins to configure.
     53          static const Pin twi_pins[] = {PINS_TWI};
     54          
     55          /// TWI driver instance.
     56          Twid  twid;
     57          
     58          Async twi_async ;     
     59          
     60          //------------------------------------------------------------------------------
     61          //         Local types
     62          //------------------------------------------------------------------------------
     63          
     64          /// TWI driver callback function.
     65          typedef void (*TwiCallback)(Async *);
     66          
     67          //------------------------------------------------------------------------------
     68          /// TWI asynchronous transfer descriptor.
     69          //------------------------------------------------------------------------------
     70          typedef struct _AsyncTwi {
     71          
     72              /// Asynchronous transfer status.
     73              volatile unsigned char status;
     74              // Callback function to invoke when transfer completes or fails.
     75              TwiCallback callback;
     76              /// Pointer to the data buffer.
     77              unsigned char *pData;
     78              /// Total number of bytes to transfer.
     79              unsigned int num;
     80              /// Number of already transferred bytes.
     81              unsigned int transferred;    
     82             
     83          
     84          } AsyncTwi;
     85          
     86          
     87          OS_EVENT *TWI_Sem_lock; //sem for TWI
     88          OS_EVENT *TWI_Sem_done; //sem for TWI
     89          
     90          //------------------------------------------------------------------------------
     91          //         Global functions
     92          //------------------------------------------------------------------------------
     93          
     94          //------------------------------------------------------------------------------
     95          /// Initializes a TWI driver instance, using the given TWI peripheral. The
     96          /// peripheral must have been initialized properly before calling this function.
     97          /// \param pTwid  Pointer to the Twid instance to initialize.
     98          /// \param pTwi  Pointer to the TWI peripheral to use.
     99          //------------------------------------------------------------------------------
    100          void TWID_Initialize(Twid *pTwid, AT91S_TWI *pTwi)
    101          {
    102              //TRACE_DEBUG("TWID_Initialize()\n\r");
    103              //SANITY_CHECK(pTwid);
    104              //SANITY_CHECK(pTwi); 
    105            
    106              // Initialize driver
    107              pTwid->pTwi         = pTwi;
    108              pTwid->pTransfer    = NULL;
    109             }
    110          
    111          
    112          
    113          //------------------------------------------------------------------------------
    114          /// Interrupt handler for a TWI peripheral. Manages asynchronous transfer
    115          /// occuring on the bus. This function MUST be called by the interrupt service
    116          /// routine of the TWI peripheral if asynchronous read/write are needed.
    117          //------------------------------------------------------------------------------
    118          
    119          void TWID_Handler( void )
    120          {
    121              unsigned int status;
    122              AsyncTwi  *pTransfer;
    123              AT91S_TWI *pTwi     ;
    124              
    125              pTransfer   = (AsyncTwi *) twid.pTransfer;
    126              pTwi        =              twid.pTwi; 
    127              status      = TWI_GetMaskedStatus(pTwi);   // Retrieve interrupt status
    128            
    129              
    130                  //if NAK detected, end operations
    131              if( TWI_STATUS_NACK(status) ) { 
    132                
    133                  //BSP_IntClr(AT91C_ID_TWI ); 
    134                  TWI_DisableIt(pTwi, AT91C_TWI_TXRDY | AT91C_TWI_RXRDY | AT91C_TWI_TXCOMP | AT91C_TWI_NACK );    
    135                  pTransfer->status = 1; //NAK error
    136                  if (pTransfer->callback) {            
    137                     pTransfer->callback((Async *) pTransfer);
    138                      
    139                  }               
    140                  OSSemPost( TWI_Sem_done );  
    141              }
    142              // Byte received
    143              else if ( TWI_STATUS_RXRDY(status) ) {
    144          
    145                  pTransfer->pData[pTransfer->transferred] = TWI_ReadByte(pTwi);
    146                  pTransfer->transferred++;
    147          
    148                  // Transfer finished ?
    149                  if (pTransfer->transferred == pTransfer->num) {
    150                      TWI_DisableIt(pTwi, AT91C_TWI_RXRDY);
    151                      TWI_EnableIt(pTwi, AT91C_TWI_TXCOMP);
    152                      
    153                  }
    154                  // Last byte ?
    155                  else if ( pTransfer->transferred == (pTransfer->num - 1) ) {
    156                      TWI_Stop(pTwi);   
    157                      
    158                  }
    159              // Byte sent       
    160              } else if (TWI_STATUS_TXRDY(status)) { 
    161                   // Transfer finished ?
    162                  if (pTransfer->transferred == pTransfer->num) {
    163                      TWI_DisableIt(pTwi, AT91C_TWI_TXRDY);
    164                      TWI_EnableIt(pTwi, AT91C_TWI_TXCOMP);
    165                      
    166                  } else  {// Bytes remaining
    167                      TWI_WriteByte(pTwi, pTransfer->pData[pTransfer->transferred]);
    168                      pTransfer->transferred++;     
    169                      
    170                  }        
    171              // Transfer complete   
    172              } else if (TWI_STATUS_TXCOMP(status)) { 
    173          
    174                  //BSP_IntClr(AT91C_ID_TWI ); 
    175                  TWI_DisableIt(pTwi, AT91C_TWI_TXCOMP | AT91C_TWI_NACK );
    176                  pTransfer->status = 0; //ok
    177                  if (pTransfer->callback) {            
    178                      pTransfer->callback((Async *) pTransfer);
    179                      
    180                  }              
    181                  OSSemPost( TWI_Sem_done );
    182                  
    183              }    
    184              
    185          
    186                  
    187          }
    188          
    189          
    190          //-----------------------------------------------------------------------------
    191          /// Asynchronously reads data from a slave on the TWI bus. An optional
    192          /// callback function is triggered when the transfer is complete.
    193          /// Returns 0 if the transfer has been started; otherwise returns a TWI error
    194          /// code.
    195          /// \param address  TWI slave address.
    196          /// \param iaddress  Optional slave internal address.
    197          /// \param isize  Internal address size in bytes.
    198          /// \param pData  Data buffer for storing received bytes.
    199          /// \param num  Number of bytes to read.
    200          /// \param pAsync  Asynchronous transfer descriptor.
    201          //-----------------------------------------------------------------------------
    202          unsigned char TWID_Read      (
    203                  unsigned char  address,
    204                  unsigned int   iaddress,
    205                  unsigned char  isize,
    206                  unsigned char *pData,
    207                  unsigned int   num,
    208                  Async *pAsync         )
    209          {  
    210            
    211              AT91S_TWI *pTwi ;
    212              AsyncTwi *pTransfer;
    213              unsigned int timeout;
    214              unsigned char err;    
    215              unsigned char state; 
    216                  
    217              pAsync    = &twi_async; //force use async
    218              pTwi      = twid.pTwi; 
    219              pTransfer = (AsyncTwi *)twid.pTransfer; 
    220              state     = TWID_NO_ERROR;
    221                  
    222              if (pAsync) {  // Asynchronous transfer
    223                
    224                  if (pTransfer) { // Check that no transfer is already pending
    225                      //TRACE_ERROR("TWID_Read: A transfer is already pending\n\r");   
    226                      state =  TWID_ERROR_BUSY;
    227                      return state ;
    228                  }
    229                  if (num == 1) { // in case of there is only one byte data
    230                      TWI_Stop(pTwi);  //stop must be send before the last byte
    231                      
    232                  }    
    233                  // Update the transfer descriptor
    234                  twid.pTransfer          = pAsync;
    235                  pTransfer               = (AsyncTwi *)pAsync; 
    236                  pTransfer->status       = ASYNC_STATUS_PENDING;
    237                  pTransfer->pData        = pData;
    238                  pTransfer->num          = num;
    239                  pTransfer->transferred  = 0;   
    240                  
    241                  // Enable read interrupt and start the transfer      
    242                  //BSP_IntEn(AT91C_ID_TWI);
    243                  TWI_StartRead(pTwi, address, iaddress, isize);
    244                  TWI_EnableIt(pTwi, AT91C_TWI_RXRDY);
    245                  TWI_EnableIt(pTwi, AT91C_TWI_NACK); 
    246                  
    247                  OSSemPend( TWI_Sem_done, 1000, &err );  
    248                  if( OS_ERR_NONE != err ) {
    249                      TWI_DisableIt(pTwi, AT91C_TWI_TXRDY | AT91C_TWI_RXRDY | AT91C_TWI_TXCOMP | AT91C_TWI_NACK ); 
    250                  }
    251                  state          = pTransfer->status ;
    252                  twid.pTransfer = NULL;
    253                  
    254              }  else {  // Synchronous transfer
    255          
    256                  OSSemPend( TWI_Sem_lock, 0, &err );  
    257                  // Set STOP signal if only one byte is sent
    258                  if (num == 1) {
    259                      TWI_Stop(pTwi);
    260                  }
    261                  // Start read
    262                  TWI_StartRead(pTwi, address, iaddress, isize);
    263                  // Read all bytes, setting STOP before the last byte
    264                  while (num > 0 ) {
    265                      // Last byte
    266                      if (num == 1) {
    267                          TWI_Stop(pTwi);
    268                      }
    269                      // Wait for byte then read and store it
    270                      timeout = 0;
    271                      while( !TWI_ByteReceived(pTwi) && (++timeout<TWITIMEOUTMAX) );
    272                      if (timeout == TWITIMEOUTMAX) {
    273                          //TRACE_ERROR("TWID Timeout BR\n\r");
    274                           OSSemPost( TWI_Sem_lock );
    275                           state =  TWID_ERROR_TIMEOUT;
    276                           return state;
    277                      }
    278                      *pData++ = TWI_ReadByte(pTwi);
    279                      num--;
    280                  }
    281                  // Wait for transfer to be complete
    282                  timeout = 0;
    283                  while( !TWI_TransferComplete(pTwi) && (++timeout < TWITIMEOUTMAX) );
    284                  if (timeout == TWITIMEOUTMAX) {
    285                      //TRACE_ERROR("TWID Timeout TC\n\r");           
    286                      state =  TWID_ERROR_TIMEOUT2;           
    287                  }
    288                  OSSemPost( TWI_Sem_lock );
    289                  
    290              }
    291                 
    292              return state;
    293          }
    294          
    295          //------------------------------------------------------------------------------
    296          /// Asynchronously sends data to a slave on the TWI bus. An optional callback
    297          /// function is invoked whenever the transfer is complete.
    298          /// \param address  Slave address.
    299          /// \param iaddress  Optional slave internal address.
    300          /// \param isize  Number of internal address bytes.
    301          /// \param pData  Data buffer to send.
    302          /// \param num  Number of bytes to send.
    303          /// \param pAsync  Pointer to an Asynchronous transfer descriptor.
    304          //------------------------------------------------------------------------------
    305          unsigned char TWID_Write    (
    306                  unsigned char  address,
    307                  unsigned int   iaddress,
    308                  unsigned char  isize,
    309                  unsigned char *pData,
    310                  unsigned int   num,
    311                  Async *pAsync       )
    312          {
    313              AT91S_TWI *pTwi;
    314              AsyncTwi *pTransfer;
    315              unsigned int timeout;
    316              unsigned char err;     
    317              unsigned char state; 
    318                  
    319              pAsync    = &twi_async; //force use async    
    320              pTwi      = twid.pTwi; 
    321              pTransfer = (AsyncTwi *)twid.pTransfer;      
    322              state     = TWID_NO_ERROR;
    323                  
    324              if (pAsync) {  // Asynchronous transfer
    325                
    326                  if (pTransfer) { // Check that no transfer is already pending
    327                      //TRACE_ERROR("TWID_Read: A transfer is already pending\n\r");   
    328                      state =  TWID_ERROR_BUSY;
    329                      return state ;
    330                  }         
    331                       
    332                  // Update the transfer descriptor
    333                  twid.pTransfer          = pAsync;
    334                  pTransfer               = (AsyncTwi *)pAsync;    
    335                  pTransfer->status       = ASYNC_STATUS_PENDING;
    336                  pTransfer->pData        = pData;
    337                  pTransfer->num          = num;
    338                  pTransfer->transferred  = 1;    
    339                  
    340                  // Enable write interrupt and start the transfer
    341               
    342                  //BSP_IntEn(AT91C_ID_TWI);
    343                  TWI_StartWrite(pTwi, address, iaddress, isize, *pData); 
    344                  TWI_EnableIt(pTwi, AT91C_TWI_TXRDY);         
    345                  TWI_EnableIt(pTwi, AT91C_TWI_NACK);  
    346                  OSSemPend( TWI_Sem_done, 1000, &err );
    347                  if( OS_ERR_NONE != err ) {
    348                      TWI_DisableIt(pTwi, AT91C_TWI_TXRDY | AT91C_TWI_RXRDY | AT91C_TWI_TXCOMP | AT91C_TWI_NACK ); 
    349                  }
    350                  state          =  pTransfer->status ;
    351                  twid.pTransfer =  NULL;
    352                  
    353              } else {   // Synchronous transfer   
    354          
    355                  OSSemPend( TWI_Sem_lock, 0, &err ); 
    356                  // Start write
    357                  TWI_StartWrite(pTwi, address, iaddress, isize, *pData++);
    358                  num--;
    359                  // Send all bytes
    360                  while (num > 0) {        
    361                      // Wait before sending the next byte
    362                      timeout = 0;
    363                      while( !TWI_ByteSent(pTwi) && (++timeout<TWITIMEOUTMAX) );
    364                      if (timeout == TWITIMEOUTMAX) {
    365                          //TRACE_ERROR("TWID Timeout BS\n\r");             
    366                           state =  TWID_ERROR_TIMEOUT;
    367                           return state;
    368                      }
    369                      TWI_WriteByte(pTwi, *pData++);
    370                      num--;
    371                  }
    372          
    373                  // Wait for actual end of transfer
    374                  timeout = 0;
    375          
    376                  //TWI auto insert a stop in A3 chip
    377          #ifdef TWI_V3XX
    378                  // Send a STOP condition
    379                  TWI_SendSTOPCondition(pTwi);
    380          #endif
    381                  
    382                  while( !TWI_TransferComplete(pTwi) && (++timeout<TWITIMEOUTMAX) );
    383                  if (timeout == TWITIMEOUTMAX) {
    384                      //TRACE_ERROR("TWID Timeout TC2\n\r");   
    385                      state =  TWID_ERROR_TIMEOUT2;         
    386                  }
    387                  OSSemPost( TWI_Sem_lock );
    388              }     
    389              
    390              return state;
    391          }
    392          
    393          
    394          
    395          //TWI Initial
    396          // Configure TWI
    397          // In IRQ mode: to avoid problems, the priority of the TWI IRQ must be max.
    398          // In polling mode: try to disable all IRQs if possible.
    399          // (in this example it does not matter, there is only the TWI IRQ active)
    400          void TWI_Init( unsigned int twi_clock  )
    401          {
    402            
    403          #if (OS_EVENT_NAME_EN  > 0 )
    404              CPU_INT08U  err;
    405          #endif
    406              
    407              PIO_Configure(  twi_pins, PIO_LISTSIZE(twi_pins)  );
    408              
    409              AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_TWI;
    410              TWI_ConfigureMaster( AT91C_BASE_TWI, twi_clock, MCK  );
    411              TWID_Initialize( &twid, AT91C_BASE_TWI );
    412              
    413              TWI_Sem_lock  = OSSemCreate(1); 
    414          #if (OS_EVENT_NAME_EN > 0)
    415             OSEventNameSet(TWI_Sem_lock,         "TWI_Sem_lock", &err);
    416          #endif
    417             
    418          
    419             
    420          #ifdef TWI_ASYNC_MODE
    421                  
    422              TWI_Sem_done  = OSSemCreate(0); 
    423          #if (OS_EVENT_NAME_EN > 0)
    424             OSEventNameSet(TWI_Sem_done,         "TWI_Sem_done", &err);
    425          #endif
    426              twi_async.callback  = 0 ;
    427              
    428              BSP_IntVectSet( AT91C_ID_TWI,
    429                              (CPU_INT08U   )AT91C_AIC_PRIOR_HIGHEST,
    430                              (CPU_INT08U   )BSP_INT_SCR_TYPE_INT_HIGH_LEVEL_SENSITIVE, //why must BSP_IntClr()BSP_IntEn() be used in int service if BSP_INT_SCR_TYPE_INT_POSITIVE_EDGE_TRIG
    431                              (CPU_FNCT_VOID)TWID_Handler);  
    432              
    433              BSP_IntClr(AT91C_ID_TWI );     
    434              BSP_IntEn(AT91C_ID_TWI);    
    435          #endif
    436              
    437                
    438          }
    439          
    440          
    441          
    442          
    443          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TWID_Handler
        16   -- Indirect call
        16   -> OSSemPost
        16   -> TWI_DisableIt
        16   -> TWI_EnableIt
        16   -> TWI_GetMaskedStatus
        16   -> TWI_ReadByte
        16   -> TWI_Stop
        16   -> TWI_WriteByte
       0   TWID_Initialize
      48   TWID_Read
        48   -> OSSemPend
        48   -> OSSemPost
        48   -> TWI_ByteReceived
        48   -> TWI_DisableIt
        48   -> TWI_EnableIt
        48   -> TWI_ReadByte
        48   -> TWI_StartRead
        48   -> TWI_Stop
        48   -> TWI_TransferComplete
      56   TWID_Write
        56   -> OSSemPend
        56   -> OSSemPost
        56   -> TWI_ByteSent
        56   -> TWI_DisableIt
        56   -> TWI_EnableIt
        56   -> TWI_StartWrite
        56   -> TWI_TransferComplete
        56   -> TWI_WriteByte
      16   TWI_Init
        16   -> BSP_IntClr
        16   -> BSP_IntEn
        16   -> BSP_IntVectSet
        16   -> OSEventNameSet
        16   -> OSSemCreate
        16   -> PIO_Configure
        16   -> TWID_Initialize
        16   -> TWI_ConfigureMaster


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "TWI_Sem_done">
      16  ?<Constant "TWI_Sem_lock">
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
     400  TWID_Handler
      16  TWID_Initialize
     568  TWID_Read
     536  TWID_Write
     200  TWI_Init
       4  TWI_Sem_done
       4  TWI_Sem_lock
      20  twi_async
      12  twi_pins
       8  twid

 
    36 bytes in section .bss
    44 bytes in section .rodata
 1 756 bytes in section .text
 
 1 756 bytes of CODE  memory
    44 bytes of CONST memory
    36 bytes of DATA  memory

Errors: none
Warnings: none
