###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        04/Sep/2014  10:10:16
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\dsp.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\dsp.c" -lcN "E:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb "E:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o "E:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\dsp.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\dsp.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\dsp.c
      1          /*
      2          *********************************************************************************************************
      3          *                               iSAM TEST BENCH AUDIO BRIDGE BOARD APP PACKAGE
      4          *
      5          *                            (c) Copyright 2013 - 2016; Fortemedia Inc.; Nanjing, China
      6          *
      7          *                   All rights reserved.  Protected by international copyright laws.
      8          *                   Knowledge of the source code may not be used to write a similar
      9          *                   product.  This file may only be used in accordance with a license
     10          *                   and should not be redistributed in any way.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                        FM36 DSP Based Signal Path Setup
     18          *
     19          *                                          Atmel AT91SAM7A3
     20          *                                               on the
     21          *                                      iSAM Audio Bridge Board
     22          *
     23          * Filename      : dsp.c
     24          * Version       : V1.0.0
     25          * Programmer(s) : PQ
     26          *********************************************************************************************************
     27          * Note(s)       :
     28          *********************************************************************************************************
     29          */
     30          
     31          
     32          #include <includes.h>
     33          
     34          
     35          
     36          static void Revert_patch_Endien( unsigned int *pData )
     37          {
     38              
     39             unsigned char temp, *pChar;    
     40             
     41             pChar  = (unsigned char *)pData;   
     42             temp   = *pChar;
     43             *pChar = *(pChar+2);
     44             *(pChar+2) = temp;
     45             
     46          }
     47          
     48          
     49          ////////////////////    for FM36-36D0 on AB01          /////////////////////////
     50          
     51          static unsigned int fm36_patch_code_1[] = 
     52          {
     53                0x003F00,  
     54                0x92FFFA,
     55                0x82266A,
     56                0x93FEDA,
     57                0x83FCFA,           
     58                0x23AA5F,           
     59                0x23B29F,           
     60                0x93FCFA,           
     61                0x82267A,           
     62                0x93FD5A,           
     63                0x82268A,            
     64                0x93FD6A,           
     65                0x82269A,           
     66                0x93FCCA,           
     67                0x8226AA,           
     68                0x93FCDA,           
     69                0x8226BA,           
     70                0x93FCBA,           
     71                0x83FD7A,           
     72                0x23A21F,           
     73                0x23A25F,           
     74                0x93FD7A,           
     75                0x82FFFA,           
     76                0x93F90A,           
     77                0x18466F  
     78          };
     79          
     80          static unsigned short int fm36_para_table_1[][2] = 
     81          {   
     82            {0x3FA0, 0x8437},
     83            {0x3FB0, 0x0452},
     84            {0x3FA1, 0x8465},
     85            {0x3FB1, 0x3F00},
     86            
     87            //{0x2260, 0x78df},//16bit TDM
     88            //{0x2260, 0x78ff},//32bit TDM
     89            //{0x2260, 0x7AFF},//32bit TDM,MSB first,Left alignment
     90            {0x2260, 0x7AFD},//32bit TDM,MSB first,Left alignment
     91            {0x2266, 0x0013}, //3.072Hz
     92            //{0x2266, 0x001B}, //2.048M
     93            {0x2267, 0xBB80}, //3.072Hz
     94            //{0x2267, 0x7d00}, //2.048M
     95            {0x2268, 0xBB80}, //48k
     96            
     97            {0x2264, 0x01A0},
     98            {0x2265, 0x0000},
     99            {0x2288, 0x0000},
    100            {0x2289, 0x7FFF},
    101            {0x2290, 0x7FFF},
    102            {0x22FD, 0x009E},
    103          
    104            {0x2273, 0x0AAA},
    105            //{0x2274, 0x0001},//mic revert
    106            {0x2303, 0x8000},
    107            {0x2304, 0x4000},
    108            {0x2305, 0x0000},
    109            {0x226E, 0x0006},//OSC= 12.288MHz. PLL
    110            {0x2272, 0x003F},
    111            {0x2278, 0x0000},
    112            {0x22C1, 0x3FD9},
    113            {0x22C2, 0x3FDB},
    114            {0x22C3, 0x3FDD},
    115            {0x22C4, 0x3FDF},
    116            {0x22C5, 0x3FE1},
    117            {0x22C6, 0x3FE3}, 
    118          
    119            {0x22FB, 0     },
    120          //  {0x3FCF, 0x0220}, //Bit9 : Enable inner LDO. Bit5: Enable PDM ADC CLK 
    121          //  {0x3FED, 0x0013}, //set PDM CLK = 3.072MHz
    122          //    
    123          //  //fix PDM issue
    124          //  {0x3F90, 0xFF }, //power down mic
    125          //  {0x3F90, 0x00 }, //power down mic  
    126          
    127          } ;
    128          
    129          
    130          /////////////////////    for FM36-600C on AB02     /////////////////////////////
    131          
    132          static unsigned int fm36_patch_code_2[] = 
    133          {
    134              0x003F00,  
    135              0x3C0065,
    136              0x43700A,
    137              0x377201,
    138              0x17F05E,
    139              0x6800A5,
    140              0x22629F,
    141              0x44000A,
    142              0x19E78F,
    143              0x81012A,
    144              0x877200,
    145              0x6800A1,
    146              0x977200,
    147              0x81013A,
    148              0x877220,
    149              0x6800A1,
    150              0x977220,
    151              0x81014A,
    152              0x877240,
    153              0x6800A1,
    154              0x977240,
    155              0x81011A,
    156              0x19BFCF,
    157              0x877210,
    158              0x6000A1,
    159              0x977210,
    160              0x9101DA,
    161              0x877230,
    162              0x6000A1,
    163              0x977230,
    164              0x9101EA,
    165              0x877250,
    166              0x6000A1,
    167              0x977250,
    168              0x9101FA,
    169              0x862450,
    170              0x19C27F
    171          };
    172          
    173          static unsigned short int fm36_para_table_2[][2] = 
    174          {
    175             
    176            {0x3FA0, 0x9E77},
    177            {0x3FB0, 0x3F00},
    178            {0x3FA1, 0x9BFB},
    179            {0x3FB1, 0x3F08},
    180            {0x3FA2, 0x9C26},
    181            {0x3FB2, 0x3F16},  
    182          
    183            //{0x2260, 0x78df},//16bit TDM
    184            //{0x2260, 0x78ff},//32bit TDM
    185            //{0x2260, 0x7AFF},//32bit TDM,MSB first,Left alignment,8 slot 
    186            {0x2260, 0x7AFD},//32bit TDM,MSB first,Left alignment,6 slot 
    187            {0x2266, 0x0013}, //3.072Hz
    188            //{0x2266, 0x001B}, //2.048M
    189            {0x2267, 0xBB80}, //3.072Hz
    190            //{0x2267, 0x7d00}, //2.048M 
    191            
    192            {0x2268, 0xBB80}, 
    193            {0x2264, 0x01A0},
    194            {0x2265, 0x0000},
    195            {0x2288, 0x0000},
    196            {0x2289, 0x7FFF},
    197            {0x2290, 0x7FFF},
    198            {0x22FD, 0x009E},  
    199          
    200            //{0x2274, 0x0001},//mic revert
    201            
    202            //{0x2303, 0x8000},
    203            //{0x2304, 0x4000},
    204            //{0x2305, 0x0000},
    205            {0x22FC, 0x8000},
    206            {0x226E, 0x0006}, //PLL  12.288MHz OSC 
    207            
    208            {0x22D7, 0x0000},
    209            {0x22D8, 0x0001},
    210            {0x22D9, 0x0002},
    211            {0x22DA, 0x0003},
    212            {0x22DB, 0x0004},
    213            {0x22DC, 0x0005}, 
    214            
    215            {0x22B2, 0x0001},
    216            {0x22B3, 0x0001},
    217            {0x22B4, 0x0001},  
    218          
    219            {0x2282, 0x0000},
    220            {0x2283, 0x0001},
    221            {0x2284, 0x0002},
    222            {0x2285, 0x0003},
    223            {0x2286, 0x0004},
    224            {0x2287, 0x0005}, 
    225            
    226            {0x22EB, 0x0006}, 
    227            
    228            {0x22C1, 0x101A},
    229            {0x22C2, 0x101B},
    230            {0x22C3, 0x101C},
    231            {0x22C4, 0x101D},
    232            {0x22C5, 0x101E},
    233            {0x22C6, 0x101F},
    234            
    235            //{0x2278, 0x0000}, //MIC Gain = 0dB
    236            
    237            {0x22FB, 0 },  
    238            
    239            {0x3F91, 0x0000}, //MEMS MIC TYPE
    240            //{0x3F92, 0x0000} //MEMS MIC gain = 0dB
    241            //{0x3F92, 0x0155} //MEMS MIC gain = 6dB
    242            //{0x3F92, 0x0AAA} //MEMS MIC gain = 12dB //SW default setting
    243            //{0x3F92, 0x03FF} //MEMS MIC gain = 18dB
    244            
    245          
    246          } ;
    247          
    248          
    249          
    250          /*
    251            //{0x3FC6, 0} //MIC0/1 volume
    252            //{0x3FC7, 0} //MIC2/3 volume
    253            //{0x3FC8, 0} //MIC4/5 volume
    254            //the real volume is volume/100
    255          unsigned char Set_Mic_Volume( unsigned float vol )
    256          {
    257              
    258              if( vol <= 0 && vol >= -143.25 ) {
    259                  temp 
    260              } else if( vol <= 24 && vol >0 ) {
    261                  
    262              } else {
    263                  
    264              }
    265              
    266          }
    267          */
    268          
    269          
    270          
    271          ////////////////////////    for FM36-600C on AB03      ////////////////////////
    272          
    273          static unsigned int fm36_patch_code_3[] = 
    274          {
    275              0x003F00,  
    276              0x3C0065,  
    277              0x43700A,  
    278              0x377201,  
    279              0x17F05E,  
    280              0x6800A5,  
    281              0x22629F,  
    282              0x3C0045,  
    283              0x43730A,  
    284              0x377261,  
    285              0x17F0BE,  
    286              0x6800A5,  
    287              0x22629F,  
    288              0x44000A,  
    289              0x19E78F,  
    290              0x81012A,  
    291              0x877200,  
    292              0x6800A1,  
    293              0x977200,  
    294              0x81013A,  
    295              0x877220,  
    296              0x6800A1,  
    297              0x977220,  
    298              0x81014A,  
    299              0x877240,  
    300              0x6800A1,  
    301              0x977240,  
    302              0x81011A,  
    303              0x19BFCF,  
    304              0x877210,  
    305              0x6000A1,  
    306              0x977210,  
    307              0x9101DA,  
    308              0x877230,  
    309              0x6000A1,  
    310              0x977230,  
    311              0x9101EA,  
    312              0x877250,  
    313              0x6000A1,  
    314              0x977250,  
    315              0x9101FA,  
    316              0x862450,  
    317              0x19C27F,  
    318              0x8A2C72,  
    319              0x7000AA,  
    320              0x877260,  
    321              0x6800A1,  
    322              0x977260,  
    323              0x8A2C82,  
    324              0x7000AA,  
    325              0x877280,  
    326              0x6800A1,  
    327              0x977280,  
    328              0x810BF1,  
    329              0x1831DF,  
    330              0x43F005,  
    331              0x3C0025,  
    332              0x3A2D50,  
    333              0x3B72A2,  
    334              0x1DC53F,  
    335              0x43F005,  
    336              0x19C8CF,  
    337              0x877270,  
    338              0x340088,  
    339              0x6000A1,  
    340              0x8B72A0,  
    341              0x7800A2,  
    342              0x977270,  
    343              0x877290,  
    344              0x6000A1,  
    345              0x8B72B0,  
    346              0x7800A2,  
    347              0x977290,  
    348              0x862550,  
    349              0x19A30F
    350          
    351          };
    352          
    353          //parameters for FM36 signal path on AB03
    354          static unsigned short int fm36_para_table_3[][2] = 
    355          {
    356            //patch settings
    357            {0x3FA0, 0x9E77},
    358            {0x3FB0, 0x3F00},
    359            {0x3FA1, 0x9BFB},
    360            {0x3FB1, 0x3F0E},
    361            {0x3FA2, 0x9C26},
    362            {0x3FB2, 0x3F1C},
    363            {0x3FA3, 0x831C},
    364            {0x3FB3, 0x3F2A},
    365            {0x3FA4, 0x9C8B},
    366            {0x3FB4, 0x3F36},
    367            {0x3FA5, 0x9A2F},
    368            {0x3FB5, 0x3F3D},    
    369          
    370            //////////////////////////////////////////////////////////////
    371            
    372            //SP0 port setting
    373            //{0x2260, 0x78df},//16bit TDM
    374            //{0x2260, 0x78ff},//32bit TDM
    375            {0x2260, 0x7AFF},//32bit TDM,MSB first,Left alignment,8 slot 
    376            //{0x2260, 0x7AFD},//32bit TDM,MSB first,Left alignment,6 slot 
    377            {0x2266, 0x0013}, //3.072Hz
    378            //{0x2266, 0x001B}, //2.048M
    379            {0x2267, 0xBB80}, //3.072Hz
    380            //{0x2267, 0x7d00}, //2.048M 
    381            
    382            //SP1 port setting
    383            {0x2261, 0x78FF},//32bit TDM,MSB first,Left alignment,8 slot, Left alignment of word inside slot to meet AD1937
    384          
    385            {0x2268, 0xBB80}, 
    386            {0x2264, 0x01A0},
    387            {0x2265, 0x0000},
    388            {0x2288, 0x0000},
    389            {0x2289, 0x7FFF},
    390            {0x2290, 0x7FFF},
    391            {0x22FD, 0x009E},  
    392          
    393            //{0x2274, 0x0001},//mic revert  
    394            //{0x2303, 0x8000},
    395            //{0x2304, 0x4000},
    396            //{0x2305, 0x0000},
    397            {0x22FC, 0x8000},
    398            {0x226E, 0x0006}, //PLL  12.288MHz OSC 
    399            
    400            ////////////////////////////////////////////////////////////
    401            
    402            //select data interruption source :  
    403            // 0: PDM, 1: SP0, 2: SP1, 3: SP2
    404            {0x22B2, 0x0001},
    405            {0x22B3, 0x0001},
    406            {0x22B4, 0x0001}, 
    407            
    408              //additional, input
    409              ////229A = 0x1 //Aux-in From SP0
    410              ////229B = 0x0 //Aux-in-L in slot0 
    411              ////229C = 0x1 //Aux-in-R in slot1
    412              //// 
    413              //////output, aux2 output same as aux1
    414              ////22C7 = 0x1018 //Aux-in-L
    415              ////22C8 = 0x1019 //Aux-in-R
    416              ////22B4 = 1 //SP0
    417              ////22D5 = 6 //slot6 
    418              ////22D6 = 7 //slot7
    419            
    420            //lin source 
    421            {0x229A, 0x0002}, //Aux-in From SP1
    422            {0x229B, 0x0008}, //Aux-in-L in SP1 slot0 
    423            {0x229C, 0x0009}, //Aux-in-R in SP1 slot1
    424            
    425            //select output data source slot
    426            {0x22C1, 0x101A},
    427            {0x22C2, 0x101B},
    428            {0x22C3, 0x101C},
    429            {0x22C4, 0x101D},
    430            {0x22C5, 0x101E},
    431            {0x22C6, 0x101F},   
    432          //  {0x22C7, 0x1018}, //Aux-in-L
    433          //  {0x22C8, 0x1019}, //Aux-in-R
    434            {0x22C7, 0x1020}, //default 0
    435            {0x22C8, 0x1020}, //default 0
    436            
    437            //select data dest slot
    438            //If lineout is from TX0, offset is 0~7
    439            //If lineout is from TX1, offset is 8~15
    440            //If lineout is from TX2, offset is 16~23
    441            //If offset = 0x8000, means Zero output.
    442            {0x22D7, 0x0000},
    443            {0x22D8, 0x0001},
    444            {0x22D9, 0x0002},
    445            {0x22DA, 0x0003},
    446            {0x22DB, 0x0004},
    447            {0x22DC, 0x0005},  
    448            {0x22D5, 0x0006}, //slot6 
    449            {0x22D6, 0x0007}, //slot7
    450            
    451            //mic souce
    452            {0x2282, 0x0000},
    453            {0x2283, 0x0001},
    454            {0x2284, 0x0002},
    455            {0x2285, 0x0003},
    456            {0x2286, 0x0004},
    457            {0x2287, 0x0005}, 
    458            
    459            {0x22EB, 0x0006}, 
    460            
    461            {0x22FB, 0 }, 
    462            
    463            /*******************  MIC Volume Control  ****************
    464            Volume setting [7:4]:
    465            0x0 ( 0 dB) 0x4 (-48 dB) 0x8 (-96 dB) 0xc (Not allowed)
    466            0x1 (-12 dB) 0x5 (-60 dB) 0x9 (-108 dB) 0xd (Not allowed)
    467            0x2 (-24 dB) 0x6 (-72 dB) 0xa (-120 dB) 0xe (+24 dB)
    468            0x3 (-36 dB) 0x7 (-84 dB) 0xb (-132 dB) 0xf (+12 dB)
    469            Volume setting [3:0]:
    470            0x0 ( 0 dB) 0x4 (-3.00 dB) 0x8 (-6.00 dB) 0xc (-9.00 dB)
    471            0x1 (-0.75 dB) 0x5 (-3.75 dB) 0x9 (-6.75 dB) 0xd (-9.75 dB)
    472            0x2 (-1.50 dB) 0x6 (-4.50 dB) 0xa (-7.50 dB) 0xe (-10.50 dB)
    473            0x3 (-2.25 dB) 0x7 (-5.25 dB) 0xb (-8.25 dB) 0xf (-11.25 dB)
    474            Real volume = Volume for [7:4] + Volume for [3:0]
    475            **********************************************************/  
    476            //{0x3FC6, 0x0000}, //MIC0,1 Volume Gain = 0dB
    477            //{0x3FC7, 0x0000}, //MIC2,3 Volume Gain = 0dB
    478            //{0x3FC8, 0x0000}, //MIC4,5 Volume Gain = 0dB
    479            
    480            /**************** MEMS Gain Control **********************/
    481            //{0x3F91, 0x0000}, //MEMS MIC TYPE, SW default setting as MEMS type
    482            //{0x3F92, 0x0000} //MEMS MIC gain = 0dB
    483            //{0x3F92, 0x0555} //MEMS MIC gain = 6dB
    484            //{0x3F92, 0x0AAA} //MEMS MIC gain = 12dB //SW default setting
    485            //{0x3F92, 0x0FFF} //MEMS MIC gain = 18dB
    486          
    487          } ;
    488          
    489          //DMIC 4 steps PGA gain
    490          unsigned char DMIC_PGA_Control( unsigned short gain ) 
    491          {
    492              unsigned char  err  ;
    493              unsigned short data ;
    494              unsigned short mute ;
    495              
    496              mute = 0x3F;
    497              
    498              switch ( gain ){
    499                  case 0 : 
    500                      data = 0x0000;
    501                  break;
    502                  case 6 : 
    503                      data = 0x0555;
    504                  break;
    505                  case 12 : 
    506                      data = 0x0AAA;
    507                  break;
    508                  case 18 : 
    509                      data = 0x0FFF;
    510                  break;
    511                  case 1000 :
    512                      mute = 0x3F3F;
    513                  break;
    514                  default:
    515                      return FM36_DMIC_PGA_GAIN_ERR;
    516              }  
    517              
    518              if( mute == 0x3F ) {
    519                err = DM_SingleWrite( FM36_I2C_ADDR, 0x3F92, data ) ;
    520                if( OS_ERR_NONE != err ) {
    521                    return FM36_WR_DM_ERR;;
    522                }   
    523              }    
    524              err = DM_SingleWrite( FM36_I2C_ADDR, 0x3F96, mute ) ;
    525              if( OS_ERR_NONE != err ) {
    526                  return FM36_WR_DM_ERR;;
    527              }    
    528              
    529          }
    530          
    531          
    532          //Setup External Lin data input source
    533          //From : SP0_RX, SP1_RX
    534          static unsigned char Config_Lin( unsigned char lin_sp_index, unsigned char start_slot_index )
    535          {
    536              
    537              unsigned char err ;
    538             
    539              //Aux-Source
    540              err = DM_SingleWrite( FM36_I2C_ADDR, 0x229A, lin_sp_index+1 ) ;
    541              if( OS_ERR_NONE != err ) {
    542                  return FM36_WR_DM_ERR;;
    543              }
    544              
    545              //Aux-in-L
    546              err = DM_SingleWrite( FM36_I2C_ADDR, 0x229B, (lin_sp_index<<3) + start_slot_index ) ;
    547              if( OS_ERR_NONE != err ) {
    548                  return FM36_WR_DM_ERR;;
    549              }
    550              
    551              //Aux-in-R
    552              err = DM_SingleWrite( FM36_I2C_ADDR, 0x229C, (lin_sp_index<<3) + start_slot_index + 1 ) ;
    553              if( OS_ERR_NONE != err ) {
    554                  return FM36_WR_DM_ERR;;
    555              }    
    556             
    557              return err;
    558              
    559          }
    560          
    561          // Set additional data besides MIC data
    562          // M0..M5 + X0 + X1
    563          // Max 8 slots
    564          // Make sure last 2 slots folowed mic data closely
    565          static unsigned char Config_SP0_Out( unsigned char mic_num )
    566          {
    567              
    568              unsigned char err ;
    569            
    570              //select output data source slot
    571              err = DM_SingleWrite( FM36_I2C_ADDR, 0x22C1 + mic_num, 0x1018 ) ;
    572              if( OS_ERR_NONE != err ) {
    573                  return FM36_WR_DM_ERR;;
    574              }       
    575              err = DM_SingleWrite( FM36_I2C_ADDR, 0x22C2 + mic_num, 0x1019 ) ;
    576              if( OS_ERR_NONE != err ) {
    577                  return FM36_WR_DM_ERR;;
    578              }     
    579            
    580              return err;
    581              
    582          }
    583          
    584          
    585          
    586          //Note: This routine do NOT support reentrance
    587          static unsigned int sr_saved = 0;
    588          static unsigned int mic_num_saved = 0;
    589          
    590          //Just Change the sample rate of FM36
    591          unsigned char ReInit_FM36( unsigned short sr )
    592          {
    593             
    594              unsigned char  err;
    595              unsigned short temp;
    596              
    597              if( sr == sr_saved ) {
    598                  return NO_ERR;
    599              } else {
    600                  sr_saved = sr ;
    601              }  
    602             
    603              switch ( sr ) {
    604                  case 8000 :
    605                      temp = 0x1F40;
    606                  break;        
    607                  case 16000 :
    608                      temp = 0x3E80;
    609                  break;
    610                  case 24000 :
    611                      temp = 0x5DC0;
    612                  break;
    613                  case 32000 :
    614                      temp = 0x7D00;
    615                  break;
    616                  case 44100 :
    617                      temp = 0xAC44;
    618                  break;
    619                  default: // 48000 :
    620                      temp = 0xBB80;
    621                  break;   
    622              }
    623              
    624              err = DM_SingleWrite( FM36_I2C_ADDR, 0x3FD6, temp ) ;
    625              if( OS_ERR_NONE != err ) {
    626                  err = FM36_WR_DM_ERR;
    627              }
    628              return err ; 
    629              
    630          }
    631          
    632          
    633          unsigned char Init_FM36( unsigned short sr )
    634          {
    635              unsigned int i;
    636              unsigned short temp, temp2 ;
    637              unsigned short addr, val; 
    638              unsigned char err ;
    639              unsigned char dsp_type;
    640              
    641              
    642              if( sr == sr_saved ) {
    643                  return 0;
    644              } else {
    645                  sr_saved = sr ;
    646              }    
    647             
    648              Pin_Reset_FM36();  
    649          
    650              err = HOST_SingleWrite_2(FM36_I2C_ADDR,0x0C, 2); //reset
    651              if( OS_ERR_NONE != err ) {
    652                  return err ;
    653              }
    654               
    655          //    err = DM_LegacyRead( FM36_I2C_ADDR, 0x22FB,(unsigned char *)&temp ) ;
    656          //    if( OS_ERR_NONE != err ) {
    657          //        return err ;
    658          //    }  
    659          //    APP_TRACE_INFO(("0x22FB = 0x%X\r\n", temp)); 
    660          //    
    661          //    err = DM_LegacyRead( FM36_I2C_ADDR, 0x2306,(unsigned char *)&temp ) ;
    662          //    if( OS_ERR_NONE != err ) {
    663          //        return err ;
    664          //    }  
    665          //    APP_TRACE_INFO(("0x2306 = 0x%X\r\n", temp)); 
    666              
    667              
    668              err = CM_LegacyRead( FM36_I2C_ADDR, 0x2FFF,(unsigned char *)&temp ) ;
    669              if( OS_ERR_NONE != err ) {
    670                  return err ;
    671              }
    672              APP_TRACE_INFO(("ROM ID = 0x%X\r\n", temp)); 
    673              if( temp == FM36_ROM_ID_1 ) {
    674                  dsp_type = 0;
    675              } else if ( temp == FM36_ROM_ID_2 ) {
    676                  dsp_type = 1;
    677              } else {
    678                  return (0xA0); //dsp type error
    679              } 
    680                 
    681              // set SR
    682              switch ( sr ) {
    683                  case 8000 :
    684                      temp = 0x1F40;
    685                  break;        
    686                  case 16000 :
    687                      temp = 0x3E80;
    688                  break;
    689                  case 24000 :
    690                      temp = 0x5DC0;
    691                  break;
    692                  case 32000 :
    693                      temp = 0x7D00;
    694                  break;
    695                  case 44100 :
    696                      temp = 0xAC44;
    697                  break;
    698                  default: // 48000 :
    699                      temp = 0xBB80;
    700                  break;   
    701              }
    702           
    703              if( dsp_type == 0 )  { 
    704                  //patch code
    705                  addr = (unsigned short)fm36_patch_code_1[0];
    706                  for( i = 1; i < sizeof(fm36_patch_code_1)/4; i++) { 
    707                    Revert_patch_Endien(&fm36_patch_code_1[i]);    
    708                    err = PM_SingleWrite( FM36_I2C_ADDR, addr++, (unsigned char*)&fm36_patch_code_1[i],0 ) ;
    709                      if( OS_ERR_NONE != err ) {
    710                          return err ;
    711                      }    
    712                  }    
    713                  //parameters
    714                  for( i = 0; i < sizeof(fm36_para_table_1)/4; i++) {            
    715                      addr = fm36_para_table_1[i][0];
    716                      val  = fm36_para_table_1[i][1];
    717                      if( addr == 0x2268 ) { //SR
    718                          val = temp ;
    719                      }
    720                      err = DM_SingleWrite( FM36_I2C_ADDR, addr, val ) ;
    721                      if( OS_ERR_NONE != err ) {
    722                          return err ;
    723                      }
    724                      if( addr == 0x22FB ) {  //run chip
    725                          OSTimeDly(100);
    726                      }
    727                  }        
    728              
    729              } else {
    730                  //patch code
    731                  addr = (unsigned short)fm36_patch_code_2[0];
    732                  for( i = 1; i < sizeof(fm36_patch_code_2)/4; i++) { 
    733                    Revert_patch_Endien(&fm36_patch_code_2[i]);    
    734                    err = PM_SingleWrite( FM36_I2C_ADDR, addr++, (unsigned char*)&fm36_patch_code_2[i],0 ) ;
    735                      if( OS_ERR_NONE != err ) {
    736                          return err ;
    737                      }         
    738                  } 
    739                  //parameters
    740                  for( i = 0; i < sizeof(fm36_para_table_2)/4; i++) {            
    741                      addr = fm36_para_table_2[i][0];
    742                      val  = fm36_para_table_2[i][1];
    743                      if( addr == 0x2268 ) { //SR
    744                          val = temp ;
    745                      }
    746                      err = DM_SingleWrite( FM36_I2C_ADDR, addr, val ) ;
    747                      if( OS_ERR_NONE != err ) {
    748                          return err ;
    749                      }
    750                      if( addr == 0x22FB ) {  //run chip
    751                          OSTimeDly(100);
    752                      } 
    753          
    754                  } 
    755                  
    756              }
    757          
    758              err = DM_LegacyRead( FM36_I2C_ADDR, 0x2306,(unsigned char *)&temp2 ) ;
    759              if( OS_ERR_NONE != err ) {
    760                  return err ;
    761              }
    762              OSTimeDly(100);
    763              err = DM_LegacyRead( FM36_I2C_ADDR, 0x22FB,(unsigned char *)&temp ) ;
    764              if( OS_ERR_NONE != err ) {
    765                  return err ;
    766              }
    767              APP_TRACE_INFO(("0x22FB = 0x%X\r\n", temp));
    768              if( temp != 0x5A5A ) {   
    769                  return (2);
    770              }
    771              err = DM_LegacyRead( FM36_I2C_ADDR, 0x2306,(unsigned char *)&temp ) ;
    772              if( OS_ERR_NONE != err ) {
    773                  return err ;
    774              }
    775              if( temp == temp2 ) {
    776                  APP_TRACE_INFO(("frame counter stopped !"));
    777                  return (3);
    778              }    
    779              return (err);
    780              
    781          }
    782          
    783          static bool flag_power_lose = true;
    784          
    785          /*
    786          *********************************************************************************************************
    787          *                                       Init_FM36_AB03()
    788          *
    789          * Description : Initialize FM36 DSP on AB03 board.
    790          * Argument(s) : sr        : sample rate : 8000 ~ 48000 
    791          *               mic_num   : 0~6
    792          *               lin_sp_index  : line in data source: 0 ~ 1
    793          *               start_slot_index: line in data slot: 0 ~ 7
    794          * Return(s)   : NO_ERR :   execute successfully
    795          *               others :   =error code .  
    796          *
    797          * Note(s)     : None.
    798          *********************************************************************************************************
    799          */
    800          unsigned char Init_FM36_AB03( unsigned short sr, unsigned char mic_num, unsigned char lin_sp_index, unsigned char start_slot_index )
    801          {
    802              unsigned int   i;
    803              unsigned short temp, temp2 ;
    804              unsigned short addr, val; 
    805              unsigned char  err ;      
    806              
    807              if( sr == sr_saved  &&  mic_num == mic_num_saved ) { //just check this 2 parameters, b/c other won't change in AB03
    808                  return NO_ERR;
    809              } else {
    810                  sr_saved = sr ;
    811                  mic_num_saved = mic_num ;
    812              }   
    813              
    814              Pin_Reset_FM36();  
    815              
    816          //    err = HOST_SingleWrite_2(FM36_I2C_ADDR, 0x0C, 2); //reset
    817          //    if( OS_ERR_NONE != err ) {
    818          //        return FM36_WR_HOST_ERR;
    819          //    }    
    820          //    err = DM_LegacyRead( FM36_I2C_ADDR, 0x22FB,(unsigned char *)&temp ) ;
    821          //    if( OS_ERR_NONE != err ) {
    822          //        err = FM36_RD_DM_ERR;
    823          //        return err ;
    824          //    }  
    825          //    APP_TRACE_INFO(("0x22FB = 0x%X\r\n", temp));     
    826          //    err = DM_LegacyRead( FM36_I2C_ADDR, 0x2306,(unsigned char *)&temp ) ;
    827          //    if( OS_ERR_NONE != err ) {
    828          //        err = FM36_RD_DM_ERR;
    829          //        return err ;
    830          //    }  
    831          //    APP_TRACE_INFO(("0x2306 = 0x%X\r\n", temp));     
    832              
    833              err = CM_LegacyRead( FM36_I2C_ADDR, 0x2FFF,(unsigned char *)&temp ) ;
    834              if( OS_ERR_NONE != err ) {
    835                  err = FM36_RD_CM_ERR;
    836                  return FM36_RD_CM_ERR ;
    837              }
    838              APP_TRACE_INFO(("ROM ID = 0x%X\r\n", temp));
    839              
    840              if( temp != FM36_ROM_ID_2 ) { 
    841                  return FM36_CHECK_ROMID_ERR; //dsp type error
    842              } 
    843                 
    844              // set SR
    845              switch ( sr ) {
    846                  case 8000 :
    847                      temp = 0x1F40;
    848                  break;        
    849                  case 16000 :
    850                      temp = 0x3E80;
    851                  break;
    852                  case 24000 :
    853                      temp = 0x5DC0;
    854                  break;
    855                  case 32000 :
    856                      temp = 0x7D00;
    857                  break;
    858                  case 44100 :
    859                      temp = 0xAC44;
    860                  break;
    861                  default: //48000 :
    862                      temp = 0xBB80;
    863                  break;   
    864              }
    865           
    866              //FM36-600C
    867              //patch code
    868              if( flag_power_lose ) { //only need download patch once after one power cycle
    869                      
    870                  flag_power_lose = false;
    871                  addr = (unsigned short)fm36_patch_code_3[0];
    872                  for( i = 1; i < sizeof(fm36_patch_code_3)/4; i++) { 
    873                      Revert_patch_Endien(&fm36_patch_code_3[i]);    
    874                      err = PM_SingleWrite( FM36_I2C_ADDR, addr++, (unsigned char*)&fm36_patch_code_3[i],0 ) ;
    875                        if( OS_ERR_NONE != err ) {
    876                            err = FM36_WR_PM_ERR;
    877                            return err ;
    878                        }         
    879                  }
    880              } 
    881              //parameters
    882              for( i = 0; i < sizeof(fm36_para_table_3)/4; i++) {            
    883                  addr = fm36_para_table_3[i][0];
    884                  val  = fm36_para_table_3[i][1];
    885                  if( addr == 0x2268 ) { //SR
    886                      val = temp ;
    887                  }
    888                  if( addr == 0x22FB ) {  //if run chip, do sth before
    889                      err = Config_SP0_Out( mic_num );
    890                      if( OS_ERR_NONE != err ) {
    891                          return err ;
    892                      }
    893                      err = Config_Lin( lin_sp_index, start_slot_index );
    894                      if( OS_ERR_NONE != err ) {
    895                          return err ;
    896                      }
    897                  } 
    898                  err = DM_SingleWrite( FM36_I2C_ADDR, addr, val ) ;
    899                  if( OS_ERR_NONE != err ) {
    900                      err = FM36_WR_DM_ERR;
    901                      return err ;
    902                  }
    903                  if( addr == 0x22FB ) {  //if run chip, delay
    904                      OSTimeDly(100);
    905                  } 
    906              } 
    907                    
    908          
    909              err = DM_LegacyRead( FM36_I2C_ADDR, 0x2306,(unsigned char *)&temp2 ) ;
    910              if( OS_ERR_NONE != err ) {
    911                  err = FM36_RD_DM_ERR;
    912                  return err ;
    913              }
    914              APP_TRACE_DBG(("0x2306 = 0x%X\r\n", temp2));
    915              OSTimeDly(100);
    916              err = DM_LegacyRead( FM36_I2C_ADDR, 0x22FB,(unsigned char *)&temp ) ;
    917              if( OS_ERR_NONE != err ) {
    918                  err = FM36_RD_DM_ERR;
    919                  return err ;
    920              }
    921              APP_TRACE_INFO(("0x22FB = 0x%X\r\n", temp));
    922              if( temp != 0x5A5A ) {   
    923                  return FM36_CHECK_FLAG_ERR;
    924              }
    925              err = DM_LegacyRead( FM36_I2C_ADDR, 0x2306,(unsigned char *)&temp ) ;
    926              if( OS_ERR_NONE != err ) {
    927                  err = FM36_RD_DM_ERR;
    928                  return err ;
    929              }
    930              APP_TRACE_DBG(("0x2306 = 0x%X\r\n", temp));
    931              if( temp == temp2 ) {
    932                  APP_TRACE_INFO(("FM36 frame counter stopped !"));
    933                  return FM36_CHECK_COUNTER_ERR;
    934              }    
    935              return err;
    936              
    937          }
    938          
    939          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Config_Lin
        16   -> DM_SingleWrite
      16   Config_SP0_Out
        16   -> DM_SingleWrite
      24   DMIC_PGA_Control
        24   -> DM_SingleWrite
      32   Init_FM36
        32   -> BSP_Ser_Printf
        32   -> CM_LegacyRead
        32   -> DM_LegacyRead
        32   -> DM_SingleWrite
        32   -> HOST_SingleWrite_2
        32   -> OSTimeDly
        32   -> PM_SingleWrite
        32   -> Pin_Reset_FM36
        32   -> Revert_patch_Endien
      40   Init_FM36_AB03
        40   -> BSP_Ser_Printf
        40   -> CM_LegacyRead
        40   -> Config_Lin
        40   -> Config_SP0_Out
        40   -> DM_LegacyRead
        40   -> DM_SingleWrite
        40   -> OSTimeDly
        40   -> PM_SingleWrite
        40   -> Pin_Reset_FM36
        40   -> Revert_patch_Endien
      16   ReInit_FM36
        16   -> DM_SingleWrite
       0   Revert_patch_Endien


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "0x22FB = 0x%X\r\n">
      32  ?<Constant "FM36 frame counter st...">
      16  ?<Constant "ROM ID = 0x%X\r\n">
      24  ?<Constant "frame counter stopped !">
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     240  Config_Lin
     168  Config_SP0_Out
     296  DMIC_PGA_Control
    1312  Init_FM36
    1132  Init_FM36_AB03
     288  ReInit_FM36
      28  Revert_patch_Endien
       1  flag_power_lose
     112  fm36_para_table_1
     168  fm36_para_table_2
     220  fm36_para_table_3
     100  fm36_patch_code_1
     148  fm36_patch_code_2
     300  fm36_patch_code_3
       4  mic_num_saved
       4  sr_saved

 
     8 bytes in section .bss
 1 049 bytes in section .data
    88 bytes in section .rodata
 3 516 bytes in section .text
 
 3 516 bytes of CODE  memory
    88 bytes of CONST memory
 1 057 bytes of DATA  memory

Errors: none
Warnings: 1
