###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Dec/2014  13:30:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\flashd_efc.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\flashd_efc.c"
#        -lcN "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\"
#        -lb "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\FLASH\List\flashd_efc.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\FLASH\Obj\flashd_efc.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\flashd_efc.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include <bsp.h>
     35          #include <efc.h>
     36          #include "flashd.h"
     37          #include <math.h>
     38          
     39          #ifdef BOARD_FLASH_EFC
     40          
     41          //------------------------------------------------------------------------------
     42          //         Local constants
     43          //------------------------------------------------------------------------------
     44          
     45          #if defined(AT91C_BASE_EFC) && !defined(AT91C_BASE_EFC0)
     46              #define AT91C_BASE_EFC0     AT91C_BASE_EFC
     47          #endif
     48          
     49          //------------------------------------------------------------------------------
     50          //         Local functions
     51          //------------------------------------------------------------------------------
     52          
     53          //------------------------------------------------------------------------------
     54          /// Computes the lock range associated with the given address range.
     55          /// \param start  Start address of lock range.
     56          /// \param end  End address of lock range.
     57          /// \param pActualStart  Actual start address of lock range.
     58          /// \param pActualEnd  Actual end address of lock range.
     59          //------------------------------------------------------------------------------
     60          static void ComputeLockRange(
     61              unsigned int start,
     62              unsigned int end,
     63              unsigned int *pActualStart,
     64              unsigned int *pActualEnd)
     65          {
     66              AT91S_EFC *pStartEfc, *pEndEfc;
     67              unsigned short startPage, endPage;
     68              unsigned short numPagesInRegion;
     69              unsigned short actualStartPage, actualEndPage;
     70          
     71              // Convert start and end address in page numbers
     72              EFC_TranslateAddress(start, &pStartEfc, &startPage, 0);
     73              EFC_TranslateAddress(end, &pEndEfc, &endPage, 0);
     74          
     75              // Find out the first page of the first region to lock
     76              numPagesInRegion = AT91C_IFLASH_LOCK_REGION_SIZE / AT91C_IFLASH_PAGE_SIZE;
     77              actualStartPage = startPage - (startPage % numPagesInRegion);
     78              actualEndPage = endPage;
     79              if ((endPage % numPagesInRegion) != 0) {
     80          
     81                  actualEndPage += numPagesInRegion - (endPage % numPagesInRegion);
     82              }
     83          
     84              // Store actual page numbers
     85              EFC_ComputeAddress(pStartEfc, actualStartPage, 0, pActualStart);
     86              EFC_ComputeAddress(pEndEfc, actualEndPage, 0, pActualEnd);
     87              //TRACE_DEBUG("Actual lock range is 0x%06X - 0x%06X\n\r", *pActualStart, *pActualEnd);
     88          }
     89          
     90          //------------------------------------------------------------------------------
     91          //         Global functions
     92          //------------------------------------------------------------------------------
     93          
     94          //------------------------------------------------------------------------------
     95          /// Initializes the flash driver.
     96          /// \param mck  Master clock frequency in Hz.
     97          //------------------------------------------------------------------------------
     98          void FLASHD_Initialize(unsigned int mck)
     99          {
    100          
    101              EFC_SetMasterClock(mck);
    102              EFC_SetEraseBeforeProgramming(AT91C_BASE_EFC0, 1);
    103              EFC_DisableIt(AT91C_BASE_EFC0, AT91C_MC_FRDY | AT91C_MC_LOCKE | AT91C_MC_PROGE);
    104          #ifdef AT91C_BASE_EFC1
    105              EFC_SetEraseBeforeProgramming(AT91C_BASE_EFC1, 1);
    106              EFC_DisableIt(AT91C_BASE_EFC1, AT91C_MC_FRDY | AT91C_MC_LOCKE | AT91C_MC_PROGE);
    107          #endif
    108          }
    109          
    110          //------------------------------------------------------------------------------
    111          /// Erases the entire flash.
    112          /// Returns 0 if successful; otherwise returns an error code.
    113          //------------------------------------------------------------------------------
    114          unsigned char FLASHD_Erase(void)
    115          {
    116              unsigned char error;
    117          
    118              error = EFC_PerformCommand(AT91C_BASE_EFC0, AT91C_MC_FCMD_ERASE_ALL, 0);
    119          #ifdef AT91C_BASE_EFC1
    120              if (error) {
    121          
    122                  return error;
    123              }
    124              error = EFC_PerformCommand(AT91C_BASE_EFC1, AT91C_MC_FCMD_ERASE_ALL, 0);
    125          #endif
    126          
    127              return error;
    128          }
    129          
    130          static unsigned char pPageBuffer[AT91C_IFLASH_PAGE_SIZE];
    131          
    132          //------------------------------------------------------------------------------
    133          /// Writes a data buffer in the internal flash. This function works in polling
    134          /// mode, and thus only returns when the data has been effectively written.
    135          /// Returns 0 if successful; otherwise returns an error code.
    136          /// \param address  Write address.
    137          /// \param pBuffer  Data buffer.
    138          /// \param size  Size of data buffer in bytes.
    139          //------------------------------------------------------------------------------
    140          unsigned char FLASHD_Write(
    141              unsigned int address,
    142              const void *pBuffer,
    143              unsigned int size)
    144          {
    145              AT91S_EFC *pEfc;
    146              unsigned short page;
    147              unsigned short offset;
    148              unsigned int writeSize;
    149              unsigned int pageAddress;
    150              unsigned short padding;
    151              unsigned char error;
    152          
    153              unsigned int sizeTmp;
    154              unsigned int *pAlignedDestination; 
    155              unsigned int *pAlignedSource;
    156          
    157              ////SANITY_CHECK(address >= (unsigned int)AT91C_IFLASH);
    158              ////SANITY_CHECK(pBuffer);
    159              ////SANITY_CHECK((address + size) <= (unsigned int)(AT91C_IFLASH + AT91C_IFLASH_SIZE));
    160          
    161              
    162          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
    163              OS_CPU_SR  cpu_sr = 0u;
    164          #endif
    165              OS_ENTER_CRITICAL(); 
    166                  
    167              
    168              // Translate write address
    169              EFC_TranslateAddress(address, &pEfc, &page, &offset);
    170          
    171              // Write all pages
    172              while (size > 0) {
    173          
    174                  // Copy data in temporary buffer to avoid alignment problems
    175                  writeSize = min(AT91C_IFLASH_PAGE_SIZE - offset, size);
    176                  EFC_ComputeAddress(pEfc, page, 0, &pageAddress);
    177                  padding = AT91C_IFLASH_PAGE_SIZE - offset - writeSize;
    178          
    179                  // Pre-buffer data (mask with 0xFF)
    180                  memcpy(pPageBuffer, (void *) pageAddress, offset);
    181          
    182                  // Buffer data
    183                  memcpy(pPageBuffer + offset, pBuffer, writeSize);
    184          
    185                  // Post-buffer data
    186                  memcpy(pPageBuffer + offset + writeSize, (void *) (pageAddress + offset + writeSize), padding);
    187          
    188                  // Write page
    189                  // Writing 8-bit and 16-bit data is not allowed 
    190                  // and may lead to unpredictable data corruption
    191          #ifdef EFC_EVEN_ODD_PROG
    192                  // Write even words first with auto erase
    193                  pAlignedDestination = (unsigned int*)pageAddress;
    194                  pAlignedSource = (unsigned int*)pPageBuffer;
    195                  sizeTmp = AT91C_IFLASH_PAGE_SIZE;
    196                  while (sizeTmp >= 4) {
    197          
    198                      *pAlignedDestination = *pAlignedSource;
    199                      pAlignedDestination += 2;
    200                      pAlignedSource += 2;
    201                      sizeTmp -= 8;
    202                  }
    203                  // Send writing command
    204                  error = EFC_PerformCommand(pEfc, AT91C_MC_FCMD_START_PROG, page);
    205                  if (error) {
    206                      OS_EXIT_CRITICAL();
    207                      return error;
    208                  }
    209          
    210                  // Then write odd words without auto erase
    211                  EFC_SetEraseBeforeProgramming(AT91C_BASE_EFC0, 0);
    212          #ifdef AT91C_BASE_EFC1
    213                  EFC_SetEraseBeforeProgramming(AT91C_BASE_EFC1, 0);
    214          #endif
    215                  pAlignedDestination = (unsigned int*)pageAddress + 1;
    216                  pAlignedSource = (unsigned int*)pPageBuffer + 1;
    217                  sizeTmp = AT91C_IFLASH_PAGE_SIZE;
    218                  while (sizeTmp >= 4) {
    219          
    220                      *pAlignedDestination = *pAlignedSource;
    221                      pAlignedDestination += 2;
    222                      pAlignedSource += 2;
    223                      sizeTmp -= 8;
    224                  }
    225          
    226                  // Send writing command
    227                  error = EFC_PerformCommand(pEfc, AT91C_MC_FCMD_START_PROG, page);
    228                  if (error) {
    229                      OS_EXIT_CRITICAL();
    230                      return error;
    231                  }
    232          
    233                  EFC_SetEraseBeforeProgramming(AT91C_BASE_EFC0, 1);
    234          #ifdef AT91C_BASE_EFC1
    235                  EFC_SetEraseBeforeProgramming(AT91C_BASE_EFC1, 1);
    236          #endif
    237          
    238          #else 
    239                  pAlignedDestination = (unsigned int*)pageAddress;
    240                  pAlignedSource = (unsigned int*)pPageBuffer;        
    241                  sizeTmp = AT91C_IFLASH_PAGE_SIZE;
    242                  while (sizeTmp >= 4) {
    243          
    244                      *pAlignedDestination++ = *pAlignedSource++;
    245                      sizeTmp -= 4;
    246                  }        
    247                  
    248                  // Send writing command
    249                  error = EFC_PerformCommand(pEfc, AT91C_MC_FCMD_START_PROG, page);
    250                  if (error) {
    251                      OS_EXIT_CRITICAL();
    252                      return error;
    253                  }
    254          #endif
    255                  // Progression
    256                  address += AT91C_IFLASH_PAGE_SIZE;
    257                  pBuffer = (void *) ((unsigned int) pBuffer + writeSize);
    258                  size -= writeSize;
    259                  page++;
    260                  offset = 0;
    261          
    262          #if defined(AT91C_BASE_EFC1)
    263                  // Handle EFC crossover
    264                  if ((pEfc == AT91C_BASE_EFC0) && (page >= (AT91C_IFLASH_NB_OF_PAGES / 2))) {
    265          
    266                      pEfc = AT91C_BASE_EFC1;
    267                      page = 0;
    268                  }
    269          #endif
    270              } //while end
    271              
    272              OS_EXIT_CRITICAL();
    273              
    274              return 0;
    275          }
    276          
    277          //------------------------------------------------------------------------------
    278          /// Locks all the regions in the given address range. The actual lock range is
    279          /// reported through two output parameters.
    280          /// Returns 0 if successful; otherwise returns an error code.
    281          /// \param start  Start address of lock range.
    282          /// \param end  End address of lock range.
    283          /// \param pActualStart  Start address of the actual lock range (optional).
    284          /// \param pActualEnd  End address of the actual lock range (optional).
    285          //------------------------------------------------------------------------------
    286          unsigned char FLASHD_Lock(
    287              unsigned int start,
    288              unsigned int end,
    289              unsigned int *pActualStart,
    290              unsigned int *pActualEnd)
    291          {
    292              AT91S_EFC *pStartEfc, *pEndEfc, *pEfc;
    293              unsigned int actualStart, actualEnd;
    294              unsigned short startPage, endPage;
    295              unsigned char error;
    296              unsigned short numPagesInRegion = AT91C_IFLASH_LOCK_REGION_SIZE / AT91C_IFLASH_PAGE_SIZE;
    297          
    298          #if OS_CRITICAL_METHOD == 3u   
    299              OS_CPU_SR  cpu_sr = 0u;
    300          #endif
    301              OS_ENTER_CRITICAL(); 
    302           
    303              // Compute actual lock range and store it
    304              ComputeLockRange(start, end, &actualStart, &actualEnd);
    305              if (pActualStart) {
    306          
    307                  *pActualStart = actualStart;
    308              }
    309              if (pActualEnd) {
    310          
    311                  *pActualEnd = actualEnd;
    312              }
    313          
    314              // Compute page numbers
    315              EFC_TranslateAddress(actualStart, &pStartEfc, &startPage, 0);
    316              EFC_TranslateAddress(actualEnd, &pEndEfc, &endPage, 0);
    317          
    318              // Lock all pages
    319              // If there is an EFC crossover, lock all pages from first EFC
    320          #if defined(AT91C_BASE_EFC1)
    321              if (pStartEfc != pEndEfc) {
    322          
    323                  while (startPage < (AT91C_IFLASH_NB_OF_PAGES / 2)) {
    324          
    325                      error = EFC_PerformCommand(pStartEfc, AT91C_MC_FCMD_LOCK, startPage);
    326                      if (error) {
    327                        
    328                          OS_EXIT_CRITICAL(); 
    329                          return error;
    330                      }
    331                      startPage += numPagesInRegion;
    332                  }
    333                  startPage = 0;
    334              }
    335          #endif
    336              pEfc = pEndEfc;
    337          
    338              // Lock remaining pages
    339              while (startPage < endPage) {
    340          
    341                  error = EFC_PerformCommand(pEfc, AT91C_MC_FCMD_LOCK, startPage);
    342                  if (error) {
    343                    
    344                      OS_EXIT_CRITICAL(); 
    345                      return error;
    346                  }
    347                  startPage += numPagesInRegion;
    348              }
    349              
    350              OS_EXIT_CRITICAL(); 
    351              
    352              return 0;
    353          }
    354          
    355          //------------------------------------------------------------------------------
    356          /// Unlocks all the regions in the given address range. The actual unlock range is
    357          /// reported through two output parameters.
    358          /// Returns 0 if successful; otherwise returns an error code.
    359          /// \param start  Start address of unlock range.
    360          /// \param end  End address of unlock range.
    361          /// \param pActualStart  Start address of the actual unlock range (optional).
    362          /// \param pActualEnd  End address of the actual unlock range (optional).
    363          //------------------------------------------------------------------------------
    364          unsigned char FLASHD_Unlock(
    365              unsigned int start,
    366              unsigned int end,
    367              unsigned int *pActualStart,
    368              unsigned int *pActualEnd)
    369          {
    370              AT91S_EFC *pStartEfc, *pEndEfc, *pEfc;
    371              unsigned int actualStart, actualEnd;
    372              unsigned short startPage, endPage;
    373              unsigned char error;
    374              unsigned short numPagesInRegion = AT91C_IFLASH_LOCK_REGION_SIZE / AT91C_IFLASH_PAGE_SIZE;
    375           
    376          #if OS_CRITICAL_METHOD == 3u  
    377              OS_CPU_SR  cpu_sr = 0u;
    378          #endif
    379              OS_ENTER_CRITICAL(); 
    380              
    381              // Compute actual unlock range and store it
    382              ComputeLockRange(start, end, &actualStart, &actualEnd);
    383              if (pActualStart) {
    384          
    385                  *pActualStart = actualStart;
    386              }
    387              if (pActualEnd) {
    388          
    389                  *pActualEnd = actualEnd;
    390              }
    391          
    392              // Compute page numbers
    393              EFC_TranslateAddress(actualStart, &pStartEfc, &startPage, 0);
    394              EFC_TranslateAddress(actualEnd, &pEndEfc, &endPage, 0);
    395          
    396              // Unlock all pages
    397              // If there is an EFC crossover, unlock all pages from first EFC
    398          #if defined(AT91C_BASE_EFC1)
    399              if (pStartEfc != pEndEfc) {
    400          
    401                  while (startPage < (AT91C_IFLASH_NB_OF_PAGES / 2)) {
    402          
    403                      error = EFC_PerformCommand(pStartEfc, AT91C_MC_FCMD_UNLOCK, startPage);
    404                      if (error) {
    405                        
    406                          OS_EXIT_CRITICAL();
    407                          return error;
    408                      }
    409                      startPage += numPagesInRegion;
    410                  }
    411                  startPage = 0;
    412              }
    413          #endif
    414              pEfc = pEndEfc;
    415          
    416              // Unlock remaining pages
    417              while (startPage < endPage) {
    418          
    419                  error = EFC_PerformCommand(pEfc, AT91C_MC_FCMD_UNLOCK, startPage);
    420                  if (error) {
    421                    
    422                      OS_EXIT_CRITICAL();
    423                      return error;
    424                  }
    425                  startPage += numPagesInRegion;            
    426                   
    427              }
    428          
    429              OS_EXIT_CRITICAL();
    430              
    431              return 0;
    432          }
    433          
    434          //------------------------------------------------------------------------------
    435          /// Returns the number of locked regions inside the given address range.
    436          /// \param start  Start address of range.
    437          /// \param end  End address of range.
    438          //------------------------------------------------------------------------------
    439          unsigned char FLASHD_IsLocked(unsigned int start, unsigned int end)
    440          {
    441              AT91S_EFC *pStartEfc, *pEndEfc, *pEfc;
    442              unsigned short startPage, endPage;
    443              unsigned char startRegion, endRegion;
    444              unsigned int numPagesInRegion;
    445              unsigned int numLockedRegions = 0;
    446              unsigned int status;
    447              
    448              // Get EFC & page values
    449              EFC_TranslateAddress(start, &pStartEfc, &startPage, 0);
    450              EFC_TranslateAddress(end, &pEndEfc, &endPage, 0);
    451          
    452              // Compute region indexes
    453              numPagesInRegion = AT91C_IFLASH_LOCK_REGION_SIZE / AT91C_IFLASH_PAGE_SIZE;
    454              startRegion = startPage / numPagesInRegion;
    455              endRegion = endPage / numPagesInRegion;
    456              if ((endPage % numPagesInRegion) != 0) {
    457          
    458                  endRegion++;
    459              }
    460          
    461              // EFC cross-over, handle starting page -> end page of EFC0
    462          #if defined(AT91C_BASE_EFC1)
    463              if (pStartEfc != pEndEfc) {
    464          
    465                  status = EFC_GetStatus(pStartEfc);
    466                  while (startRegion < 16) {
    467          
    468                      if ((status & (1 << startRegion << 16)) != 0) {
    469          
    470                          numLockedRegions++;
    471                      }
    472                      startRegion++;
    473                  }
    474                  startRegion = 0;
    475              }
    476          #endif
    477              pEfc = pEndEfc;
    478          
    479              // Remaining regions / no EFC cross-over
    480              status = EFC_GetStatus(pEfc);
    481              while (startRegion < endRegion) {
    482          
    483                  if ((status & (1 << startRegion << 16)) != 0) {
    484          
    485                      numLockedRegions++;
    486                  }
    487                  startRegion++;
    488              }
    489          
    490              return numLockedRegions;
    491          }
    492          
    493          #if (EFC_NUM_GPNVMS > 0)
    494          //------------------------------------------------------------------------------
    495          /// Returns 1 if the given GPNVM bit is currently set; otherwise returns 0.
    496          /// \param gpnvm  GPNVM bit index.
    497          //------------------------------------------------------------------------------
    498          unsigned char FLASHD_IsGPNVMSet(unsigned char gpnvm)
    499          {
    500              AT91S_EFC *pEfc = AT91C_BASE_EFC0;
    501              unsigned int status;
    502          
    503              //SANITY_CHECK(gpnvm < EFC_NUM_GPNVMS);
    504          
    505          #ifdef AT91C_BASE_EFC1
    506              // GPNVM in EFC1
    507              if (gpnvm >= 8) {
    508          
    509                  pEfc = AT91C_BASE_EFC1;
    510                  gpnvm -= 8;
    511              }
    512          #endif
    513          
    514              // Check if GPNVM is set
    515              status = EFC_GetStatus(pEfc);
    516              if ((status & (1 << gpnvm << 8)) != 0) {
    517          
    518                  return 1;
    519              }
    520              else {
    521          
    522                  return 0;
    523              }
    524          }
    525          
    526          //------------------------------------------------------------------------------
    527          /// Sets the selected GPNVM bit.
    528          /// Returns 0 if successful; otherwise returns an error code.
    529          /// \param gpnvm  GPNVM index.
    530          //------------------------------------------------------------------------------
    531          unsigned char FLASHD_SetGPNVM(unsigned char gpnvm)
    532          {
    533              AT91S_EFC *pEfc = AT91C_BASE_EFC0;
    534          
    535              //SANITY_CHECK(gpnvm < EFC_NUM_GPNVMS);
    536          
    537              if (!FLASHD_IsGPNVMSet(gpnvm)) {
    538          
    539          #ifdef AT91C_BASE_EFC1
    540                  // GPNVM in EFC1
    541                  if (gpnvm >= 8) {
    542          
    543                      pEfc = AT91C_BASE_EFC1;
    544                      gpnvm -= 8;
    545                  }
    546          #endif
    547          
    548                  return EFC_PerformCommand(pEfc, AT91C_MC_FCMD_SET_GP_NVM, gpnvm);
    549              }
    550              else {
    551          
    552                  return 0;
    553              }
    554          }
    555          
    556          //------------------------------------------------------------------------------
    557          /// Clears the selected GPNVM bit.
    558          /// Returns 0 if successful; otherwise returns an error code.
    559          /// \param gpnvm  GPNVM index.
    560          //------------------------------------------------------------------------------
    561          unsigned char FLASHD_ClearGPNVM(unsigned char gpnvm)
    562          {
    563              AT91S_EFC *pEfc = AT91C_BASE_EFC0;
    564          
    565              //SANITY_CHECK(gpnvm < EFC_NUM_GPNVMS);
    566          
    567              if (FLASHD_IsGPNVMSet(gpnvm)) {
    568          
    569          #ifdef AT91C_BASE_EFC1
    570                  // GPNVM in EFC1
    571                  if (gpnvm >= 8) {
    572          
    573                      pEfc = AT91C_BASE_EFC1;
    574                      gpnvm -= 8;
    575                  }
    576          #endif
    577          
    578                  return EFC_PerformCommand(pEfc, AT91C_MC_FCMD_CLR_GP_NVM, gpnvm);
    579              }
    580              else {
    581          
    582                  return 0;
    583              }
    584          }
    585          #endif //#if (EFC_NUM_GPNVMS > 0)
    586          
    587          #if !defined EFC_NO_SECURITY_BIT
    588          //------------------------------------------------------------------------------
    589          /// Returns 1 if the Security bit is currently set; otherwise returns 0.
    590          //------------------------------------------------------------------------------
    591          unsigned char FLASHD_IsSecurityBitSet(void)
    592          {
    593          
    594              AT91S_EFC *pEfc = AT91C_BASE_EFC0;
    595              unsigned int status;
    596          
    597              status = EFC_GetStatus(pEfc);
    598              return ( ((status & AT91C_MC_SECURITY) != 0)?1:0 );
    599              
    600          }
    601          
    602          //------------------------------------------------------------------------------
    603          /// Set Security Bit Command (SSB).
    604          /// Returns 0 if successful; otherwise returns an error code.
    605          //------------------------------------------------------------------------------
    606          unsigned char FLASHD_SetSecurityBit(void)
    607          {
    608              AT91S_EFC *pEfc = AT91C_BASE_EFC0;
    609           
    610              if( FLASHD_IsSecurityBitSet() == 0) {
    611                  return EFC_PerformCommand(pEfc, AT91C_MC_FCMD_SET_SECURITY, 0);
    612              }
    613              else {
    614                  return 0;
    615              }
    616          }
    617          
    618          #endif //#if (!defined EFC_NO_SECURITY_BIT)
    619          #endif //#ifdef BOARD_FLASH_EFC
    620          
    621          
    622          
    623          
    624          
    625          int flash_test( void )
    626          {  
    627              unsigned int i, j;
    628              unsigned char error;
    629              unsigned int pBuffer[AT91C_IFLASH_PAGE_SIZE / 4];
    630              unsigned int lastPageAddress;
    631              volatile unsigned int *pLastPageData;
    632              //unsigned char pageLocked;
    633          
    634              // Initialize flash driver
    635              //FLASHD_Initialize( BOARD_MCK );
    636          
    637              // Unlock whole flash
    638              
    639              //printf("-I- Unlocking the whole flash\n\r");
    640              LED_Clear(LED_DS2); 
    641            
    642             
    643          // The AT91SAM7A3 has 16 lock regions. Each lock region contains 16 pages of 256 bytes. 
    644          // Each lock region has a size of 4 Kbytes, thus only the first 64 Kbytes can be locked.
    645          #if defined(at91sam7a3)
    646              error = FLASHD_Unlock(AT91C_IFLASH, AT91C_IFLASH + 64 * 1024, 0, 0);  // 16* 16 * 256 = 64kB, Only the first 64KB can be locked in the SAM7A3
    647          #else
    648              error = FLASHD_Unlock(AT91C_IFLASH, AT91C_IFLASH + AT91C_IFLASH_SIZE, 0, 0);
    649          #endif
    650              //ASSERT(!error, "-F- Error while trying to unlock the whole flash (0x%02X)\n\r", error);
    651              
    652              if(error !=0 ) {
    653                  while(1);
    654              }
    655              //fill data to sectors :  512 ~ 1024.
    656              for(j = 1; j<= 512; j++) {
    657                
    658                  LED_Toggle(LED_DS2); 
    659                  // Performs tests on last page (to avoid overriding existing program).
    660                  lastPageAddress = AT91C_IFLASH + AT91C_IFLASH_SIZE - AT91C_IFLASH_PAGE_SIZE * j;
    661                  pLastPageData = (volatile unsigned int *) lastPageAddress;
    662              
    663                  // Write page with walking bit pattern (0x00000001, 0x00000002, ...)
    664                  //printf("-I- Writing last page with walking bit pattern\n\r");
    665                  for (i=0; i < (AT91C_IFLASH_PAGE_SIZE / 4); i++) {
    666              
    667                      pBuffer[i] = 0xee;//(i % 32);
    668                  }
    669                  error = FLASHD_Write(lastPageAddress, pBuffer, AT91C_IFLASH_PAGE_SIZE);    
    670               
    671                  //ASSERT(!error, "-F- Error when trying to write page (0x%02X)\n\r", error);
    672                  // Check page contents
    673                  //printf("-I- Checking page contents ");
    674                  for (i=0; i < (AT91C_IFLASH_PAGE_SIZE / 4); i++) {
    675                      //printf(".");
    676                      //ASSERT(pLastPageData[i] == (1 << (i % 32)),\
    677                             "\n\r-F- Expected 0x%08X at address 0x%08X, found 0x%08X\n\r",\
    678                             (1 << (i % 32)), (unsigned int) &(pLastPageData[i]), pLastPageData[i]);
    679                               if( pLastPageData[i] != (1 << (i % 32))) {
    680                                 LED_Set(LED_DS2); 
    681                                 break;
    682                               }
    683                  }
    684              
    685              }
    686              
    687              /*****************************************************************************/
    688              LED_Clear(LED_DS2);    
    689              //while(1);
    690                  
    691              //printf(" ok \n\r");
    692           
    693          #if defined(at91sam7a3)
    694              // Only the first 64Kb can be locked in the SAM7A3
    695              lastPageAddress = AT91C_IFLASH + (64*1024) - AT91C_IFLASH_PAGE_SIZE;
    696          #endif
    697          
    698              
    699              // Lock page
    700              //printf("-I- Locking last page\n\r");
    701              //error = FLASHD_Lock(lastPageAddress, lastPageAddress + AT91C_IFLASH_PAGE_SIZE, 0, 0);
    702              //ASSERT(!error, "-F- Error when trying to lock page (0x%02X)\n\r", error);
    703          
    704              // Check that associated region is locked
    705              //printf("-I- Checking lock status ... ");
    706              //pageLocked = FLASHD_IsLocked(lastPageAddress, lastPageAddress + AT91C_IFLASH_PAGE_SIZE);
    707              //ASSERT(pageLocked, "\n\r-F- Page is not locked\n\r");
    708              //printf("ok\n\r");
    709          
    710              // Unlock page
    711              //printf("-I- Unlocking last page\n\r");
    712              //error = FLASHD_Unlock(lastPageAddress, lastPageAddress + AT91C_IFLASH_PAGE_SIZE, 0, 0);
    713              //ASSERT(!error, "-F- Error when trying to unlock page (0x%02X)\n\r", error);
    714          
    715              // Check that associated region is unlocked
    716              //printf("-I- Checking lock status ... ");
    717              //pageLocked = FLASHD_IsLocked(lastPageAddress, lastPageAddress + AT91C_IFLASH_PAGE_SIZE);
    718              //ASSERT(!pageLocked, "\n\r-F- Page is locked\n\r");
    719              //printf("ok\n\r");
    720          
    721              
    722          #if (EFC_NUM_GPNVMS > 0)
    723              // Test GPNVM bit #1 (should be safe)
    724              if (FLASHD_IsGPNVMSet(1)) {
    725          
    726                  //printf("-I- GPNVM #1 is set\n\r");
    727          
    728                  // Clear GPNVM
    729                  //printf("-I- Clearing GPNVM #%d\n\r", 1);
    730                  error = FLASHD_ClearGPNVM(1);
    731                  //ASSERT(!error, "-F- Error while trying to clear GPNVM (0x%02X)\n\r", error);
    732                  //ASSERT(!FLASHD_IsGPNVMSet(1), "-F- GPNVM is set\n\r");
    733          
    734                  // Set GPNVM
    735                  //printf("-I- Setting GPNVM #%d\n\r", 1);
    736                  error = FLASHD_SetGPNVM(1);
    737                  //ASSERT(!error, "-F- Error while trying to set GPNVM (0x%02X)\n\r", error);
    738                  //ASSERT(FLASHD_IsGPNVMSet(1), "-F- GPNVM is not set\n\r");
    739          
    740              }
    741              else {
    742          
    743                  //printf("-I- GPNVM #1 is cleared\n\r");
    744          
    745                  // Set GPNVM
    746                  //printf("-I- Setting GPNVM #%d\n\r", 1);
    747                  error = FLASHD_SetGPNVM(1);
    748                  //ASSERT(!error, "-F- Error while trying to set GPNVM (0x%02X)\n\r", error);
    749                  //ASSERT(FLASHD_IsGPNVMSet(1), "-F- GPNVM is not set\n\r");
    750          
    751                  // Clear GPNVM
    752                  //printf("-I- Clearing GPNVM #%d\n\r", 1);
    753                  error = FLASHD_ClearGPNVM(1);
    754                  //ASSERT(!error, "-F- Error while trying to clear GPNVM (0x%02X)\n\r", error);
    755                  //ASSERT(!FLASHD_IsGPNVMSet(1), "-F- GPNVM is set\n\r");
    756              }
    757          #endif
    758          
    759              //printf("-I- All tests ok\n\r");
    760            
    761              return 0;
    762          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   ComputeLockRange
        48   -> EFC_ComputeAddress
        48   -> EFC_TranslateAddress
        48   -> __aeabi_idivmod
       8   FLASHD_Erase
         8   -> EFC_PerformCommand
       8   FLASHD_Initialize
         8   -> EFC_DisableIt
         8   -> EFC_SetEraseBeforeProgramming
         8   -> EFC_SetMasterClock
      48   FLASHD_IsLocked
        48   -> EFC_GetStatus
        48   -> EFC_TranslateAddress
        48   -> __aeabi_uidiv
        48   -> __aeabi_uidivmod
      56   FLASHD_Lock
        56   -> ComputeLockRange
        56   -> EFC_PerformCommand
        56   -> EFC_TranslateAddress
        56   -> OS_CPU_SR_Restore
        56   -> OS_CPU_SR_Save
      56   FLASHD_Unlock
        56   -> ComputeLockRange
        56   -> EFC_PerformCommand
        56   -> EFC_TranslateAddress
        56   -> OS_CPU_SR_Restore
        56   -> OS_CPU_SR_Save
      56   FLASHD_Write
        56   -> EFC_ComputeAddress
        56   -> EFC_PerformCommand
        56   -> EFC_TranslateAddress
        56   -> OS_CPU_SR_Restore
        56   -> OS_CPU_SR_Save
        56   -> memcpy
        56   -> min
     280   flash_test
       280   -> FLASHD_Unlock
       280   -> FLASHD_Write
       280   -> LED_Clear
       280   -> LED_Set
       280   -> LED_Toggle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
     228  ComputeLockRange
      40  FLASHD_Erase
      48  FLASHD_Initialize
     200  FLASHD_IsLocked
     252  FLASHD_Lock
     252  FLASHD_Unlock
     364  FLASHD_Write
     272  flash_test
     256  pPageBuffer

 
   256 bytes in section .bss
 1 660 bytes in section .text
 
 1 660 bytes of CODE memory
   256 bytes of DATA memory

Errors: none
Warnings: none
