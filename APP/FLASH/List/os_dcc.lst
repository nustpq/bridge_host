###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        21/Jun/2016  16:45:22
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\uCOS-II\Ports\ARM\Generic\IAR\os_dcc.c
#    Command line =  
#        "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\uCOS-II\Ports\ARM\Generic\IAR\os_dcc.c" -lcN
#        "F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "F:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "F:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "F:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\os_dcc.lst
#    Object file  =  
#        F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\os_dcc.o
#
###############################################################################

F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\uCOS-II\Ports\ARM\Generic\IAR\os_dcc.c
      1          /*
      2          *********************************************************************************************************
      3          *                                               uC/OS-II
      4          *                                         The Real-Time Kernel
      5          *
      6          *
      7          *                             (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                          All Rights Reserved
      9          *
     10          *                                           Generic ARM Port
     11          *                                          DCC Communication
     12          *
     13          * File      : OS_DCC.C
     14          * Version   : V2.89
     15          *
     16          * For       : ARM7 or ARM9
     17          * Mode      : ARM or Thumb
     18          * Toolchain : IAR's EWARM V4.40a and higher
     19          *********************************************************************************************************
     20          */
     21          
     22          #include <ucos_ii.h>
     23                                                               /* This directive suppresses warnings for non-... */
     24          #pragma  diag_suppress=Pe940                         /* ...void functions with no return values.       */
     25          
     26          #if OS_CPU_ARM_DCC_EN > 0
     27          
     28          /*
     29          *********************************************************************************************************
     30          *                                           CONSTANTS
     31          *********************************************************************************************************
     32          */
     33          
     34          #define  OS_DCC_OP_READ_U32     0x01000000
     35          #define  OS_DCC_OP_READ_U16     0x02000000
     36          #define  OS_DCC_OP_READ_U8      0x04000000
     37          #define  OS_DCC_OP_GET_CAPS     0x08000000
     38          #define  OS_DCC_OP_WRITE_U32    0x10000000
     39          #define  OS_DCC_OP_WRITE_U16    0x20000000
     40          #define  OS_DCC_OP_WRITE_U8     0x40000000
     41          #define  OS_DCC_OP_ODD_ADDR     0x80000000
     42          #define  OS_DCC_OP_COMMAND      0x00000001
     43          
     44          #define  OS_DCC_COMM_CTRL_RD    0x00000001
     45          #define  OS_DCC_COMM_CTRL_WR    0x00000002
     46          
     47          #define  OS_DCC_SIGNATURE       0x91CA0000
     48          #define  OS_DCC_CONFIG          0x00000077
     49          
     50          /*
     51          *********************************************************************************************************
     52          *                                          LOCAL VARIABLES
     53          *********************************************************************************************************
     54          */
     55          
     56          static  INT32U  OSDCC_Cmd;
     57          static  INT32U  OSDCC_Addr;
     58          static  INT32U  OSDCC_ItemCnt;
     59          static  INT32U  OSDCC_Data;
     60          
     61          /*
     62          *********************************************************************************************************
     63          *                                       OSDCC_ReadCtrl()
     64          *
     65          * Description: This function retrieves data from the comms control register.
     66          *
     67          * Arguments  : none
     68          *
     69          * Returns    : The contents of the comms control register
     70          *
     71          * Notes      : 1) This function uses a coprocessor register transfer instruction to place the contents
     72          *                 of the comms control register in R0.  Thus, the function does not contain an
     73          *                 explicit return statement.  "#pragma diag_suppress=Pe940", which appears at the
     74          *                 top of this file, is used to suppress the warning that normally results from non-
     75          *                 void functions lacking return statements.
     76          *********************************************************************************************************
     77          */
     78          
     79          static  __arm  INT32U  OSDCC_ReadCtrl (void)
     80          {
     81              __asm("mrc  P14,0,R0,C0,C0");
     82          }
     83          
     84          /*
     85          *********************************************************************************************************
     86          *                                         OSDCC_Read()
     87          *
     88          * Description: This function retrieves data from the comms data read register.
     89          *
     90          * Arguments  : none
     91          *
     92          * Returns    : The contents of the comms data read register
     93          *
     94          * Notes      : 1) This function uses a coprocessor register transfer instruction to place the contents
     95          *                 of the comms data read register in R0.  Thus, the function does not contain an
     96          *                 explicit return statement.  "#pragma diag_suppress=Pe940", which appears at the
     97          *                 top of this file, is used to suppress the warning that normally results from non-
     98          *                 void functions lacking return statements.
     99          *********************************************************************************************************
    100          */
    101          
    102          static  __arm  INT32U  OSDCC_Read (void)
    103          {
    104              __asm("mrc  P14,0,R0,C1,C0");
    105          }
    106          
    107          /*
    108          *********************************************************************************************************
    109          *                                        OSDCC_Write()
    110          *
    111          * Description: This function places data in the comms data write register.
    112          *
    113          * Arguments  : none
    114          *
    115          * Returns    : none
    116          *********************************************************************************************************
    117          */
    118          
    119          static  __arm  void  OSDCC_Write (INT32U data)
    120          {
    121              __asm("mcr  P14,0,R0,C1,C0");
    122          }
    123          
    124          /*
    125          *********************************************************************************************************
    126          *                                        OSDCC_Handler()
    127          *
    128          * Description: This function reads commands from the DCC comms data read register.  Data may be
    129          *              transferred to or from memory based on those commands.
    130          *
    131          * Arguments  : none
    132          *
    133          * Returns    : none
    134          *
    135          * Notes      : 1) This function should be called periodically.  If OS_CPU_ARM_DCC_EN is '1', this
    136          *                 function will be called from both the idle task hook and the tick interrupt hook.
    137          *********************************************************************************************************
    138          */
    139          
    140          void  OSDCC_Handler (void)
    141          {
    142              INT32U  reg_val;
    143          #if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    144              OS_CPU_SR  cpu_sr = 0;
    145          #endif
    146          
    147          
    148              OS_ENTER_CRITICAL();                             /* Disable interrupts                             */
    149          
    150                                                               /* Check for the presence of new data             */
    151              if ((OSDCC_ReadCtrl() & OS_DCC_COMM_CTRL_RD) != 0) {
    152                  reg_val = OSDCC_Read();                      /* Read the new data                              */
    153          
    154                  if ((reg_val & OS_DCC_OP_COMMAND) != 0) {    /* Determine whether a command has been received  */
    155                      OSDCC_Cmd = reg_val;
    156                                                               /* Check for an odd address in the next operation */
    157                      if ((OSDCC_Cmd & OS_DCC_OP_ODD_ADDR) != 0) {
    158                          OSDCC_Addr |= 1;
    159                      }
    160                                                               /* If data will be read, adjust OSDCC_ItemCnt     */
    161                      if ((OSDCC_Cmd & (OS_DCC_OP_READ_U32 | OS_DCC_OP_READ_U16 | OS_DCC_OP_READ_U8
    162                                                           |  OS_DCC_OP_GET_CAPS)) != 0) {
    163                          OSDCC_ItemCnt = (OSDCC_Cmd >> 2) & 0xffff;
    164                      } else {                                 /* Data will be written; initialize OSDCC_Data    */
    165                          if ((OSDCC_Cmd & OS_DCC_OP_WRITE_U32) != 0) {
    166                              OSDCC_Data |= (OSDCC_Cmd << 14) & 0xffff0000;
    167                          } else {
    168                              OSDCC_Data = (OSDCC_Cmd >> 2) & 0xffff;
    169                          }
    170                                                               /* Write a single byte                            */
    171                          if ((OSDCC_Cmd & OS_DCC_OP_WRITE_U8) != 0) {
    172                              *(INT8U *)OSDCC_Addr = OSDCC_Data;
    173                              OSDCC_Addr += 1;
    174                          }
    175                                                               /* Write two bytes                                */
    176                          if ((OSDCC_Cmd & OS_DCC_OP_WRITE_U16) != 0) {
    177                              *(INT16U *)OSDCC_Addr = OSDCC_Data;
    178                              OSDCC_Addr += 2;
    179                          }
    180                                                               /* Write four bytes                               */
    181                          if ((OSDCC_Cmd & OS_DCC_OP_WRITE_U32) != 0) {
    182                              *(INT32U *)OSDCC_Addr =OSDCC_Data;
    183                              OSDCC_Addr += 4;
    184                          }
    185                      }
    186                      OS_EXIT_CRITICAL();
    187                      return;
    188                  }
    189                  OSDCC_Addr     = reg_val;                    /* An address was received; OSDCC_Addr is updated */
    190              }
    191                                                               /* Determine whether data must be read            */
    192              if (OSDCC_ItemCnt != 0) {
    193                                                               /* Confirm that the comms data write register...  */
    194                                                               /* ...is free from the processor point of view    */
    195                  if ((OSDCC_ReadCtrl() & OS_DCC_COMM_CTRL_WR) == 0) {
    196                      reg_val = (OS_DCC_CONFIG | OS_DCC_SIGNATURE);
    197                                                               /* Read a single byte                             */
    198                      if ((OSDCC_Cmd & OS_DCC_OP_READ_U8) != 0) {
    199                          reg_val = *(INT8U *)OSDCC_Addr;
    200                          OSDCC_Addr += 1;
    201                      }
    202                                                               /* Read two bytes                                 */
    203                      if ((OSDCC_Cmd & OS_DCC_OP_READ_U16) != 0) {
    204                          reg_val = *(INT16U *)OSDCC_Addr;
    205                          OSDCC_Addr += 2;
    206                      }
    207                                                               /* Read four bytes                                */
    208                      if ((OSDCC_Cmd & OS_DCC_OP_READ_U32) != 0) {
    209                          reg_val = *(INT32U *)OSDCC_Addr;
    210                          OSDCC_Addr += 4;
    211                      }
    212          
    213                      OSDCC_Write(reg_val);                    /* Place data in the comms data write register    */
    214                      OSDCC_ItemCnt--;                         /* Decrement the number of items to be read       */
    215                  }
    216              }
    217              OS_EXIT_CRITICAL();
    218          }
    219          
    220          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   OSDCC_Handler
        16   -> OSDCC_Read
        16   -> OSDCC_ReadCtrl
        16   -> OSDCC_Write
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
       0   OSDCC_Read
       0   OSDCC_ReadCtrl
       0   OSDCC_Write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  OSDCC_Addr
       4  OSDCC_Cmd
       4  OSDCC_Data
     636  OSDCC_Handler
       4  OSDCC_ItemCnt
       8  OSDCC_Read
       8  OSDCC_ReadCtrl
       8  OSDCC_Write

 
  16 bytes in section .bss
 680 bytes in section .text
 
 680 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
