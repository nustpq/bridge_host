###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Aug/2014  09:36:58
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\codec.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\codec.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\codec.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\codec.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\codec.c
      1          #include <bsp.h>
      2          #include <pio.h>
      3          #include <async.h>
      4          #include <twid.h>
      5          #include "codec.h"
      6          
      7          
      8          
      9          unsigned char Codec_Read(unsigned char dev_addr,unsigned char reg,unsigned char *pVal)
     10          {
     11              unsigned char state = 0;   
     12              state =  TWID_Read( dev_addr>>1, reg, 1, pVal++,1, NULL) ;
     13              return(state);
     14          }
     15          
     16          
     17          unsigned char Codec_Write(unsigned char dev_addr,unsigned char reg,unsigned char data)
     18          {      
     19              unsigned char buf[] = {  data };     
     20              unsigned char state;
     21                
     22              state =  TWID_Write( dev_addr>>1, reg, 1 , buf, sizeof(buf), NULL);     
     23              
     24              return state ;
     25          }
     26          
     27          
     28          unsigned char Codec_Read_SPI(unsigned char dev_addr,unsigned char reg,unsigned char *pVal)
     29          {
     30              unsigned char state = 0;   
     31              //state =  TWID_Read( dev_addr>>1, reg, 1, pVal++,1, NULL) ;
     32              return(state);
     33          }
     34          
     35          
     36          unsigned char Codec_Write_SPI(unsigned char dev_addr,unsigned char reg,unsigned char data)
     37          {      
     38              unsigned char buf[] = { dev_addr<<1, reg, data };     
     39              unsigned char state;    
     40              
     41              state = SPI_WriteBuffer_API( buf, 3);     
     42            
     43              
     44              return state ;
     45              
     46          }
     47          
     48          
     49          //i2c_channel = 0 ~ 7
     50          unsigned char Codec_Mixer(unsigned char i2c_channel )
     51          {    
     52               unsigned char buf   ;
     53               unsigned char state ;
     54               
     55               state = 0xe0 ; 
     56               
     57               if( i2c_channel <= 3 )  {//PCA9548A,
     58                  buf   = 0x01<<i2c_channel ; //select i2c_channel
     59                  state = TWID_Write( PCA9548A_ADDRESS>>1, 0, 0, &buf, 1, NULL); 
     60               /*
     61                  buf   = 0 ;
     62                  state = TWID_Write( PCA9540B_ADDRESS>>1, 0, 0, &buf, 1, NULL); 
     63                
     64               } else {  // PCA9540B
     65                  buf   = 4 ; //select CH0
     66                  state = TWID_Write( PCA9540B_ADDRESS>>1, 0, 0, &buf, 1, NULL); 
     67                  buf   = 0 ;
     68                  state = TWID_Write( PCA9548A_ADDRESS>>1, 0, 0, &buf, 1, NULL); 
     69               */
     70               }
     71               
     72               return state ;
     73          }
     74          
     75          
     76          
     77          
     78          
     79          
     80          unsigned char Set_Codec(unsigned char codec_control_type, unsigned char size_para, unsigned char *pdata)
     81          {
     82              unsigned char i, state = 0 ;
     83              for(i = 0; i< size_para ; i++)
     84              {
     85                if(codec_control_type == 0 ) {
     86                  state = Codec_Write(CODEC_ADDRESS,*(pdata+i*2),*(pdata+i*2+1));
     87                } else {
     88                  state = Codec_Write_SPI(AD1938_ADDRESS,*(pdata+i*2),*(pdata+i*2+1));
     89                }
     90                  if( state != 0 ) break;
     91              }
     92              return state;
     93            
     94          }
     95          
     96          
     97          unsigned char Get_Codec(unsigned char codec_control_type, unsigned char reg, unsigned char *pdata)
     98          {
     99              unsigned char state = 0 ;
    100              
    101              if(codec_control_type == 0 ) {
    102                  state = Codec_Read( CODEC_ADDRESS, reg, pdata) ;
    103              } else {
    104                  state = Codec_Read_SPI( CODEC_ADDRESS, reg, pdata) ;
    105              }
    106              
    107              return state;
    108            
    109          }
    110          
    111          
    112          /*********************************************************************************************************************************/
    113          // OSC=12.288Mhz
    114          
    115          unsigned char I2CWrite_Codec( unsigned char reg,unsigned char data )
    116          {
    117              unsigned char err;
    118              err = Codec_Write( AD1937_ADDRESS, reg, data);
    119              return err;
    120          }
    121          
    122          unsigned char I2CWrite_Codec_AIC3204( unsigned char reg,unsigned char data )
    123          {
    124              unsigned char err;
    125              err = Codec_Write( CODEC_ADDRESS, reg, data);
    126              return err;
    127          }
    128          
    129          void ALL_POWER_ON(void)
    130          {
    131              I2CWrite_Codec(DAC_Control0,0x00);  //
    132              I2CWrite_Codec(ADC_Control0,0x00);  //
    133          }
    134          
    135          
    136          void ALL_POWER_OFF(void)
    137          {
    138              I2CWrite_Codec(DAC_Control0,0x01);  //
    139              I2CWrite_Codec(ADC_Control0,0x01);  //
    140          }
    141          
    142          
    143          unsigned char Codec_DAC_Attenuation( unsigned char DAC_NAME, unsigned int x10gain )
    144          {
    145              
    146              unsigned char err;
    147              float temp ;
    148              
    149              if( x10gain == 1000 ){        
    150                  return 0 ;
    151              }
    152              if (x10gain > 945) {//0.375*252=94.5dB         
    153                  err = CODEC_SETVOL_RANGE_ERR;
    154                  APP_TRACE_INFO(("ERR: CODEC Gain Over Range!\r\n"));        
    155                  return err;
    156              }
    157              temp = x10gain/(0.375*10); 
    158              err = I2CWrite_Codec(DAC_NAME,(unsigned char)temp);
    159              if( OS_ERR_NONE != err ) {
    160                  err = CODEC_WR_REG_ERR;
    161                  return err ;
    162              }
    163              APP_TRACE_DBG(("\r\nSet CODEC REG[%d]=0x%0X",DAC_NAME,(unsigned char)temp)); 
    164              
    165              return 0;
    166          
    167          }
    168          
    169          //unsigned char Codec_DAC_Attenuation( unsigned char DAC_NAME, float gain )
    170          //{
    171          //    
    172          //    unsigned char err;
    173          //    float temp ;
    174          //      
    175          //    if ( gain > 0 ) {         
    176          //        err = 1;
    177          //        return err;
    178          //    }
    179          //    
    180          //    if(gain< -95.25 ) {
    181          //        temp = 255 ;
    182          //        
    183          //    } else {
    184          //        temp = -gain/0.375; 
    185          //        
    186          //    }
    187          //    
    188          //    err = I2CWrite_Codec(DAC_NAME,(unsigned char)temp);
    189          //    
    190          //    return err;
    191          //    
    192          //}
    193          
    194          
    195          // Main clock source = 12.288 MHz.   
    196          unsigned char Codec_SetFCLK( unsigned int fclk )
    197          {
    198              
    199              unsigned char err;
    200              unsigned char pll_reg;
    201              
    202              switch( fclk )   {
    203                
    204                  case 8000:  // Need  12.288 / 2 MHz Osc 
    205                      pll_reg = 0x9e;      
    206                      return CODEC_SETFCLK_RANGE_ERR;
    207                      break;            
    208                  case 16000:            
    209                      pll_reg = 0x9e;            
    210                      break;
    211                  case 24000:      
    212                      pll_reg = 0x9c;            
    213                      break;
    214                  case 32000:            
    215                      pll_reg = 0x9a;      
    216                      break;
    217                  case 44100: // Need 11.2896 MHz Osc 
    218                      pll_reg = 0x98;  
    219                      return CODEC_SETFCLK_RANGE_ERR;
    220                      break;
    221                  case 48000:             
    222                      pll_reg = 0x98;            
    223                      break;
    224                  case 96000: // Need 12.288 * 2 MHz Osc       
    225                      pll_reg = 0x98;             
    226                      return CODEC_SETFCLK_RANGE_ERR;
    227                      break;
    228                  case 0 : //power down clock
    229                      pll_reg = 0x01; 
    230                      break;
    231                  default:
    232                      return CODEC_SETFCLK_RANGE_ERR;
    233                      break;
    234                      
    235              }
    236              
    237              err = I2CWrite_Codec( PLL_Control0, pll_reg );
    238              if( OS_ERR_NONE != err ) {
    239                  err = CODEC_WR_REG_ERR;
    240                  return err ;
    241              }
    242          
    243              return err;
    244              
    245          }
    246          
    247          
    248          unsigned char Codec_SetMode( unsigned char mode )
    249          {
    250              unsigned char err;
    251              unsigned char dac_reg0,dac_reg1;
    252              unsigned char adc_reg1,adc_reg2;
    253              
    254              switch( mode )  {
    255              
    256                  case I2S_MODE:
    257                           dac_reg0 = 0x00;      //I2S
    258                           dac_reg1 = 0x70;      //2 channels
    259                           adc_reg1 = 0x03;      //I2S
    260                           adc_reg2 = 0x01;      //2 channels
    261                           break;
    262                  case TDM_MODE:
    263                           dac_reg0 = 0x40;      //TDM
    264                           dac_reg1 = 0x74;      // 8 channels
    265                           adc_reg1 = 0x23;      //TDM
    266                           adc_reg2 = 0x21;      // 8 channels
    267                           break;
    268                  case TDM16_MODE:
    269                           dac_reg0 = 0x40;      //TDM
    270                           dac_reg1 = 0x76;      // 16 channels
    271                           adc_reg1 = 0x23;      //TDM
    272                           adc_reg2 = 0x31;      // 16 channels
    273                           break;
    274                  default:
    275                          return CODEC_SETMODE_RANGE_ERR;
    276                          break;
    277              } 
    278              
    279              err = I2CWrite_Codec( DAC_Control0, dac_reg0 );
    280              if( OS_ERR_NONE != err ) {
    281                  err = CODEC_WR_REG_ERR;
    282                  return err ;
    283              }    
    284              err = I2CWrite_Codec( DAC_Control1, dac_reg1 );
    285              if( OS_ERR_NONE != err ) {
    286                  err = CODEC_WR_REG_ERR;
    287                  return err ;
    288              }
    289              
    290              err = I2CWrite_Codec( ADC_Control1, adc_reg1 );
    291              if( OS_ERR_NONE != err ) {
    292                  err = CODEC_WR_REG_ERR;
    293                  return err ;
    294              }    
    295              err = I2CWrite_Codec( ADC_Control2, adc_reg2 );
    296              if( OS_ERR_NONE != err ) {
    297                  err = CODEC_WR_REG_ERR;
    298                  return err ;
    299              }
    300          
    301              return err;    
    302            
    303          }
    304          
    305          /*******************************************/
    306          
    307          unsigned char Init_CODEC( unsigned int sample_rate )   
    308          { 
    309              unsigned char err;
    310              unsigned char i;
    311              static unsigned int sr_saved; 
    312              
    313              unsigned char reg_para[][2] = {
    314                  
    315                  { PLL_Control0,0x98 },
    316                  { PLL_Control1,0x00 },  //
    317                  { DAC_Control2,0x18 },  // 16bit    
    318                  { DAC_Mute    ,0xF0 },  // DAC3.4 mute.
    319                  { DAC1L_Volume,0x00 },  // no attenuation on SPK
    320                  { DAC1R_Volume,0x00 },  // no attenuation on SPK
    321                  { DAC2L_Volume,0x00 },  // no attenuation on Lout
    322                  { DAC2R_Volume,0x00 },  // no attenuation on Lout
    323                  { ADC_Control0,0x30 }  //Enable ADC
    324           //    { DAC3L_Volume,0x00 },  // not used on AB03
    325           //    { DAC3R_Volume,0x00 },  // not used on AB03 
    326                  
    327              };
    328              
    329              if( sample_rate == sr_saved ) {
    330                  return 0;
    331              } else {
    332                  sr_saved = sample_rate ;
    333              }
    334          
    335              for( i = 0; i< sizeof(reg_para)>>1; i++ ) {
    336                err = I2CWrite_Codec(reg_para[i][0], reg_para[i][1]); 
    337                if( OS_ERR_NONE != err ) {
    338                    err = CODEC_WR_REG_ERR;
    339                    return err ;
    340                }
    341                
    342              }
    343              
    344              err = Codec_SetFCLK( sample_rate );
    345              if( OS_ERR_NONE != err ) {
    346                  err = CODEC_WR_REG_ERR;
    347                  return err ;
    348              }    
    349          
    350              err = Codec_SetMode( TDM_MODE );   
    351              if( OS_ERR_NONE != err ) {
    352                  err = CODEC_WR_REG_ERR;
    353                  return err ;
    354              }     
    355          
    356              if( !( Get_Switches() & 0x01 ) ) {
    357                  err = CODEC_LOUT_Small_Gain_En( true ); //attenuation enable
    358              }
    359              
    360              return err;
    361              
    362          }
    363          
    364          
    365          
    366          
    367          
    368          unsigned char CODEC_LOUT_Small_Gain_En( bool small_gain )
    369          {
    370              unsigned char err;
    371              unsigned char reg;
    372              if( small_gain ) {        
    373                  reg = 64;    // 64*0.375=24dB attenuation on Lout     
    374                  APP_TRACE_INFO(("Lout Gain 24dB attenuation: Enabled \r\n"));  
    375                  
    376              } else {        
    377                  reg = 0;    // 0dB attenuation on Lout        
    378                  APP_TRACE_INFO(("Lout Gain 24dB attenuation: Disabled \r\n"));  
    379                  
    380              }    
    381              err = I2CWrite_Codec( DAC2L_Volume, reg );
    382              if( OS_ERR_NONE != err ) {
    383                  err = CODEC_WR_REG_ERR;
    384                  return err ;
    385              }    
    386              
    387              err = I2CWrite_Codec( DAC2R_Volume, reg );
    388              if( OS_ERR_NONE != err ) {
    389                  err = CODEC_WR_REG_ERR;
    390                  return err ;
    391              }
    392          
    393              return err;    
    394              
    395          }
    396          
    397          
    398          unsigned char CODEC_Set_Volume( unsigned int vol_spk, unsigned int vol_lin )
    399          {
    400             
    401              unsigned char err;
    402              unsigned char temp;
    403              
    404              temp = 0xF0;
    405              err = Codec_DAC_Attenuation(DAC1L_Volume, vol_spk );    
    406              if( OS_ERR_NONE != err ){
    407                  return err;
    408              }
    409              err = Codec_DAC_Attenuation(DAC1R_Volume, vol_spk );
    410              if( OS_ERR_NONE != err ){
    411                  return err;
    412              }
    413              
    414              err = Codec_DAC_Attenuation(DAC2L_Volume, vol_lin );
    415              if( OS_ERR_NONE != err ){
    416                  return err;
    417              }   
    418              err = Codec_DAC_Attenuation(DAC2R_Volume, vol_lin );
    419              if( OS_ERR_NONE != err ){
    420                  return err;
    421              }
    422               
    423              if( vol_spk == SET_VOLUME_MUTE ) {
    424                  temp += (3<<0);
    425              }
    426              if( vol_lin == SET_VOLUME_MUTE ) {
    427                  temp += (3<<2);
    428              }
    429              err = I2CWrite_Codec(DAC_Mute,temp);
    430              
    431              return err;
    432              
    433          }
    434          
    435          
    436          
    437          
    438          
    439          
    440          
    441          
    442          
    443          
    444          
    445          
    446          
    447          
    448          
    449          
    450          
    451          
    452          /*
    453          unsigned char config_aic3204[][2] = {
    454              
    455              
    456          	      0,0x00, //page0---------------------	      
    457          	      //software reset	
    458          	      1,0X01, 
    459          	      
    460          	      //PLL not used here
    461          	      4,0x01,	 //BCLK as main clock       
    462          	      11,0x84,  //NDAC=4    
    463          	      12,0x82,  //MDAC=2	      
    464          	      13,0x00,   
    465          	      14,32,    //DOSR=32
    466          	      
    467          	      18,0x84,  //NADC=4               
    468          	      19,0x82,  //MADC=2		      
    469          	      20,32,   //AOSR=32		    
    470          	      //30,0X82,  //bclk=bdiv_clkin/4
    471          
    472          	      //set route settings
    473          	      //29,0X11,    // Inner ADC is routed to DAC	
    474          	      //29,0X21,    // I2S input is routed to I2S output	
    475          	      //29,0X1,     // No innner rounte      
    476          
    477          	      //set digital interface, On S-II board CODEC set as master 
    478          	      27,0x71,   	//DSP mode,32bit,Slave,HZ after data transmit done	  
    479          	      28,96,   	//data offset 6*32 = 6<<5 = 192, defalut put line in channels on slot 6, 7 
    480          //	      32,0X00, 
    481          //	      33,0X4d, 
    482          	      34,0x20, 
    483          //	      53,0X02,  	//Dout is pin5
    484          //	      54,0X02,  	//pin4 is i2s data input  
    485          	         
    486          //		  //set channels
    487          //	      63,0Xd4, //DAC Channel Setup 
    488          //	      64,0X00, //DAC Channel Setup	 
    489          //	      65,0X00, //DAC Volume L set 0dB
    490          //	      66,0X00, //DAC Volume R set 0dB
    491          	     
    492          //	      //set dmic data pin setting
    493          //	      55,0X0e,   // Set MISO as PDM CLK ouput pin
    494          //	      56,0X02,   // SCLK pin is enabled	
    495                    
    496                    //set ADC channel
    497          	      81, 0xF0,//81, 0xDC , //????????adc_input_para,   // enable ADC and set SCLK as PDM DATA input pin-------	    
    498          	      //Dmic clock output(=adc_mod_clk), PDM CLK = ADC_MOD_CLK	        
    499          	      82,0X00,   //ADC Fine gain adjust, 0dB, unmute
    500          	      83,0X00,   //ADC Volume L set 0dB
    501          	      84,0X00,   //ADC Volume R set 0dB
    502          
    503          	      0,0X01,  //page1--------------------------
    504          	          
    505          	      //set power
    506          	      1,0x08,  //disconnect AVDD and DVDD		 
    507          	      2,0X01,  //enable Master Analog Power Control		
    508          //	      3,0X00,  //Set the DAC L PTM mode to PTM_P3/4
    509          //	      4,0X00,  //Set the DAC R PTM mode to PTM_P3/4		      
    510          //	      9, 0XFF,  //All HPOUT,LOUT and Mixer Amplifier are Power up  
    511          //	      9, 0x3c,
    512          	      10,0X00,  //Set the Input Common Mode to 0.9V and Output Common Mode for Headphone to Input Common Mode
    513          //		  20,0X00,  //headphone driver startup
    514          
    515          		  //set route settings
    516          		  //CODEC LO to FM23 LIN, single ended
    517          ////		  12,0X00, //HPL route off
    518          ////	      13,0X00, //HPR route off
    519          ////	      14,0X08, //LOL route: DAC L 
    520          ////	      15,0X00, //LOR route off
    521          ////
    522          ////	      12,0X08, //HPL route off
    523          ////	      13,0X08, //HPR route off
    524          ////	      14,0X08, //LOL route: DAC L 
    525          ////	      15,0X08, //LOR route off
    526          	      
    527          //          //set DAC output gains
    528          //	      16,0X00,  //HPL 0db gain
    529          //	      17,0X00,  //HPR 0db gain
    530          //	      //18,0X00,  //LOL 0db gain
    531          //	      //19,0X00,  //LOR 0db gain  
    532          //	      18,0X3A,  //LOL -6db gain
    533          //	      19,0X3A,  //LOR -6db gain   
    534                    
    535          		 //set ADC routine
    536          	      52,0X04, //IN3L to L_MICPGA_Positive
    537          	      54,0X40, //CM1L to L_MICPGA_Negative
    538          	      55,0X04, //IN3R to R_MICPGA_Positive
    539          	      57,0X40, //CM1R to R_MICPGA_Negative         
    540          
    541          	      		       
    542          	      //set ADC input gains
    543          	      59,0X00,  //L PGA 0db gain
    544          	      60,0X00   //R PGA 0db gain	    
    545          };
    546          
    547          unsigned char Init_CODEC_AIC3204( unsigned int sample_rate ) 
    548          {
    549              unsigned char i ;
    550              unsigned char err;
    551              
    552              for (i = 0 ; i< sizeof(config_aic3204)>>1 ; i++ ) {    
    553                  err = I2CWrite_Codec_AIC3204(config_aic3204[i][0],config_aic3204[i][1]);
    554                  if(err != 0 ) {
    555                      break;
    556                  }
    557              }
    558              return err;    
    559              
    560          }
    561          
    562          unsigned char Set_AIC3204_DSP_Offset( unsigned char slot_index ) 
    563          {
    564              
    565              unsigned char err;
    566              
    567              if( slot_index >6 ) { //slot_index is for line in channels
    568                  return 0x99;
    569              }      
    570              err = I2CWrite_Codec_AIC3204( 28, slot_index << 5);
    571              
    572              return err;    
    573              
    574          }
    575          */
    576          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ALL_POWER_OFF
         8   -> I2CWrite_Codec
       8   ALL_POWER_ON
         8   -> I2CWrite_Codec
      16   CODEC_LOUT_Small_Gain_En
        16   -> BSP_Ser_Printf
        16   -> I2CWrite_Codec
      24   CODEC_Set_Volume
        24   -> Codec_DAC_Attenuation
        24   -> I2CWrite_Codec
      24   Codec_DAC_Attenuation
        24   -> BSP_Ser_Printf
        24   -> I2CWrite_Codec
        24   -> __aeabi_d2f
        24   -> __aeabi_ddiv
        24   -> __aeabi_f2iz
        24   -> __aeabi_ui2d
      24   Codec_Mixer
        24   -> TWID_Write
      32   Codec_Read
        32   -> TWID_Read
       0   Codec_Read_SPI
      16   Codec_SetFCLK
        16   -> I2CWrite_Codec
      32   Codec_SetMode
        32   -> I2CWrite_Codec
      32   Codec_Write
        32   -> TWID_Write
      24   Codec_Write_SPI
        24   -> SPI_WriteBuffer_API
      24   Get_Codec
        24   -> Codec_Read
        24   -> Codec_Read_SPI
      16   I2CWrite_Codec
        16   -> Codec_Write
      16   I2CWrite_Codec_AIC3204
        16   -> Codec_Write
      40   Init_CODEC
        40   -> CODEC_LOUT_Small_Gain_En
        40   -> Codec_SetFCLK
        40   -> Codec_SetMode
        40   -> Get_Switches
        40   -> I2CWrite_Codec
        40   -> __aeabi_memcpy4
      24   Set_Codec
        24   -> Codec_Write
        24   -> Codec_Write_SPI


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant "ERR: CODEC Gain Over ...">
      40  ?<Constant "Lout Gain 24dB attenu...">
      40  ?<Constant "Lout Gain 24dB attenu...">_1
      20  ?<Constant {{0, 152}, {1, 0}, {4, 24}, {5, 240
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
      36  ALL_POWER_OFF
      36  ALL_POWER_ON
     188  CODEC_LOUT_Small_Gain_En
     256  CODEC_Set_Volume
     184  Codec_DAC_Attenuation
     100  Codec_Mixer
      92  Codec_Read
      16  Codec_Read_SPI
     300  Codec_SetFCLK
     400  Codec_SetMode
      84  Codec_Write
      64  Codec_Write_SPI
     104  Get_Codec
      56  I2CWrite_Codec
      56  I2CWrite_Codec_AIC3204
     320  Init_CODEC
     200  Set_Codec
       4  sr_saved

 
     4 bytes in section .bss
   132 bytes in section .rodata
 2 512 bytes in section .text
 
 2 512 bytes of CODE  memory
   132 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
