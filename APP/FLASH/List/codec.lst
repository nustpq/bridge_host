###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        16/Dec/2014  22:25:25
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\codec.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\codec.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\codec.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\codec.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\codec.c
      1          #include <bsp.h>
      2          #include <pio.h>
      3          #include <async.h>
      4          #include <twid.h>
      5          #include "codec.h"
      6          
      7          
      8          
      9          unsigned char Codec_Read(unsigned char dev_addr,unsigned char reg,unsigned char *pVal)
     10          {
     11              unsigned char state = 0;   
     12              state =  TWID_Read( dev_addr>>1, reg, 1, pVal++,1, NULL) ;
     13              return(state);
     14          }
     15          
     16          
     17          unsigned char Codec_Write(unsigned char dev_addr,unsigned char reg,unsigned char data)
     18          {      
     19              unsigned char buf[] = {  data };     
     20              unsigned char state;
     21                
     22              state =  TWID_Write( dev_addr>>1, reg, 1 , buf, sizeof(buf), NULL);     
     23              
     24              return state ;
     25          }
     26          
     27          
     28          unsigned char Codec_Read_SPI(unsigned char dev_addr,unsigned char reg,unsigned char *pVal)
     29          {
     30              unsigned char state = 0;   
     31              //state =  TWID_Read( dev_addr>>1, reg, 1, pVal++,1, NULL) ;
     32              return(state);
     33          }
     34          
     35          
     36          unsigned char Codec_Write_SPI(unsigned char dev_addr,unsigned char reg,unsigned char data)
     37          {      
     38              unsigned char buf[] = { dev_addr<<1, reg, data };     
     39              unsigned char state;    
     40              
     41              state = SPI_WriteBuffer_API( buf, 3);     
     42            
     43              
     44              return state ;
     45              
     46          }
     47          
     48          
     49          //i2c_channel = 0 ~ 7
     50          unsigned char Codec_Mixer(unsigned char i2c_channel )
     51          {    
     52               unsigned char buf   ;
     53               unsigned char state ;
     54               
     55               state = 0xe0 ; 
     56               
     57               if( i2c_channel <= 3 )  {//PCA9548A,
     58                  buf   = 0x01<<i2c_channel ; //select i2c_channel
     59                  state = TWID_Write( PCA9548A_ADDRESS>>1, 0, 0, &buf, 1, NULL); 
     60               /*
     61                  buf   = 0 ;
     62                  state = TWID_Write( PCA9540B_ADDRESS>>1, 0, 0, &buf, 1, NULL); 
     63                
     64               } else {  // PCA9540B
     65                  buf   = 4 ; //select CH0
     66                  state = TWID_Write( PCA9540B_ADDRESS>>1, 0, 0, &buf, 1, NULL); 
     67                  buf   = 0 ;
     68                  state = TWID_Write( PCA9548A_ADDRESS>>1, 0, 0, &buf, 1, NULL); 
     69               */
     70               }
     71               
     72               return state ;
     73          }
     74          
     75          
     76          
     77          
     78          
     79          
     80          unsigned char Set_Codec(unsigned char codec_control_type, unsigned char size_para, unsigned char *pdata)
     81          {
     82              unsigned char i, state = 0 ;
     83              for(i = 0; i< size_para ; i++)
     84              {
     85                if(codec_control_type == 0 ) {
     86                  state = Codec_Write(CODEC_ADDRESS,*(pdata+i*2),*(pdata+i*2+1));
     87                } else {
     88                  state = Codec_Write_SPI(AD1938_ADDRESS,*(pdata+i*2),*(pdata+i*2+1));
     89                }
     90                  if( state != 0 ) break;
     91              }
     92              return state;
     93            
     94          }
     95          
     96          
     97          unsigned char Get_Codec(unsigned char codec_control_type, unsigned char reg, unsigned char *pdata)
     98          {
     99              unsigned char state = 0 ;
    100              
    101              if(codec_control_type == 0 ) {
    102                  state = Codec_Read( CODEC_ADDRESS, reg, pdata) ;
    103              } else {
    104                  state = Codec_Read_SPI( CODEC_ADDRESS, reg, pdata) ;
    105              }
    106              
    107              return state;
    108            
    109          }
    110          
    111          
    112          /*********************************************************************************************************************************/
    113          // OSC=12.288Mhz
    114          
    115          unsigned char I2CWrite_Codec( unsigned char reg,unsigned char data )
    116          {
    117              unsigned char err;
    118              err = Codec_Write( AD1937_ADDRESS, reg, data);
    119              return err;
    120          }
    121          
    122          unsigned char I2CWrite_Codec_AIC3204( unsigned char reg,unsigned char data )
    123          {
    124              unsigned char err;
    125              err = Codec_Write( CODEC_ADDRESS, reg, data);
    126              return err;
    127          }
    128          
    129          void ALL_POWER_ON(void)
    130          {
    131              I2CWrite_Codec(DAC_Control0,0x00);  //
    132              I2CWrite_Codec(ADC_Control0,0x00);  //
    133          }
    134          
    135          
    136          void ALL_POWER_OFF(void)
    137          {
    138              I2CWrite_Codec(DAC_Control0,0x01);  //
    139              I2CWrite_Codec(ADC_Control0,0x01);  //
    140          }
    141          
    142          
    143          unsigned char Codec_DAC_Attenuation( unsigned char DAC_NAME, unsigned int x10gain )
    144          {
    145              
    146              unsigned char err;
    147              float temp ;
    148              
    149              if( x10gain == 1000 ){        
    150                  return 0 ;
    151              }
    152              if (x10gain > 945) {//0.375*252=94.5dB         
    153                  err = CODEC_SETVOL_RANGE_ERR;
    154                  APP_TRACE_INFO(("ERR: CODEC Gain Over Range!\r\n"));        
    155                  return err;
    156              }
    157              temp = x10gain/(0.375*10); 
    158              err = I2CWrite_Codec(DAC_NAME,(unsigned char)temp);
    159              if( OS_ERR_NONE != err ) {
    160                  err = CODEC_WR_REG_ERR;
    161                  return err ;
    162              }
    163              APP_TRACE_DBG(("\r\nSet CODEC REG[%d]=0x%0X",DAC_NAME,(unsigned char)temp)); 
    164              
    165              return 0;
    166          
    167          }
    168          
    169          //unsigned char Codec_DAC_Attenuation( unsigned char DAC_NAME, float gain )
    170          //{
    171          //    
    172          //    unsigned char err;
    173          //    float temp ;
    174          //      
    175          //    if ( gain > 0 ) {         
    176          //        err = 1;
    177          //        return err;
    178          //    }
    179          //    
    180          //    if(gain< -95.25 ) {
    181          //        temp = 255 ;
    182          //        
    183          //    } else {
    184          //        temp = -gain/0.375; 
    185          //        
    186          //    }
    187          //    
    188          //    err = I2CWrite_Codec(DAC_NAME,(unsigned char)temp);
    189          //    
    190          //    return err;
    191          //    
    192          //}
    193          
    194          unsigned short SR_Support[] =         {
    195                                                      //8000,
    196                                                      16000,
    197                                                      24000,
    198                                                      32000,
    199                                                      //44100,
    200                                                      48000
    201                                                      //96000
    202                                                };
    203          
    204          unsigned char Check_SR_Support( unsigned int sample_rate )
    205          {    
    206             unsigned int i;
    207             for( i = 0; i<(sizeof(SR_Support)/2); i++ ) {
    208                 if( SR_Support[i] == sample_rate ) {
    209                     return OS_ERR_NONE ; //find the SR
    210                 }
    211             }   
    212             return CODEC_SR_NOT_SUPPORT_ERR;  //SR not support
    213              
    214          }
    215          
    216          // Main clock source = 12.288 MHz.   
    217          unsigned char Codec_SetFCLK( unsigned int fclk )
    218          {
    219              
    220              unsigned char err;
    221              unsigned char pll_reg;
    222              
    223              switch( fclk )   {
    224                
    225                  case 8000:  // Need  12.288 / 2 MHz Osc 
    226                      pll_reg = 0x9e;      
    227                      return CODEC_SETFCLK_RANGE_ERR;
    228                      break;            
    229                  case 16000:            
    230                      pll_reg = 0x9e;            
    231                      break;
    232                  case 24000:      
    233                      pll_reg = 0x9c;            
    234                      break;
    235                  case 32000:            
    236                      pll_reg = 0x9a;      
    237                      break;
    238                  case 44100: // Need 11.2896 MHz Osc 
    239                      pll_reg = 0x98;  
    240                      return CODEC_SETFCLK_RANGE_ERR;
    241                      break;
    242                  case 48000:             
    243                      pll_reg = 0x98;            
    244                      break;
    245                  case 96000: // Need 12.288 * 2 MHz Osc       
    246                      pll_reg = 0x98;             
    247                      return CODEC_SETFCLK_RANGE_ERR;
    248                      break;
    249                  case 0 : //power down clock
    250                      pll_reg = 0x01; 
    251                      break;
    252                  default:
    253                      return CODEC_SETFCLK_RANGE_ERR;
    254                      break;
    255                      
    256              }
    257              
    258              err = I2CWrite_Codec( PLL_Control0, pll_reg );
    259              if( OS_ERR_NONE != err ) {
    260                  err = CODEC_WR_REG_ERR;
    261                  return err ;
    262              }
    263          
    264              return err;
    265              
    266          }
    267          
    268          
    269          unsigned char Codec_SetMode( unsigned char mode )
    270          {
    271              unsigned char err;
    272              unsigned char dac_reg0,dac_reg1;
    273              unsigned char adc_reg1,adc_reg2;
    274              
    275              switch( mode )  {
    276              
    277                  case I2S_MODE:
    278                           dac_reg0 = 0x00;      //I2S
    279                           dac_reg1 = 0x70;      //2 channels
    280                           adc_reg1 = 0x03;      //I2S
    281                           adc_reg2 = 0x01;      //2 channels
    282                           break;
    283                  case TDM_MODE:
    284                           dac_reg0 = 0x40;      //TDM
    285                           dac_reg1 = 0x74;      // 8 channels
    286                           adc_reg1 = 0x23;      //TDM
    287                           adc_reg2 = 0x21;      // 8 channels
    288                           break;
    289                  case TDM16_MODE:
    290                           dac_reg0 = 0x40;      //TDM
    291                           dac_reg1 = 0x76;      // 16 channels
    292                           adc_reg1 = 0x23;      //TDM
    293                           adc_reg2 = 0x31;      // 16 channels
    294                           break;
    295                  default:
    296                          return CODEC_SETMODE_RANGE_ERR;
    297                          break;
    298              } 
    299              
    300              err = I2CWrite_Codec( DAC_Control0, dac_reg0 );
    301              if( OS_ERR_NONE != err ) {
    302                  err = CODEC_WR_REG_ERR;
    303                  return err ;
    304              }    
    305              err = I2CWrite_Codec( DAC_Control1, dac_reg1 );
    306              if( OS_ERR_NONE != err ) {
    307                  err = CODEC_WR_REG_ERR;
    308                  return err ;
    309              }
    310              
    311              err = I2CWrite_Codec( ADC_Control1, adc_reg1 );
    312              if( OS_ERR_NONE != err ) {
    313                  err = CODEC_WR_REG_ERR;
    314                  return err ;
    315              }    
    316              err = I2CWrite_Codec( ADC_Control2, adc_reg2 );
    317              if( OS_ERR_NONE != err ) {
    318                  err = CODEC_WR_REG_ERR;
    319                  return err ;
    320              }
    321          
    322              return err;    
    323            
    324          }
    325          
    326          /*******************************************/
    327          
    328          unsigned char Init_CODEC( unsigned int sample_rate )   
    329          { 
    330              unsigned char err;
    331              unsigned char i;
    332              static unsigned int sr_saved; 
    333              
    334              unsigned char reg_para[][2] = {
    335                  
    336                  { PLL_Control0,0x98 },
    337                  { PLL_Control1,0x00 },  //
    338                  { DAC_Control2,0x18 },  // 16bit    
    339                  { DAC_Mute    ,0xF0 },  // DAC3.4 mute.
    340                  { DAC1L_Volume,0x00 },  // no attenuation on SPK
    341                  { DAC1R_Volume,0x00 },  // no attenuation on SPK
    342                  { DAC2L_Volume,0x00 },  // no attenuation on Lout
    343                  { DAC2R_Volume,0x00 },  // no attenuation on Lout
    344                  { ADC_Control0,0x30 }  //Enable ADC
    345           //    { DAC3L_Volume,0x00 },  // not used on AB03
    346           //    { DAC3R_Volume,0x00 },  // not used on AB03 
    347                  
    348              };
    349              
    350              if( sample_rate == sr_saved ) {
    351                  return 0;
    352              } else {
    353                  sr_saved = sample_rate ;
    354              }
    355          
    356              for( i = 0; i< sizeof(reg_para)>>1; i++ ) {
    357                err = I2CWrite_Codec(reg_para[i][0], reg_para[i][1]); 
    358                if( OS_ERR_NONE != err ) {
    359                    err = CODEC_WR_REG_ERR;
    360                    return err ;
    361                }
    362                
    363              }
    364              
    365              err = Codec_SetFCLK( sample_rate );
    366              if( OS_ERR_NONE != err ) {
    367                  err = CODEC_WR_REG_ERR;
    368                  return err ;
    369              }    
    370          
    371              err = Codec_SetMode( TDM_MODE );   
    372              if( OS_ERR_NONE != err ) {
    373                  err = CODEC_WR_REG_ERR;
    374                  return err ;
    375              }     
    376          
    377              if( !( Get_Switches() & 0x01 ) ) {
    378                  err = CODEC_LOUT_Small_Gain_En( true ); //attenuation enable
    379              }
    380              
    381              return err;
    382              
    383          }
    384          
    385          
    386          
    387          
    388          
    389          unsigned char CODEC_LOUT_Small_Gain_En( bool small_gain )
    390          {
    391              unsigned char err;
    392              unsigned char reg;
    393              if( small_gain ) {        
    394                  reg = 64;    // 64*0.375=24dB attenuation on Lout     
    395                  APP_TRACE_INFO(("Lout Gain 24dB attenuation: Enabled \r\n"));  
    396                  
    397              } else {        
    398                  reg = 0;    // 0dB attenuation on Lout        
    399                  APP_TRACE_INFO(("Lout Gain 24dB attenuation: Disabled \r\n"));  
    400                  
    401              }    
    402              err = I2CWrite_Codec( DAC2L_Volume, reg );
    403              if( OS_ERR_NONE != err ) {
    404                  err = CODEC_WR_REG_ERR;
    405                  return err ;
    406              }    
    407              
    408              err = I2CWrite_Codec( DAC2R_Volume, reg );
    409              if( OS_ERR_NONE != err ) {
    410                  err = CODEC_WR_REG_ERR;
    411                  return err ;
    412              }
    413          
    414              return err;    
    415              
    416          }
    417          
    418          
    419          unsigned char CODEC_Set_Volume( unsigned int vol_spk, unsigned int vol_lin )
    420          {
    421             
    422              unsigned char err;
    423              unsigned char temp;
    424              
    425              temp = 0xF0;
    426              err = Codec_DAC_Attenuation(DAC1L_Volume, vol_spk );    
    427              if( OS_ERR_NONE != err ){
    428                  return err;
    429              }
    430              err = Codec_DAC_Attenuation(DAC1R_Volume, vol_spk );
    431              if( OS_ERR_NONE != err ){
    432                  return err;
    433              }
    434              
    435              err = Codec_DAC_Attenuation(DAC2L_Volume, vol_lin );
    436              if( OS_ERR_NONE != err ){
    437                  return err;
    438              }   
    439              err = Codec_DAC_Attenuation(DAC2R_Volume, vol_lin );
    440              if( OS_ERR_NONE != err ){
    441                  return err;
    442              }
    443               
    444              if( vol_spk == SET_VOLUME_MUTE ) {
    445                  temp += (3<<0);
    446              }
    447              if( vol_lin == SET_VOLUME_MUTE ) {
    448                  temp += (3<<2);
    449              }
    450              err = I2CWrite_Codec(DAC_Mute,temp);
    451              
    452              return err;
    453              
    454          }
    455          
    456          
    457          
    458          
    459          
    460          
    461          
    462          
    463          
    464          
    465          
    466          
    467          
    468          
    469          
    470          
    471          
    472          
    473          /*
    474          unsigned char config_aic3204[][2] = {
    475              
    476              
    477          	      0,0x00, //page0---------------------	      
    478          	      //software reset	
    479          	      1,0X01, 
    480          	      
    481          	      //PLL not used here
    482          	      4,0x01,	 //BCLK as main clock       
    483          	      11,0x84,  //NDAC=4    
    484          	      12,0x82,  //MDAC=2	      
    485          	      13,0x00,   
    486          	      14,32,    //DOSR=32
    487          	      
    488          	      18,0x84,  //NADC=4               
    489          	      19,0x82,  //MADC=2		      
    490          	      20,32,   //AOSR=32		    
    491          	      //30,0X82,  //bclk=bdiv_clkin/4
    492          
    493          	      //set route settings
    494          	      //29,0X11,    // Inner ADC is routed to DAC	
    495          	      //29,0X21,    // I2S input is routed to I2S output	
    496          	      //29,0X1,     // No innner rounte      
    497          
    498          	      //set digital interface, On S-II board CODEC set as master 
    499          	      27,0x71,   	//DSP mode,32bit,Slave,HZ after data transmit done	  
    500          	      28,96,   	//data offset 6*32 = 6<<5 = 192, defalut put line in channels on slot 6, 7 
    501          //	      32,0X00, 
    502          //	      33,0X4d, 
    503          	      34,0x20, 
    504          //	      53,0X02,  	//Dout is pin5
    505          //	      54,0X02,  	//pin4 is i2s data input  
    506          	         
    507          //		  //set channels
    508          //	      63,0Xd4, //DAC Channel Setup 
    509          //	      64,0X00, //DAC Channel Setup	 
    510          //	      65,0X00, //DAC Volume L set 0dB
    511          //	      66,0X00, //DAC Volume R set 0dB
    512          	     
    513          //	      //set dmic data pin setting
    514          //	      55,0X0e,   // Set MISO as PDM CLK ouput pin
    515          //	      56,0X02,   // SCLK pin is enabled	
    516                    
    517                    //set ADC channel
    518          	      81, 0xF0,//81, 0xDC , //????????adc_input_para,   // enable ADC and set SCLK as PDM DATA input pin-------	    
    519          	      //Dmic clock output(=adc_mod_clk), PDM CLK = ADC_MOD_CLK	        
    520          	      82,0X00,   //ADC Fine gain adjust, 0dB, unmute
    521          	      83,0X00,   //ADC Volume L set 0dB
    522          	      84,0X00,   //ADC Volume R set 0dB
    523          
    524          	      0,0X01,  //page1--------------------------
    525          	          
    526          	      //set power
    527          	      1,0x08,  //disconnect AVDD and DVDD		 
    528          	      2,0X01,  //enable Master Analog Power Control		
    529          //	      3,0X00,  //Set the DAC L PTM mode to PTM_P3/4
    530          //	      4,0X00,  //Set the DAC R PTM mode to PTM_P3/4		      
    531          //	      9, 0XFF,  //All HPOUT,LOUT and Mixer Amplifier are Power up  
    532          //	      9, 0x3c,
    533          	      10,0X00,  //Set the Input Common Mode to 0.9V and Output Common Mode for Headphone to Input Common Mode
    534          //		  20,0X00,  //headphone driver startup
    535          
    536          		  //set route settings
    537          		  //CODEC LO to FM23 LIN, single ended
    538          ////		  12,0X00, //HPL route off
    539          ////	      13,0X00, //HPR route off
    540          ////	      14,0X08, //LOL route: DAC L 
    541          ////	      15,0X00, //LOR route off
    542          ////
    543          ////	      12,0X08, //HPL route off
    544          ////	      13,0X08, //HPR route off
    545          ////	      14,0X08, //LOL route: DAC L 
    546          ////	      15,0X08, //LOR route off
    547          	      
    548          //          //set DAC output gains
    549          //	      16,0X00,  //HPL 0db gain
    550          //	      17,0X00,  //HPR 0db gain
    551          //	      //18,0X00,  //LOL 0db gain
    552          //	      //19,0X00,  //LOR 0db gain  
    553          //	      18,0X3A,  //LOL -6db gain
    554          //	      19,0X3A,  //LOR -6db gain   
    555                    
    556          		 //set ADC routine
    557          	      52,0X04, //IN3L to L_MICPGA_Positive
    558          	      54,0X40, //CM1L to L_MICPGA_Negative
    559          	      55,0X04, //IN3R to R_MICPGA_Positive
    560          	      57,0X40, //CM1R to R_MICPGA_Negative         
    561          
    562          	      		       
    563          	      //set ADC input gains
    564          	      59,0X00,  //L PGA 0db gain
    565          	      60,0X00   //R PGA 0db gain	    
    566          };
    567          
    568          unsigned char Init_CODEC_AIC3204( unsigned int sample_rate ) 
    569          {
    570              unsigned char i ;
    571              unsigned char err;
    572              
    573              for (i = 0 ; i< sizeof(config_aic3204)>>1 ; i++ ) {    
    574                  err = I2CWrite_Codec_AIC3204(config_aic3204[i][0],config_aic3204[i][1]);
    575                  if(err != 0 ) {
    576                      break;
    577                  }
    578              }
    579              return err;    
    580              
    581          }
    582          
    583          unsigned char Set_AIC3204_DSP_Offset( unsigned char slot_index ) 
    584          {
    585              
    586              unsigned char err;
    587              
    588              if( slot_index >6 ) { //slot_index is for line in channels
    589                  return 0x99;
    590              }      
    591              err = I2CWrite_Codec_AIC3204( 28, slot_index << 5);
    592              
    593              return err;    
    594              
    595          }
    596          */
    597          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ALL_POWER_OFF
         8   -> I2CWrite_Codec
       8   ALL_POWER_ON
         8   -> I2CWrite_Codec
      16   CODEC_LOUT_Small_Gain_En
        16   -> BSP_Ser_Printf
        16   -> I2CWrite_Codec
      24   CODEC_Set_Volume
        24   -> Codec_DAC_Attenuation
        24   -> I2CWrite_Codec
       0   Check_SR_Support
      24   Codec_DAC_Attenuation
        24   -> BSP_Ser_Printf
        24   -> I2CWrite_Codec
        24   -> __aeabi_d2f
        24   -> __aeabi_ddiv
        24   -> __aeabi_f2iz
        24   -> __aeabi_ui2d
      24   Codec_Mixer
        24   -> TWID_Write
      32   Codec_Read
        32   -> TWID_Read
       0   Codec_Read_SPI
      16   Codec_SetFCLK
        16   -> I2CWrite_Codec
      32   Codec_SetMode
        32   -> I2CWrite_Codec
      32   Codec_Write
        32   -> TWID_Write
      24   Codec_Write_SPI
        24   -> SPI_WriteBuffer_API
      24   Get_Codec
        24   -> Codec_Read
        24   -> Codec_Read_SPI
      16   I2CWrite_Codec
        16   -> Codec_Write
      16   I2CWrite_Codec_AIC3204
        16   -> Codec_Write
      40   Init_CODEC
        40   -> CODEC_LOUT_Small_Gain_En
        40   -> Codec_SetFCLK
        40   -> Codec_SetMode
        40   -> Get_Switches
        40   -> I2CWrite_Codec
        40   -> __aeabi_memcpy4
      24   Set_Codec
        24   -> Codec_Write
        24   -> Codec_Write_SPI


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant "ERR: CODEC Gain Over ...">
      40  ?<Constant "Lout Gain 24dB attenu...">
      40  ?<Constant "Lout Gain 24dB attenu...">_1
      20  ?<Constant {{0, 152}, {1, 0}, {4, 24}, {5, 240
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
      36  ALL_POWER_OFF
      36  ALL_POWER_ON
     188  CODEC_LOUT_Small_Gain_En
     256  CODEC_Set_Volume
      64  Check_SR_Support
     184  Codec_DAC_Attenuation
     100  Codec_Mixer
      92  Codec_Read
      16  Codec_Read_SPI
     300  Codec_SetFCLK
     400  Codec_SetMode
      84  Codec_Write
      64  Codec_Write_SPI
     104  Get_Codec
      56  I2CWrite_Codec
      56  I2CWrite_Codec_AIC3204
     320  Init_CODEC
       8  SR_Support
     200  Set_Codec
       4  sr_saved

 
     4 bytes in section .bss
     8 bytes in section .data
   132 bytes in section .rodata
 2 580 bytes in section .text
 
 2 580 bytes of CODE  memory
   132 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: none
