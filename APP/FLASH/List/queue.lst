###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Aug/2014  09:37:02
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\queue.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\queue.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\queue.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\queue.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\queue.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     MICIRUM BOARD SUPPORT PACKAGE
      4          *
      5          *                            (c) Copyright 2006-2008; Micrium, Inc.; Weston, FL
      6          *
      7          *                   All rights reserved.  Protected by international copyright laws.
      8          *                   Knowledge of the source code may not be used to write a similar
      9          *                   product.  This file may only be used in accordance with a license
     10          *                   and should not be redistributed in any way.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                         UART data buffering queue related
     18          *
     19          *                                          Atmel AT91SAM7A3
     20          *                                                on the
     21          *                                     iSAM Audio Bridge Board
     22          *
     23          * Filename      : queue.c
     24          * Version       : V1.0.0
     25          * Programmer(s) : PQ
     26          *********************************************************************************************************
     27          * Note(s)       :
     28          *********************************************************************************************************
     29          */
     30          
     31          #include <includes.h>
     32          
     33          
     34          
     35          /*********************************************************************************************************
     36          ** 函数名称: Queue_Create
     37          ** 功能描述: 初始化数据队列
     38          ** 输  　入: Buf      ：为队列分配的存储空间地址
     39          **           SizeOfBuf：为队列分配的存储空间大小（字节）
     40          **           ReadEmpty：为队列读空时处理程序
     41          **           WriteFull：为队列写满时处理程序
     42          ** 输  　出: QUEUE_FAIL:参数错误
     43          **           QUEUE_OK:成功
     44          ** 全局变量: 无
     45          ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
     46          **
     47          **------------------------------------------------------------------------------------------------------
     48          ********************************************************************************************************/
     49          CPU_INT08U Queue_Create(void *Buf,  CPU_INT32U SizeOfBuf )
     50          {
     51              DataQueue *Queue;
     52              
     53          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
     54              OS_CPU_SR  cpu_sr = 0u;
     55          #endif
     56              
     57              if (Buf != NULL && SizeOfBuf >= (sizeof(DataQueue))) {       /* 判断参数是否有效 */
     58              
     59                  Queue = (DataQueue *)Buf;
     60          
     61                  OS_ENTER_CRITICAL();
     62                                                                          /* 初始化结构体数据 */
     63                  Queue->MaxData = (SizeOfBuf - (CPU_INT32U)(((DataQueue *)0)->Buf)) / 
     64                                   sizeof(QUEUE_DATA_TYPE);               /* 计算队列可以存储的数据数目 */
     65                  Queue->End = Queue->Buf + Queue->MaxData;               /* 计算数据缓冲的结束地址 */
     66                  Queue->Out = Queue->Buf;
     67                  Queue->In = Queue->Buf;
     68                  Queue->NData = 0;
     69                  
     70                  OS_EXIT_CRITICAL();
     71          
     72                  return QUEUE_OK;
     73                  
     74              } else {
     75                  return QUEUE_FAIL;
     76              }
     77          }
     78          
     79          
     80          /*********************************************************************************************************
     81          ** 函数名称: QueueRead
     82          ** 功能描述: 获取队列中的数据
     83          ** 输  　入: Ret:存储返回的消息的地址
     84          **           Buf:指向队列的指针
     85          ** 输  　出: QUEUE_FAIL     ：参数错误
     86          **           QUEUE_OK   ：收到消息
     87          **           QUEUE_EMPTY：无消息
     88          ** 全局变量: 无
     89          ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
     90          **
     91          **------------------------------------------------------------------------------------------------------
     92          ********************************************************************************************************/
     93          CPU_INT08U Queue_Read(QUEUE_DATA_TYPE *Ret, void *Buf)
     94          {
     95              CPU_INT08U err;
     96              DataQueue *Queue;
     97              
     98          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
     99              OS_CPU_SR  cpu_sr = 0u;
    100          #endif
    101              
    102              err = QUEUE_FAIL;
    103              
    104              if (Buf != NULL) {                                         /* 队列是否有效 */
    105                                                                       /* 有效 */
    106                  Queue = (DataQueue *)Buf;
    107                  
    108                  OS_ENTER_CRITICAL();
    109                  
    110                  if (Queue->NData > 0){                                   /* 队列是否为空 */
    111                                                                           /* 不空         */
    112                      *Ret = Queue->Out[0];                               /* 数据出队     */
    113                      Queue->Out++;                                       /* 调整出队指针 */
    114                      if (Queue->Out >= Queue->End) {            
    115                          Queue->Out = Queue->Buf;
    116                      }
    117                      Queue->NData--;                                     /* 数据减少      */
    118                      err = QUEUE_OK;
    119                      
    120                  } else {                                               /* 空              */          
    121                      err = QUEUE_EMPTY;        
    122                  }
    123                  OS_EXIT_CRITICAL();
    124              }
    125              return err;
    126          }
    127          
    128          /*******************************************************************************/
    129          CPU_INT08U Queue_ReadBuf( QUEUE_DATA_TYPE *Ret, void *Buf, CPU_INT16U bytes_copy, CPU_INT16U *bytes_copied)
    130          {
    131              CPU_INT08U err;
    132              DataQueue *Queue;
    133              
    134          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
    135              OS_CPU_SR  cpu_sr = 0u;
    136          #endif
    137              
    138              err = QUEUE_FAIL;
    139              
    140              if (Buf == NULL)  {                                         
    141                   return err;
    142              }
    143              
    144              Queue = (DataQueue *)Buf; 
    145              
    146              OS_ENTER_CRITICAL();
    147                  
    148              if (Queue->NData >= bytes_copy ) {                        
    149                      *bytes_copied = bytes_copy ; 
    150                      while( bytes_copy-- > 0 ){      
    151                          *Ret++ = *(Queue->Out)++;          
    152                          if (Queue->Out >= Queue->End)  {   //>= ??? Queue->End never used ?
    153                              Queue->Out = Queue->Buf;
    154                          }
    155                          Queue->NData--;
    156                      }         
    157                      err = QUEUE_OK;
    158                  
    159              } else if (Queue->NData > 0) {                               
    160                      *bytes_copied = Queue->NData ; 
    161                      while( Queue->NData > 0 ) { 
    162                          *Ret++ = *(Queue->Out)++;  
    163                          Queue->NData--;
    164                          if (Queue->Out >= Queue->End) {
    165                              Queue->Out = Queue->Buf;
    166                          }            
    167                      }
    168                      err = QUEUE_OK;
    169                  
    170              } else  {                                                      
    171                      *bytes_copied = 0;
    172                      err = QUEUE_EMPTY;      
    173              }
    174              
    175              OS_EXIT_CRITICAL();
    176             
    177              return err;
    178          }
    179          /*********************************************************************************************************
    180          ** 函数名称: QueueReadOnly
    181          ** 功能描述: 获取队列中的数据,但不改变原数据队列
    182          ** 输  　入: Ret:存储返回的消息的地址
    183          **           Buf:指向队列的指针
    184          ** 输  　出: QUEUE_FAIL     ：参数错误
    185          **           QUEUE_OK   ：收到消息
    186          **           QUEUE_EMPTY：无消息
    187          ** 全局变量: 无
    188          ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
    189          **
    190          **------------------------------------------------------------------------------------------------------
    191          ********************************************************************************************************/
    192          CPU_INT08U Queue_ReadOnly(QUEUE_DATA_TYPE *Ret, void *Buf)
    193          {
    194              CPU_INT08U err;
    195              DataQueue *Queue;
    196              
    197          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
    198              OS_CPU_SR  cpu_sr = 0u;
    199          #endif
    200              
    201              err = QUEUE_FAIL;
    202              if (Buf != NULL) {                                         /* 队列是否有效 */
    203                                                                         /* 有效 */
    204                  Queue = (DataQueue *)Buf;
    205                  
    206                  OS_ENTER_CRITICAL();
    207                  
    208                  if (Queue->NData > 0) {                                  /* 队列是否为空 */
    209                                                                          /* 不空         */
    210                      *Ret = Queue->Out[0];                               /* 数据出队     */
    211                      err = QUEUE_OK;
    212                      
    213                  }  else  {                                                  
    214                    
    215                      err = QUEUE_EMPTY;
    216                  }
    217                  
    218                  OS_EXIT_CRITICAL();
    219              }
    220              return err;
    221          }
    222          
    223          /*********************************************************************************************************
    224          ** 函数名称: Queue_Write
    225          ** 功能描述: FIFO方式发送数据
    226          ** 输  　入: Buf :指向队列的指针
    227          **           Data:消息数据
    228          ** 输  　出: QUEUE_FAIL   :参数错误
    229          **           QUEUE_FULL:队列满
    230          **           QUEUE_OK  :发送成功
    231          ** 全局变量: 无
    232          ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
    233          **
    234          **------------------------------------------------------------------------------------------------------
    235          ********************************************************************************************************/
    236          #ifndef EN_QUEUE_WRITE
    237          #define EN_QUEUE_WRITE      0
    238          #endif
    239          
    240          #if EN_QUEUE_WRITE > 0
    241          
    242          CPU_INT08U Queue_Write(void *Buf, QUEUE_DATA_TYPE Data)
    243          {
    244              CPU_INT08U err;
    245              DataQueue *Queue;
    246              
    247          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
    248              OS_CPU_SR  cpu_sr = 0u;
    249          #endif
    250              
    251              err = QUEUE_FAIL;
    252              if (Buf != NULL) {                                                    /* 队列是否有效 */
    253              
    254                  Queue = (DataQueue *)Buf;
    255                  
    256                  OS_ENTER_CRITICAL();
    257                  
    258                  if (Queue->NData < Queue->MaxData) {                           /* 队列是否满  */
    259                                                                                /* 不满        */
    260                      Queue->In[0] = Data;                                        /* 数据入队    */
    261                      Queue->In++;                                                /* 调整入队指针*/
    262                      if (Queue->In >= Queue->End) {     
    263                          Queue->In = Queue->Buf;
    264                      }
    265                      Queue->NData++;                                             /* 数据增加    */
    266                      err = QUEUE_OK;
    267                      
    268                  } else {      
    269                                                                                  /* 满           */
    270                      err = QUEUE_FULL;       
    271                  }
    272                  OS_EXIT_CRITICAL();
    273              }
    274              return err;
    275          }
    276          
    277          
    278          /******************************************************************************/
    279          
    280          CPU_INT08U Queue_WriteBuf(QUEUE_DATA_TYPE *Ret, void *Buf, CPU_INT16U bytes_copy)
    281          {
    282              CPU_INT08U err;
    283              DataQueue *Queue;
    284          
    285          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
    286              OS_CPU_SR  cpu_sr = 0u;
    287          #endif
    288              
    289              err = QUEUE_FAIL;
    290              if (Buf == NULL | bytes_copy == 0)  {                                          /* 队列是否有效 */    
    291                   return err;
    292              }    
    293              Queue = (DataQueue *)Buf;  
    294              err = QUEUE_OK;
    295              
    296              OS_ENTER_CRITICAL();  
    297               
    298              while( bytes_copy-- > 0 ){ 
    299                        
    300                   if(Queue->NData < Queue->MaxData) {   
    301                           *(Queue->In)++ = *Ret++ ; 
    302                           Queue->NData++ ;
    303                           if (Queue->In >= Queue->End)  {
    304                              Queue->In = Queue->Buf;
    305                           } 
    306                           
    307                    } else { //full, discard the rest data
    308                           //Queue->Out++ ;
    309                           //Queue->NData-- ;
    310                           //*(Queue->In)++ = *Ret++ ;            
    311                           //if (Queue->In >= Queue->End)  {
    312                           //   Queue->In = Queue->Buf;
    313                           //} 
    314                           err = QUEUE_FULL;
    315                     }
    316              }
    317              
    318              OS_EXIT_CRITICAL();
    319          
    320              return err;
    321          }
    322          
    323          #endif
    324          
    325          /*********************************************************************************************************
    326          ** 函数名称: QueueWriteFront
    327          ** 功能描述: LIFO方式发送数据
    328          ** 输  　入: Buf:指向队列的指针
    329          **           Data:消息数据
    330          ** 输　  出: QUEUE_FULL:队列满
    331          **           QUEUE_OK:发送成功
    332          ** 全局变量: 无
    333          ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
    334          **
    335          **------------------------------------------------------------------------------------------------------
    336          ********************************************************************************************************/
    337          #ifndef EN_QUEUE_WRITE_FRONT
    338          #define EN_QUEUE_WRITE_FRONT    0
    339          #endif
    340          
    341          #if EN_QUEUE_WRITE_FRONT > 0
    342          
    343          CPU_INT08U Queue_WriteFront(void *Buf, QUEUE_DATA_TYPE Data)
    344          {
    345              CPU_INT08U err;
    346              DataQueue *Queue;
    347              
    348          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
    349              OS_CPU_SR  cpu_sr = 0u;
    350          #endif
    351              
    352              err = QUEUE_FAIL;
    353              if (Buf != NULL)                                                    /* 队列是否有效 */
    354              {
    355                  Queue = (DataQueue *)Buf;
    356                  
    357                  OS_ENTER_CRITICAL();
    358                  
    359                  if (Queue->NData < Queue->MaxData)                              /* 队列是否满  */
    360                  {                                                               /* 不满 */
    361                      Queue->Out--;                                               /* 调整出队指针 */
    362                      if (Queue->Out < Queue->Buf)
    363                      {
    364                          Queue->Out = Queue->End - 1;
    365                      }
    366                      Queue->Out[0] = Data;                                       /* 数据入队     */
    367                      Queue->NData++;                                             /* 数据数目增加 */
    368                      err = QUEUE_OK;
    369                  }
    370                  else
    371                  {                                                               /* 满           */
    372                      err = QUEUE_FULL;        
    373                  }
    374                  OS_EXIT_CRITICAL();
    375              }
    376              return err;
    377          }
    378          
    379          #endif
    380          
    381          /*********************************************************************************************************
    382          ** 函数名称: QueueNData
    383          ** 功能描述: 取得队列中数据数
    384          ** 输  　入: Buf:指向队列的指针
    385          ** 输  　出: 消息数
    386          ** 全局变量: 无
    387          ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
    388          **
    389          **------------------------------------------------------------------------------------------------------
    390          ********************************************************************************************************/
    391          #ifndef EN_QUEUE_NDATA
    392          #define EN_QUEUE_NDATA    0
    393          #endif
    394          
    395          #if EN_QUEUE_NDATA > 0
    396          
    397          CPU_INT16U Queue_NData(void *Buf)
    398          {
    399              CPU_INT16U temp;
    400              
    401          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
    402              OS_CPU_SR  cpu_sr = 0u;
    403          #endif
    404              
    405              temp = 0;                                                   /* 队列无效返回0 */
    406              if (Buf != NULL)
    407              {
    408                  OS_ENTER_CRITICAL();
    409                  temp = ((DataQueue *)Buf)->NData;
    410                  OS_EXIT_CRITICAL();
    411              }
    412              return temp;
    413          }
    414          
    415          #endif
    416          
    417          /*********************************************************************************************************
    418          ** 函数名称: QueueSize
    419          ** 功能描述: 取得队列总容量
    420          ** 输  　入: Buf:指向队列的指针
    421          ** 输  　出: 队列总容量
    422          ** 全局变量: 无
    423          ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
    424          **
    425          **------------------------------------------------------------------------------------------------------
    426          ********************************************************************************************************/
    427          #ifndef EN_QUEUE_SIZE
    428          #define EN_QUEUE_SIZE    0
    429          #endif
    430          
    431          #if EN_QUEUE_SIZE > 0
    432          
    433          CPU_INT16U Queue_Size(void *Buf)
    434          {
    435              CPU_INT16U temp;
    436              
    437          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
    438              OS_CPU_SR  cpu_sr = 0u;
    439          #endif
    440              
    441              temp = 0;                                                   /* 队列无效返回0 */
    442              if (Buf != NULL)
    443              {
    444                  OS_ENTER_CRITICAL();
    445                  temp = ((DataQueue *)Buf)->MaxData;
    446                  OS_EXIT_CRITICAL();
    447              }
    448              return temp;
    449          }
    450          
    451          #endif
    452          
    453          /*********************************************************************************************************
    454          ** 函数名称: OSQFlush
    455          ** 功能描述: 清空队列
    456          ** 输　  入: Buf:指向队列的指针
    457          ** 输  　出: 无
    458          ** 全局变量: 无
    459          ** 调用模块: OS_ENTER_CRITICAL,OS_EXIT_CRITICAL
    460          **
    461          **------------------------------------------------------------------------------------------------------
    462          ********************************************************************************************************/
    463          #ifndef EN_QUEUE_FLUSH
    464          #define EN_QUEUE_FLUSH    0
    465          #endif
    466          
    467          #if EN_QUEUE_FLUSH > 0
    468          
    469          void Queue_Flush(void *Buf)
    470          {
    471              DataQueue *Queue;
    472              
    473          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
    474              OS_CPU_SR  cpu_sr = 0u;
    475          #endif
    476              
    477              if (Buf != NULL )                                                /* 队列是否有效 */
    478              {                                                               /* 有效         */
    479                  Queue = (DataQueue *)Buf;
    480                  OS_ENTER_CRITICAL();
    481                  Queue->Out = Queue->Buf;
    482                  Queue->In = Queue->Buf;
    483                  Queue->NData = 0;                                           /* 数据数目为0 */
    484                  OS_EXIT_CRITICAL();
    485              }
    486          }
    487          
    488          #endif
    489          
    490          
    491          
    492          
    493          
    494          
    495          
    496          
    497          
    498          
    499          
    500          
    501          /*********************************************************************************************************
    502          **                            End Of File
    503          ********************************************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   Queue_Create
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> __aeabi_uidiv
      16   Queue_Flush
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      16   Queue_NData
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      24   Queue_Read
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      32   Queue_ReadBuf
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
      24   Queue_ReadOnly
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      16   Queue_Size
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      24   Queue_Write
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      32   Queue_WriteBuf
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
      24   Queue_WriteFront
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     128  Queue_Create
      72  Queue_Flush
      72  Queue_NData
     160  Queue_Read
     336  Queue_ReadBuf
     112  Queue_ReadOnly
      72  Queue_Size
     160  Queue_Write
     272  Queue_WriteBuf
     164  Queue_WriteFront

 
 1 548 bytes in section .text
 
 1 548 bytes of CODE memory

Errors: none
Warnings: none
