###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        22/May/2014  14:14:58
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\twi.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\twi.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\twi.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\twi.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\twi.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          /// \unit
     32          ///
     33          /// !Purpose
     34          ///
     35          /// Interface for configuration the Two Wire Interface (TWI) peripheral.
     36          ///
     37          /// !Usage
     38          ///
     39          /// -# Configures a TWI peripheral to operate in master mode, at the given
     40          /// frequency (in Hz) using TWI_Configure().
     41          /// -# Sends a STOP condition on the TWI using TWI_Stop().
     42          /// -# Starts a read operation on the TWI bus with the specified slave using
     43          /// TWI_StartRead(). Data must then be read using TWI_ReadByte() whenever
     44          /// a byte is available (poll using TWI_ByteReceived()).
     45          /// -# Starts a write operation on the TWI to access the selected slave using
     46          /// TWI_StartWrite(). A byte of data must be provided to start the write;
     47          /// other bytes are written next.
     48          /// -# Sends a byte of data to one of the TWI slaves on the bus using TWI_WriteByte().
     49          /// This function must be called once before TWI_StartWrite() with the first byte of data
     50          /// to send, then it shall be called repeatedly after that to send the remaining bytes.
     51          /// -# Check if a byte has been received and can be read on the given TWI
     52          /// peripheral using TWI_ByteReceived().
     53          /// Check if a byte has been sent using TWI_ByteSent().
     54          /// -# Check if the current transmission is complete (the STOP has been sent)
     55          /// using TWI_TransferComplete().
     56          /// -# Enables & disable the selected interrupts sources on a TWI peripheral
     57          /// using TWI_EnableIt() and TWI_DisableIt().
     58          /// -# Get current status register of the given TWI peripheral using
     59          /// TWI_GetStatus(). Get current status register of the given TWI peripheral, but
     60          /// masking interrupt sources which are not currently enabled using
     61          /// TWI_GetMaskedStatus().
     62          //------------------------------------------------------------------------------
     63          
     64          
     65          //------------------------------------------------------------------------------
     66          //         Headers
     67          //------------------------------------------------------------------------------
     68          
     69          #include "twi.h"
     70          #include "math.h"
     71          
     72          //#include <utility/assert.h>
     73          //#include <utility/trace.h>
     74          
     75          //extern void delay(unsigned int times);
     76          //------------------------------------------------------------------------------
     77          //         Global functions
     78          //------------------------------------------------------------------------------
     79          
     80          //------------------------------------------------------------------------------
     81          /// Configures a TWI peripheral to operate in master mode, at the given
     82          /// frequency (in Hz). The duty cycle of the TWI clock is set to 50%.
     83          /// \param pTwi  Pointer to an AT91S_TWI instance.
     84          /// \param twck  Desired TWI clock frequency.
     85          /// \param mck  Master clock frequency.
     86          //------------------------------------------------------------------------------
     87          void TWI_ConfigureMaster(AT91S_TWI *pTwi, unsigned int twck, unsigned int mck)
     88          {
     89              unsigned int ckdiv = 0;
     90              unsigned int cldiv;
     91              unsigned char ok = 0;
     92          
     93              //trace_LOG(trace_INFO,"TWI_ConfigureMaster()\n\r");
     94              //SANITY_CHECK(pTwi);
     95          
     96          #ifdef AT91C_TWI_SVEN  // TWI slave
     97              // SVEN: TWI Slave Mode Enabled
     98              pTwi->TWI_CR = AT91C_TWI_SVEN;
     99          #endif
    100              
    101              // Reset the TWI
    102              pTwi->TWI_CR = AT91C_TWI_SWRST;
    103              pTwi->TWI_RHR;
    104          
    105              // TWI Slave Mode Disabled, TWI Master Mode Disabled
    106          #ifdef AT91C_TWI_SVEN  // TWI slave
    107              pTwi->TWI_CR = AT91C_TWI_SVDIS;
    108          #endif
    109              pTwi->TWI_CR = AT91C_TWI_MSDIS;
    110          
    111              // Set master mode
    112              pTwi->TWI_CR = AT91C_TWI_MSEN;
    113          
    114              
    115              
    116              // Configure clock
    117              while (!ok) {
    118          #if defined(__ARMCC_VERSION)
    119                  cldiv = ((mck / (2 * twck)) - 3) / pow(2, ckdiv);
    120          #else
    121                  cldiv = ((mck / (2 * twck)) - 3) / power(2, ckdiv);
    122          #endif        
    123                  if (cldiv <= 255) {
    124          
    125                      ok = 1;
    126                  }
    127                  else {
    128          
    129                      ckdiv++;
    130                  }
    131              }
    132          
    133              //ASSERT(ckdiv < 8, "-F- Cannot find valid TWI clock parameters\n\r");
    134              //trace_LOG(ckdiv, "Using CKDIV = %u and CLDIV/CHDIV = %u\n\r");
    135              pTwi->TWI_CWGR = 0;
    136              pTwi->TWI_CWGR = (ckdiv << 16) | (cldiv << 8) | cldiv;
    137          }
    138          
    139          
    140          
    141          #ifdef AT91C_TWI_SVEN  // TWI slave
    142          //------------------------------------------------------------------------------
    143          /// Configures a TWI peripheral to operate in slave mode
    144          /// \param pTwi  Pointer to an AT91S_TWI instance.
    145          //------------------------------------------------------------------------------
    146          void TWI_ConfigureSlave(AT91S_TWI *pTwi, unsigned char slaveAddress)
    147          {
    148              unsigned int i;
    149          
    150              // TWI software reset
    151              pTwi->TWI_CR = AT91C_TWI_SWRST;
    152              pTwi->TWI_RHR;
    153          
    154              // Wait at least 10 ms
    155              for (i=0; i < 1000000; i++);
    156          
    157              // TWI Slave Mode Disabled, TWI Master Mode Disabled
    158              pTwi->TWI_CR = AT91C_TWI_SVDIS | AT91C_TWI_MSDIS;
    159          
    160              // Slave Address
    161              pTwi->TWI_SMR = 0;
    162              pTwi->TWI_SMR = (slaveAddress << 16) & AT91C_TWI_SADR;
    163          
    164              // SVEN: TWI Slave Mode Enabled
    165              pTwi->TWI_CR = AT91C_TWI_SVEN;
    166          
    167              // Wait at least 10 ms
    168              for (i=0; i < 1000000; i++);
    169              //ASSERT( (pTwi->TWI_CR & AT91C_TWI_SVDIS)!=AT91C_TWI_SVDIS, "Problem slave mode");
    170          }
    171          #endif
    172          
    173          //------------------------------------------------------------------------------
    174          /// Sends a STOP condition on the TWI.
    175          /// \param pTwi  Pointer to an AT91S_TWI instance.
    176          //------------------------------------------------------------------------------
    177          void TWI_Stop(AT91S_TWI *pTwi)
    178          {
    179              //SANITY_CHECK(pTwi);
    180          
    181              pTwi->TWI_CR = AT91C_TWI_STOP;
    182          }
    183          
    184          //------------------------------------------------------------------------------
    185          /// Starts a read operation on the TWI bus with the specified slave, and returns
    186          /// immediately. Data must then be read using TWI_ReadByte() whenever a byte is
    187          /// available (poll using TWI_ByteReceived()).
    188          /// \param pTwi  Pointer to an AT91S_TWI instance.
    189          /// \param address  Slave address on the bus.
    190          /// \param iaddress  Optional internal address bytes.
    191          /// \param isize  Number of internal address bytes.
    192          //-----------------------------------------------------------------------------
    193          void TWI_StartRead(
    194              AT91S_TWI *pTwi,
    195              unsigned char address,
    196              unsigned int iaddress,
    197              unsigned char isize)
    198          {
    199              //TRACE_DEBUG("TWI_StartRead()\n\r");
    200              //SANITY_CHECK(pTwi);
    201              //SANITY_CHECK((address & 0x80) == 0);
    202              //SANITY_CHECK((iaddress & 0xFF000000) == 0);
    203              //SANITY_CHECK(isize < 4);
    204          
    205              // Set slave address and number of internal address bytes
    206              pTwi->TWI_MMR = 0;
    207              pTwi->TWI_MMR = (isize << 8) | AT91C_TWI_MREAD | (address << 16);
    208          
    209              // Set internal address bytes
    210              pTwi->TWI_IADR = 0;
    211              pTwi->TWI_IADR = iaddress;
    212          
    213              // Send START condition
    214              pTwi->TWI_CR = AT91C_TWI_START;
    215          }
    216          
    217          //-----------------------------------------------------------------------------
    218          /// Reads a byte from the TWI bus. The read operation must have been started
    219          /// using TWI_StartRead() and a byte must be available (check with
    220          /// TWI_ByteReceived()).
    221          /// Returns the byte read.
    222          /// \param pTwi  Pointer to an AT91S_TWI instance.
    223          //-----------------------------------------------------------------------------
    224          unsigned char TWI_ReadByte(AT91S_TWI *pTwi)
    225          {
    226              //SANITY_CHECK(pTwi);
    227          
    228              return pTwi->TWI_RHR;
    229          }
    230          
    231          //-----------------------------------------------------------------------------
    232          /// Sends a byte of data to one of the TWI slaves on the bus. This function
    233          /// must be called once before TWI_StartWrite() with the first byte of data
    234          /// to send, then it shall be called repeatedly after that to send the
    235          /// remaining bytes.
    236          /// \param pTwi  Pointer to an AT91S_TWI instance.
    237          /// \param byte  Byte to send.
    238          //-----------------------------------------------------------------------------
    239          
    240          void TWI_WriteByte(AT91S_TWI *pTwi, unsigned char byte)
    241          {
    242              //SANITY_CHECK(pTwi);
    243              pTwi->TWI_THR = byte;
    244          
    245          }
    246          
    247          //-----------------------------------------------------------------------------
    248          /// Starts a write operation on the TWI to access the selected slave, then
    249          /// returns immediately. A byte of data must be provided to start the write;
    250          /// other bytes are written next.
    251          /// \param pTwi  Pointer to an AT91S_TWI instance.
    252          /// \param address  Address of slave to acccess on the bus.
    253          /// \param iaddress  Optional slave internal address.
    254          /// \param isize  Number of internal address bytes.
    255          /// \param byte  First byte to send.
    256          //-----------------------------------------------------------------------------
    257          void TWI_StartWrite(
    258              AT91S_TWI *pTwi,
    259              unsigned char address,
    260              unsigned int iaddress,
    261              unsigned char isize,
    262              unsigned char byte)
    263          {
    264              //TRACE_DEBUG("TWI_StartWrite()\n\r");
    265              //SANITY_CHECK(pTwi);
    266              //SANITY_CHECK((address & 0x80) == 0);
    267              //SANITY_CHECK((iaddress & 0xFF000000) == 0);
    268              //SANITY_CHECK(isize < 4);
    269          
    270              // Set slave address and number of internal address bytes
    271              pTwi->TWI_MMR = 0;
    272              pTwi->TWI_MMR = (isize << 8) | (address << 16);
    273          
    274              // Set internal address bytes
    275              pTwi->TWI_IADR = 0;
    276              pTwi->TWI_IADR = iaddress;
    277              // Write first byte to send
    278              TWI_WriteByte(pTwi, byte);
    279          }
    280          
    281          //-----------------------------------------------------------------------------
    282          /// Returns 1 if a byte has been received and can be read on the given TWI
    283          /// peripheral; otherwise, returns 0. This function resets the status register
    284          /// of the TWI.
    285          /// \param pTwi  Pointer to an AT91S_TWI instance.
    286          //-----------------------------------------------------------------------------
    287          unsigned char TWI_ByteReceived(AT91S_TWI *pTwi)
    288          {
    289              return ((pTwi->TWI_SR & AT91C_TWI_RXRDY) == AT91C_TWI_RXRDY);
    290          }
    291          
    292          //-----------------------------------------------------------------------------
    293          /// Returns 1 if a byte has been sent, so another one can be stored for
    294          /// transmission; otherwise returns 0. This function clears the status register
    295          /// of the TWI.
    296          /// \param pTwi  Pointer to an AT91S_TWI instance.
    297          //-----------------------------------------------------------------------------
    298          unsigned char TWI_ByteSent(AT91S_TWI *pTwi)
    299          {
    300              return ((pTwi->TWI_SR & AT91C_TWI_TXRDY) == AT91C_TWI_TXRDY);
    301          }
    302          
    303          //-----------------------------------------------------------------------------
    304          /// Returns 1 if the current transmission is complete (the STOP has been sent);
    305          /// otherwise returns 0.
    306          /// \param pTwi  Pointer to an AT91S_TWI instance.
    307          //-----------------------------------------------------------------------------
    308          unsigned char TWI_TransferComplete(AT91S_TWI *pTwi)
    309          {
    310              return ((pTwi->TWI_SR & AT91C_TWI_TXCOMP) == AT91C_TWI_TXCOMP);
    311          }
    312          
    313          //-----------------------------------------------------------------------------
    314          /// Enables the selected interrupts sources on a TWI peripheral.
    315          /// \param pTwi  Pointer to an AT91S_TWI instance.
    316          /// \param sources  Bitwise OR of selected interrupt sources.
    317          //-----------------------------------------------------------------------------
    318          void TWI_EnableIt(AT91S_TWI *pTwi, unsigned int sources)
    319          {
    320              //SANITY_CHECK(pTwi);
    321              //SANITY_CHECK((sources & 0xFFFFF088) == 0);
    322          
    323              pTwi->TWI_IER = sources;
    324          }
    325          
    326          //-----------------------------------------------------------------------------
    327          /// Disables the selected interrupts sources on a TWI peripheral.
    328          /// \param pTwi  Pointer to an AT91S_TWI instance.
    329          /// \param sources  Bitwise OR of selected interrupt sources.
    330          //-----------------------------------------------------------------------------
    331          void TWI_DisableIt(AT91S_TWI *pTwi, unsigned int sources)
    332          {
    333              //SANITY_CHECK(pTwi);
    334              //SANITY_CHECK((sources & 0xFFFFF088) == 0);
    335          
    336              pTwi->TWI_IDR = sources;
    337          }
    338          
    339          //-----------------------------------------------------------------------------
    340          /// Returns the current status register of the given TWI peripheral. This
    341          /// resets the internal value of the status register, so further read may yield
    342          /// different values.
    343          /// \param pTwi  Pointer to an AT91S_TWI instance.
    344          //-----------------------------------------------------------------------------
    345          unsigned int TWI_GetStatus(AT91S_TWI *pTwi)
    346          {
    347              //SANITY_CHECK(pTwi);
    348          
    349              return pTwi->TWI_SR;
    350          }
    351          
    352          //-----------------------------------------------------------------------------
    353          /// Returns the current status register of the given TWI peripheral, but
    354          /// masking interrupt sources which are not currently enabled.
    355          /// This resets the internal value of the status register, so further read may
    356          /// yield different values.
    357          /// \param pTwi  Pointer to an AT91S_TWI instance.
    358          //-----------------------------------------------------------------------------
    359          unsigned int TWI_GetMaskedStatus(AT91S_TWI *pTwi)
    360          {
    361              unsigned int status;
    362          
    363              //SANITY_CHECK(pTwi);
    364          
    365              status  = pTwi->TWI_SR;
    366              status &= pTwi->TWI_IMR;
    367          
    368              return status;
    369          }
    370          //-----------------------------------------------------------------------------
    371          /// Sends a STOP condition. STOP Condition is sent just after completing
    372          /// the current byte transmission in master read mode.
    373          /// \param pTwi  Pointer to an AT91S_TWI instance.
    374          //-----------------------------------------------------------------------------
    375          void TWI_SendSTOPCondition(AT91S_TWI *pTwi)
    376          {
    377              //SANITY_CHECK(pTwi);
    378          
    379              pTwi->TWI_CR |= AT91C_TWI_STOP;
    380          }
    381          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   TWI_ByteReceived
       0   TWI_ByteSent
      32   TWI_ConfigureMaster
        32   -> __aeabi_uidiv
        32   -> power
       0   TWI_DisableIt
       0   TWI_EnableIt
       0   TWI_GetMaskedStatus
       0   TWI_GetStatus
       0   TWI_ReadByte
       0   TWI_SendSTOPCondition
       4   TWI_StartRead
      24   TWI_StartWrite
        24   -> TWI_WriteByte
       0   TWI_Stop
       0   TWI_TransferComplete
       0   TWI_WriteByte


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  TWI_ByteReceived
      20  TWI_ByteSent
     176  TWI_ConfigureMaster
       8  TWI_DisableIt
       8  TWI_EnableIt
      24  TWI_GetMaskedStatus
       8  TWI_GetStatus
      12  TWI_ReadByte
      16  TWI_SendSTOPCondition
      72  TWI_StartRead
      96  TWI_StartWrite
      12  TWI_Stop
      16  TWI_TransferComplete
      16  TWI_WriteByte

 
 504 bytes in section .text
 
 504 bytes of CODE memory

Errors: none
Warnings: none
