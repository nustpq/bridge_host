###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        15/Dec/2014  18:01:18
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\ruler.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\ruler.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\ruler.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\ruler.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\ruler.c
      1          /*
      2          *********************************************************************************************************
      3          *                               iSAM TEST BENCH AUDIO BRIDGE BOARD APP PACKAGE
      4          *
      5          *                            (c) Copyright 2013 - 2016; Fortemedia Inc.; Nanjing, China
      6          *
      7          *                   All rights reserved.  Protected by international copyright laws.
      8          *                   Knowledge of the source code may not be used to write a similar
      9          *                   product.  This file may only be used in accordance with a license
     10          *                   and should not be redistributed in any way.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                        RULER RELATED OPERATIONS REALIZATION
     18          *
     19          *                                          Atmel AT91SAM7A3
     20          *                                               on the
     21          *                                      iSAM Audio Bridge Board
     22          *
     23          * Filename      : ruler.c
     24          * Version       : V1.0.0
     25          * Programmer(s) : PQ
     26          *********************************************************************************************************
     27          * Note(s)       :
     28          *********************************************************************************************************
     29          */
     30          
     31          #include <includes.h>
     32          
     33          
     34          volatile unsigned int   Global_Mic_Mask[4] ;      //MIC sellection status
     35          volatile unsigned char  Global_Ruler_Index = 0 ;  //the ruler index for UART comm NOW
     36          volatile unsigned char  Global_Bridge_POST = 0 ;  //audio bridge POST status
     37          volatile unsigned char  Global_Ruler_State[4];    //ruler status
     38          volatile unsigned char  Global_Ruler_Type[4];     //ruler type
     39          volatile unsigned char  Global_Mic_State[4];      //MIC (8*4=32) status(calib info error or not)
     40          unsigned char           Audio_Version[12];        //fixed size
     41          unsigned char           Ruler_CMD_Result;
     42          volatile unsigned char  Ruler_Setup_Sync_Data;
     43          
     44          extern EMB_BUF   Emb_Buf_Data;
     45          extern EMB_BUF   Emb_Buf_Cmd;
     46          
     47          
     48          
     49          /*
     50          *********************************************************************************************************
     51          *                                           Init_Global_Var()
     52          *
     53          * Description : Initialize Ruler and MIC related global variables to defalut value.
     54          * Argument(s) : None.
     55          * Return(s)   : None.
     56          *
     57          * Note(s)     : None.
     58          *********************************************************************************************************
     59          */
     60          void Init_Global_Var( void )
     61          {
     62              unsigned char ruler_id;    
     63              
     64              for( ruler_id = 0; ruler_id < 4; ruler_id++ ) {        
     65                  Global_Ruler_State[ruler_id] = RULER_STATE_DETACHED;
     66                  Global_Ruler_Type[ruler_id]  = 0;
     67                  Global_Mic_State[ruler_id]   = 0 ;
     68                  Global_Mic_Mask[ruler_id]    = 0 ;        
     69              }   
     70          }
     71          
     72          
     73          /*
     74          *********************************************************************************************************
     75          *                                           Check_Actived_Mic_Number()
     76          *
     77          * Description : Check MIC mask global variable to get the total actived MICs number.
     78          * Argument(s) : None.
     79          * Return(s)   : mic_counter : the total actived MICs number.
     80          *
     81          * Note(s)     : None.
     82          *********************************************************************************************************
     83          */
     84          static unsigned char Check_Actived_Mic_Number( void )
     85          {
     86              unsigned char mic_counter = 0;
     87              unsigned char i, j;    
     88          
     89              for( i = 0; i < 4 ; i++ ) { //scan 4 slots
     90                  for( j = 0; j < 32; j++ ) { //scan max 32mics per slot
     91                      if( (Global_Mic_Mask[i]>>j)&1) {
     92                          mic_counter++;
     93                      }
     94                  }
     95              } 
     96             
     97              return mic_counter;
     98          }
     99          
    100          
    101          /*
    102          *********************************************************************************************************
    103          *                                           Check_Watch_Attach_State()
    104          *
    105          * Description : Check if Mics on Watch ruler is used. For MIC revert issue on W01 mickup
    106          * Argument(s) : None.
    107          * Return(s)   : 0 : no watch attachd or Mics on watch not used.
    108          *               1 : Mics on watch used.
    109          *
    110          * Note(s)     : pass this info for revert mic in FM36 PDM input.
    111          *********************************************************************************************************
    112          */
    113          unsigned char Check_Watch_Attach_State( void )
    114          {
    115              unsigned char ruler_id;
    116              
    117              for( ruler_id = 0; ruler_id < 4; ruler_id++ ) {
    118                  
    119                  if( Global_Ruler_State[ruler_id] < RULER_STATE_SELECTED ) {
    120                      continue;
    121                  }
    122                  if( Global_Ruler_Type[ruler_id] == RULER_TYPE_W01 ) {
    123                       return 1;
    124                  }    
    125                  
    126              }
    127              
    128              return 0;    
    129          }
    130          
    131          /*
    132          *********************************************************************************************************
    133          *                                           Check_UART_Mixer_Ready()
    134          *
    135          * Description : Check and wait until all data transmission inbuffer for current channel ruler is done .
    136          *               To make sure ruler channels will not be mix up.
    137          *               HW switch is important for this !
    138          * Argument(s) : None.
    139          * Return(s)   : mic_counter : the total actived MICs number.
    140          *
    141          * Note(s)     : If HW switch fast enough, no need this routine.
    142          *********************************************************************************************************
    143          */
    144          void Check_UART_Mixer_Ready( void )
    145          {
    146              unsigned char err; 
    147              unsigned int  counter;
    148              
    149              counter = 0;
    150              while( OSQGet( EVENT_MsgQ_Noah2RulerUART, &err ) ) {
    151                  OSTimeDly(1);
    152                  counter++;        
    153              } 
    154              if( counter) {
    155                  APP_TRACE_INFO(("Check_UART_Mixer_Ready, stage 1 : wait %d ms\r\n",counter));  
    156              }
    157                  
    158              counter = 0;
    159              while( Queue_NData((void*)pUART_Send_Buf[RULER_UART]) ) {
    160                  OSTimeDly(1);
    161                  counter++;  
    162              } 
    163              if( counter) {
    164                  APP_TRACE_INFO(("Check_UART_Mixer_Ready, stage 2 : wait %d ms\r\n",counter));  
    165              }
    166              OSTimeDly(5);   
    167              
    168          }
    169          
    170          
    171          /*
    172          *********************************************************************************************************
    173          *                                           Setup_Audio()
    174          *
    175          * Description : Send command to configure USB audio.
    176          * Argument(s) : pAudioCfg : pointer to AUDIO_CFG type data.
    177          * Return(s)   : NO_ERR :   execute successfully
    178          *               others :   refer to error code defines.           
    179          *
    180          * Note(s)     : None.
    181          *********************************************************************************************************
    182          */
    183          unsigned char Setup_Audio( AUDIO_CFG *pAudioCfg )
    184          {
    185              unsigned char err; 
    186              unsigned char mic_num; 
    187              unsigned char data  = 0xFF;
    188              unsigned char buf[] = { 
    189                  CMD_DATA_SYNC1, CMD_DATA_SYNC2, RULER_CMD_SET_AUDIO_CFG,\
    190                  pAudioCfg->type, pAudioCfg->channels,\
    191                 (pAudioCfg->sr)&0xFF, ((pAudioCfg->sr)>>8)&0xFF
    192              };
    193              
    194              //APP_TRACE_INFO(("Setup_Audio [%s]:[%d SR]:[%d CH]: %s\r\n",(pAudioCfg->type == 0) ? "REC " : "PLAY", pAudioCfg->sr, pAudioCfg->channels,((pAudioCfg->type == 0) && (pAudioCfg->lin_ch_mask == 0)) ? "LIN Disabled" : "LIN Enabled"));
    195              if( pAudioCfg->type == 0 ) {
    196                  APP_TRACE_INFO(("Setup_Audio [REC]:[%d SR]:[%d CH]: %s\r\n", pAudioCfg->sr, pAudioCfg->channels, pAudioCfg->lin_ch_mask == 0 ? "LIN Disabled" : "LIN Enabled" ));
    197              } else {
    198                  APP_TRACE_INFO(("Setup_Audio [PLAY]:[%d SR]:[%d CH]\r\n", pAudioCfg->sr, pAudioCfg->channels ));
    199              }
    200              
    201              err = Check_SR_Support( pAudioCfg->sr );
    202              if( err != NO_ERR ) { 
    203                  APP_TRACE_INFO(("\r\nSetup_Audio ERROR: Sample rate NOT support!\r\n")); 
    204                  return err;
    205              }    
    206              mic_num = Check_Actived_Mic_Number();
    207              if( mic_num > 6 ) {
    208                  APP_TRACE_INFO(("\r\nERROR: Check_Actived_Mic_Number = %d > 6\r\n",mic_num));
    209                  return AUD_CFG_MIC_NUM_MAX_ERR;//if report err, need UI support!  
    210              } 
    211              //check rec mic num    
    212              if( (pAudioCfg->type == 0) && ( mic_num != pAudioCfg->channels) ) {
    213                  APP_TRACE_INFO(("WARN:(Setup_Audio Rec)pAudioCfg->channels(%d) !=  Active MICs Num(%d)\r\n",pAudioCfg->channels,mic_num));
    214                  buf[4] = mic_num;
    215                  return AUD_CFG_MIC_NUM_DISMATCH_ERR;
    216              }
    217              //check channel num    
    218              if( (pAudioCfg->type == 1) && (pAudioCfg->channels == 0) ) {
    219                  APP_TRACE_INFO(("WARN:(Setup_Audio Play)pAudioCfg->channels =  0\r\n" ));        
    220                  //return AUD_CFG_PLAY_CH_ZERO_ERR;  UI not support
    221              }  
    222              if( (pAudioCfg->type == 0) && (pAudioCfg->channels == 0) && (pAudioCfg->lin_ch_mask == 0) ) {
    223                  APP_TRACE_INFO(("WARN:(Setup_Audio Rec)pAudioCfg->channels + ch_lin =  0\r\n" ));        
    224                  //return AUD_CFG_PLAY_CH_ZERO_ERR; UI not support
    225              }
    226              //check sample rate
    227              //No add here!
    228              //
    229              //
    230           #ifdef BOARD_TYPE_AB03    
    231              //check play ch num
    232              if(  (pAudioCfg->type == 1) && ( pAudioCfg->channels > 4 ) ) { //for AB03
    233                  APP_TRACE_INFO(("ERROR:(Setup_Audio Play)pAudioCfg->channels(=%d) > 4 NOT allowed for AB03\r\n",pAudioCfg->channels));
    234                  return AUD_CFG_PLAY_CH_ERR ;
    235              }
    236          #endif
    237              if ( (pAudioCfg->type == 0) && (pAudioCfg->lin_ch_mask != 0) ) {         
    238                   buf[4] += 2; //add 2 channel  
    239                   APP_TRACE_INFO(("Lin 2 channels added...%d\r\n",buf[4])); 
    240              }
    241              UART2_Mixer(3); 
    242              USART_SendBuf( AUDIO_UART, buf, sizeof(buf)) ; 
    243              err = USART_Read_Timeout( AUDIO_UART, &data, 1, TIMEOUT_AUDIO_COM);
    244              if( err != NO_ERR ) { 
    245                  APP_TRACE_INFO(("\r\nSetup_Audio ERROR: timeout\r\n")); 
    246                  return err;
    247              }
    248              if( data != NO_ERR ) {
    249                  APP_TRACE_INFO(("\r\nSetup_Audio ERROR: %d\r\n ",data)); 
    250                  return data; 
    251              }
    252              err = Init_CODEC( pAudioCfg->sr );
    253              if( err != NO_ERR ) {
    254                  APP_TRACE_INFO(("\r\nSetup_Audio Init_CODEC ERROR: %d\r\n",err)); 
    255              } 
    256          #ifdef BOARD_TYPE_AB03    
    257              err = Init_FM36_AB03( pAudioCfg->sr, mic_num, 1, 0 ); //Lin from SP1_RX, slot0~1
    258          #else
    259              err = ReInit_FM36( pAudioCfg->sr ); 
    260          #endif
    261              if( err != NO_ERR ) {
    262                  APP_TRACE_INFO(("\r\nSetup_Audio ReInit_FM36 ERROR: %d\r\n",err)); 
    263              }
    264              data = Check_Watch_Attach_State();
    265              if( data ) {
    266                  APP_TRACE_INFO(("Revert DMIC polarity for W01.\r\n")); 
    267              }
    268              err = DMIC_Ploarity_Control( data );
    269              if( err != NO_ERR ) {
    270                  APP_TRACE_INFO(("\r\nDMIC_Ploarity_Control ERROR: %d\r\n",err)); 
    271              }
    272          //    if ( pAudioCfg->lin_ch_mask != 0 ) {
    273          //        err = Set_AIC3204_DSP_Offset( mic_num );
    274          //        if( err != NO_ERR ) {
    275          //            APP_TRACE_INFO(("\r\nSetup_Audio Init AIC3204 ERROR: %d\r\n",err)); 
    276          //        }
    277          //    }
    278              
    279              return err ; 
    280          }
    281          
    282          
    283          /*
    284          *********************************************************************************************************
    285          *                                           Start_Audio()
    286          *
    287          * Description : Send command to start USB audio play/record.
    288          * Argument(s) : cmd_type : record£¨== 1£©/play£¨== 2£©/record & play £¨== 3£©
    289          *               padding :  used for usb audio BI/BO first package padding
    290          * Return(s)   : NO_ERR :   execute successfully
    291          *               others :   refer to error code defines.           
    292          *
    293          * Note(s)     : None.
    294          *********************************************************************************************************
    295          */
    296          unsigned char Start_Audio( START_AUDIO start_audio )
    297          {   
    298              unsigned char err   = 0xFF;  
    299              unsigned char data  = 0xFF; 
    300              unsigned char ruler_id;    
    301              unsigned char buf[] = { CMD_DATA_SYNC1, CMD_DATA_SYNC2, RULER_CMD_START_AUDIO, start_audio.type&0x03, start_audio.padding }; 
    302              
    303          #if OS_CRITICAL_METHOD == 3u
    304              OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    305          #endif 
    306              APP_TRACE_INFO(("Start_Audio : type = [%d], padding = [0x%X]\r\n", start_audio.type, start_audio.padding));
    307              UART2_Mixer(3); 
    308              USART_SendBuf( AUDIO_UART, buf,  sizeof(buf) );    
    309              err = USART_Read_Timeout( AUDIO_UART, &data, 1, TIMEOUT_AUDIO_COM );  
    310              if( err != NO_ERR ) { 
    311                  APP_TRACE_INFO(("\r\nStart_Audio ERROR: Timeout : %d\r\n",err));
    312                  return err;
    313              }
    314              if( data != NO_ERR ) {
    315                  APP_TRACE_INFO(("\r\nStart_Audio ERROR: Data : %d\r\n ",data)); 
    316                  return data; 
    317              } else {
    318                  OS_ENTER_CRITICAL(); 
    319                  for( ruler_id = 0 ; ruler_id < 4 ; ruler_id++ ) {       
    320                      if( Global_Ruler_State[ruler_id] ==  RULER_STATE_SELECTED ) {//given: if mic selected, then ruler used
    321                          Global_Ruler_State[ruler_id] = RULER_STATE_RUN;                 
    322                      }      
    323                  }
    324                  OS_EXIT_CRITICAL();  
    325                  
    326              }
    327              return 0 ;   
    328          }
    329          
    330          
    331          /*
    332          *********************************************************************************************************
    333          *                                           Stop_Audio()
    334          *
    335          * Description : Send command to stop USB audio play/record.
    336          * Argument(s) : None.
    337          * Return(s)   : NO_ERR :   execute successfully
    338          *               others :   refer to error code defines.           
    339          *
    340          * Note(s)     : None.
    341          *********************************************************************************************************
    342          */
    343          unsigned char Stop_Audio( void )
    344          {  
    345              unsigned char err   = 0xFF;  
    346              unsigned char data  = 0xFF; 
    347              unsigned char ruler_id;     
    348              unsigned char buf[] = { CMD_DATA_SYNC1, CMD_DATA_SYNC2, RULER_CMD_STOP_AUDIO };
    349              
    350          #if OS_CRITICAL_METHOD == 3u
    351              OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    352          #endif 
    353              APP_TRACE_INFO(("Stop_Audio\r\n"));
    354              UART2_Mixer(3); 
    355              USART_SendBuf( AUDIO_UART, buf,  sizeof(buf)) ;    
    356              err = USART_Read_Timeout( AUDIO_UART, &data, 1, TIMEOUT_AUDIO_COM); 
    357              if( err != NO_ERR ) { 
    358                  APP_TRACE_INFO(("\r\nStop_Audio ERROR: timeout\r\n")); 
    359                  return err;
    360              }
    361              if( data != NO_ERR ) {
    362                  APP_TRACE_INFO(("\r\nStop_Audio ERROR: %d\r\n ",data)); 
    363                  return data; 
    364              } 
    365             
    366              err = Init_CODEC( 0 );
    367              if( err != NO_ERR ) {
    368                  APP_TRACE_INFO(("\r\nStop_Audio Power Down CODEC ERROR: %d\r\n",err)); 
    369              }
    370              
    371              OS_ENTER_CRITICAL(); 
    372              for( ruler_id = 0 ; ruler_id < 4 ; ruler_id++ ) {       
    373                  if( Global_Ruler_State[ruler_id] ==  RULER_STATE_RUN ) {//given: if mic selected, then ruler used
    374                      Global_Ruler_State[ruler_id] = RULER_STATE_SELECTED;            
    375                  }                   
    376              }
    377              OS_EXIT_CRITICAL();
    378                
    379          //clear mic toggle after each audio stop to avoid issues in scripts test using USBTEST.exe
    380          #ifdef FOR_USE_USBTEST_EXE    
    381              for( ruler_id = 0; ruler_id < 4; ruler_id++ ) {
    382                  Global_Mic_Mask[ruler_id] = 0 ;
    383              }
    384          #endif
    385              
    386              return 0 ;    
    387          }
    388          
    389          
    390          /*
    391          *********************************************************************************************************
    392          *                                           Reset_Audio()
    393          *
    394          * Description : Send command to reset USB audio data stream.
    395          * Argument(s) : None.
    396          * Return(s)   : NO_ERR :   execute successfully
    397          *               others :   refer to error code defines.           
    398          *
    399          * Note(s)     : None.
    400          *********************************************************************************************************
    401          */
    402          unsigned char Reset_Audio( void )
    403          {  
    404              unsigned char err   = 0xFF;  
    405              unsigned char data  = 0xFF;    
    406              unsigned char buf[] = { CMD_DATA_SYNC1, CMD_DATA_SYNC2, RULER_CMD_RESET_AUDIO };
    407              
    408              APP_TRACE_INFO(("Reset_Audio\r\n"));
    409              UART2_Mixer(3); 
    410              USART_SendBuf( AUDIO_UART, buf,  sizeof(buf)) ;    
    411              err = USART_Read_Timeout( AUDIO_UART, &data, 1, TIMEOUT_AUDIO_COM); 
    412              if( err != NO_ERR ) { 
    413                  APP_TRACE_INFO(("\r\nReset_Audio ERROR: timeout\r\n")); 
    414                  return err;
    415              }
    416              if( data != NO_ERR ) {
    417                  APP_TRACE_INFO(("\r\nReset_Audio ERROR: %d\r\n ",data)); 
    418                  return data; 
    419              } 
    420               
    421              return 0 ;    
    422          }
    423          
    424          
    425          /*
    426          *********************************************************************************************************
    427          *                                       Get_Audio_Version()
    428          *
    429          * Description : Get USB audio MCU firmware version info, and stored in a global variable.
    430          * Argument(s) : None.
    431          * Return(s)   : NO_ERR :   execute successfully
    432          *               others :   refer to error code defines.           
    433          *
    434          * Note(s)     : None.
    435          *********************************************************************************************************
    436          */
    437          unsigned char Get_Audio_Version( void )
    438          {  
    439              unsigned char err;      
    440              unsigned char buf[] = { CMD_DATA_SYNC1, CMD_DATA_SYNC2, RULER_CMD_GET_AUDIO_VERSION };
    441             
    442              UART2_Mixer(3); 
    443              USART_SendBuf( AUDIO_UART, buf,  sizeof(buf)) ;    
    444              err = USART_Read_Timeout( AUDIO_UART, &Audio_Version, sizeof(Audio_Version), TIMEOUT_AUDIO_COM); 
    445              if( err != NO_ERR ) { 
    446                  APP_TRACE_INFO(("\r\nGet_Audio_Version ERROR: timeout\r\n")); 
    447                  return err;        
    448              } else {        
    449                  APP_TRACE_INFO(("\r\nUSB Audio FW Version: %s\r\n ",Audio_Version));
    450              }     
    451              return 0 ;   
    452          }
    453          
    454          
    455          
    456          
    457          
    458          /*
    459          *********************************************************************************************************
    460          *                                       Init_Ruler()
    461          *
    462          * Description : Communicate with ruler to check connected or not
    463          *    
    464          * Argument(s) : ruler_slot_id: 0~ 3.
    465          * Return(s)   : NO_ERR :   ruler connected
    466          *               others :   =error code . ruler connection error,           
    467          *
    468          * Note(s)     : None.
    469          *********************************************************************************************************
    470          */
    471          unsigned char Init_Ruler( unsigned char ruler_slot_id ) //0 ~ 3
    472          {
    473              unsigned char err ;
    474          
    475          #if OS_CRITICAL_METHOD == 3u
    476              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    477          #endif 
    478                
    479              //check ruler connection state 
    480              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
    481                  return RULER_STATE_ERR ;         
    482              } 
    483              OSSemPend( UART_MUX_Sem_lock, 0, &err );
    484              if( Global_Ruler_Index != ruler_slot_id ) {
    485                  Check_UART_Mixer_Ready();
    486                  //OS_ENTER_CRITICAL(); 
    487                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    488                  //OS_EXIT_CRITICAL();  
    489                  UART1_Mixer( ruler_slot_id );
    490              } 
    491              
    492              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_EST, NULL, 0, 0, NULL, 0 ) ; 
    493              if( OS_ERR_NONE == err ) {
    494                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    495                  if( OS_ERR_TIMEOUT == err ) {
    496                      APP_TRACE_INFO(("Init ruler[%d] timeout!\r\n",ruler_slot_id));            
    497                  } else {
    498                      err = Ruler_CMD_Result; //exe result from GACK
    499                      if(OS_ERR_NONE != err ){
    500                          APP_TRACE_INFO(("Init_Ruler[%d] err = %d\r\n",ruler_slot_id,err));
    501                      }
    502                  }
    503                  
    504              } else {
    505                  APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_slot_id,err));        
    506              }    
    507              OSSemPost( UART_MUX_Sem_lock );    
    508              return err ;    
    509          }
    510                          
    511          
    512          /*
    513          *********************************************************************************************************
    514          *                                       Setup_Ruler()
    515          *
    516          * Description : Send ruler slot id to ruler for identification.
    517          *             
    518          * Argument(s) : ruler_slot_id: 0~ 3.
    519          * Return(s)   : NO_ERR :   execute successfully
    520          *               others :   =error code . ruler connection error,           
    521          *
    522          * Note(s)     : None.
    523          *********************************************************************************************************
    524          */
    525          unsigned char Setup_Ruler( unsigned char ruler_slot_id ) //0 ~ 3
    526          {    
    527              unsigned char err ;
    528              EMB_BUF        *pEBuf_Data; 
    529              unsigned char buf[] = { RULER_CMD_SET_RULER, ruler_slot_id };
    530              
    531          #if OS_CRITICAL_METHOD == 3u
    532              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    533          #endif 
    534              
    535              pEBuf_Data  = &Emb_Buf_Data; //Golbal var
    536              //check ruler connection state 
    537              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
    538                  return RULER_STATE_ERR ;         
    539              } 
    540              
    541              OSSemPend( UART_MUX_Sem_lock, 0, &err );
    542              if( Global_Ruler_Index != ruler_slot_id ) {
    543                  Check_UART_Mixer_Ready();
    544                  //OS_ENTER_CRITICAL(); 
    545                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    546                  //OS_EXIT_CRITICAL();  
    547                  UART1_Mixer( ruler_slot_id );
    548              }
    549              
    550              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    551              if( OS_ERR_NONE == err ) {
    552                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    553                  if( OS_ERR_TIMEOUT == err ) {
    554                      APP_TRACE_INFO(("Setup_Ruler[%d] timeout\r\n",ruler_slot_id));
    555                  } else {            
    556                      Ruler_Setup_Sync_Data = pEBuf_Data->data[0] ;
    557                      APP_TRACE_INFO(("Get Ruler_Setup_Sync_Data : 0x%X\r\n",Ruler_Setup_Sync_Data));
    558                      err = Ruler_CMD_Result; //exe result from GACK
    559                      if(OS_ERR_NONE != err ){
    560                          APP_TRACE_INFO(("Setup_Ruler[%d] err = %d\r\n",ruler_slot_id,err));
    561                      }
    562                  }
    563                  
    564              } else {
    565                  APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_slot_id,err));
    566              }    
    567              OSSemPost( UART_MUX_Sem_lock );    
    568              return err ;    
    569          }
    570          
    571          
    572          /*
    573          *********************************************************************************************************
    574          *                                       Get_Ruler_Type()
    575          *
    576          * Description : Get the specified ruler's type, and stored in a global variable, in which
    577          *               bit7: 0-ruler, 1- handset. Other bits reserved.
    578          * Argument(s) : ruler_slot_id: 0~ 3.
    579          * Return(s)   : NO_ERR :   execute successfully
    580          *               others :   refer to error code defines.           
    581          *
    582          * Note(s)     : None.
    583          *********************************************************************************************************
    584          */
    585          unsigned char Get_Ruler_Type(  unsigned char ruler_slot_id )
    586          {  
    587              unsigned char err ;
    588              EMB_BUF        *pEBuf_Data; 
    589              unsigned char buf[] = { RULER_CMD_GET_RULER_TYPE };
    590              
    591          #if OS_CRITICAL_METHOD == 3u
    592              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    593          #endif 
    594              
    595              pEBuf_Data  = &Emb_Buf_Data; //Golbal var
    596              //check ruler connection state 
    597              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
    598                  return RULER_STATE_ERR ;         
    599              } 
    600          
    601              OSSemPend( UART_MUX_Sem_lock, 0, &err ); 
    602              if( Global_Ruler_Index != ruler_slot_id ) {
    603                  Check_UART_Mixer_Ready();
    604                  //OS_ENTER_CRITICAL(); 
    605                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    606                  //OS_EXIT_CRITICAL();  
    607                  UART1_Mixer( ruler_slot_id );
    608              }
    609              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    610              if( OS_ERR_NONE == err ) {
    611                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    612                  if( OS_ERR_TIMEOUT == err ) {
    613                      APP_TRACE_INFO(("Read_Ruler_Type[%d] timeout\r\n",ruler_slot_id));
    614                  } else {
    615                      Global_Ruler_Type[ruler_slot_id] =  pEBuf_Data->data[0] ;
    616                      err = Ruler_CMD_Result; //exe result from GACK 
    617                      if(OS_ERR_NONE != err ){
    618                          APP_TRACE_INFO(("Get_Ruler_Type[%d] err = %d\r\n",ruler_slot_id,err));
    619                      }
    620                  }          
    621                  
    622              } else {
    623                  APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_slot_id,err));        
    624              }       
    625              OSSemPost( UART_MUX_Sem_lock );    
    626              return err ;    
    627          }
    628          
    629          
    630          /*
    631          *********************************************************************************************************
    632          *                                       Read_Ruler_Status()
    633          *
    634          * Description : Get back specified ruler's POST status.
    635          *             
    636          * Argument(s) : ruler_slot_id: 0~ 3.
    637          *               status_data:   pointer to the address that store the read status data 
    638          * Return(s)   : NO_ERR :   execute successfully
    639          *               others :   =error code .           
    640          *
    641          * Note(s)     : None.
    642          *********************************************************************************************************
    643          */
    644          unsigned char Read_Ruler_Status( unsigned char ruler_slot_id, unsigned short *status_data )
    645          {    
    646              unsigned char err ;
    647              EMB_BUF        *pEBuf_Data; 
    648              unsigned char buf[] = { RULER_CMD_RAED_RULER_STATUS };
    649              
    650          #if OS_CRITICAL_METHOD == 3u
    651              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    652          #endif 
    653              
    654              pEBuf_Data  = &Emb_Buf_Data; //Golbal var
    655              //check ruler connection state 
    656              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
    657                  return RULER_STATE_ERR ;         
    658              } 
    659              OSSemPend( UART_MUX_Sem_lock, 0, &err ); 
    660              if( Global_Ruler_Index != ruler_slot_id ) {
    661                  Check_UART_Mixer_Ready();
    662                  //OS_ENTER_CRITICAL(); 
    663                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    664                  //OS_EXIT_CRITICAL();  
    665                  UART1_Mixer( ruler_slot_id );
    666              }
    667              
    668              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    669              if( OS_ERR_NONE == err ) {
    670                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    671                  if( OS_ERR_TIMEOUT == err ) {
    672                      APP_TRACE_INFO(("Read_Ruler_Status[%d] timeout\r\n",ruler_slot_id));
    673                  } else {
    674                      *status_data = (pEBuf_Data->data[1] << 8) + pEBuf_Data->data[0] ;       
    675                      err = Ruler_CMD_Result; //exe result from GACK
    676                      if(OS_ERR_NONE != err ){
    677                          APP_TRACE_INFO(("Read_Ruler_Status[%d] err = %d\r\n",ruler_slot_id,err));
    678                      } 
    679                  }   
    680                  
    681              } else {
    682                  APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_slot_id,err));
    683              }        
    684              OSSemPost( UART_MUX_Sem_lock );    
    685              return err ;    
    686          }
    687          
    688          
    689          /*
    690          *********************************************************************************************************
    691          *                                       Read_Ruler_Info()
    692          *
    693          * Description : Get back specified ruler's infomation data.
    694          *               And the read back data is stored in global varies : Emb_Buf_Data
    695          * Argument(s) : ruler_slot_id: 0~ 3.
    696          * Return(s)   : NO_ERR :   execute successfully
    697          *               others :   =error code . ruler connection error,           
    698          *
    699          * Note(s)     : None.
    700          *********************************************************************************************************
    701          */
    702          unsigned char Read_Ruler_Info( unsigned char ruler_slot_id )
    703          {    
    704              unsigned char  err ; 
    705              unsigned char  buf[] = { RULER_CMD_RAED_RULER_INFO }; 
    706              
    707          #if OS_CRITICAL_METHOD == 3u
    708              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    709          #endif 
    710           
    711              //check ruler connection state 
    712              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_CONFIGURED ) {      
    713                  return RULER_STATE_ERR ;         
    714              }    
    715              OSSemPend( UART_MUX_Sem_lock, 0, &err );  
    716              if( Global_Ruler_Index != ruler_slot_id ) {
    717                  Check_UART_Mixer_Ready();
    718                  //OS_ENTER_CRITICAL(); 
    719                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    720                  //OS_EXIT_CRITICAL();  
    721                  UART1_Mixer( ruler_slot_id );
    722              }
    723              
    724              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    725              if( OS_ERR_NONE == err ) {
    726                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    727                  if( OS_ERR_TIMEOUT == err ) {
    728                      APP_TRACE_INFO(("Read_Ruler_Info[%d] timeout\r\n",ruler_slot_id));
    729                  } else {
    730                      err = Ruler_CMD_Result;
    731                      if(OS_ERR_NONE != err ){
    732                          APP_TRACE_INFO(("Read_Ruler_Info[%d] err = %d\r\n",ruler_slot_id,err));
    733                      }
    734                  }
    735                  
    736              } else {
    737                  APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_slot_id,err));
    738              }    
    739              OSSemPost( UART_MUX_Sem_lock );    
    740              return err ;    
    741          }
    742          
    743          
    744          /*
    745          *********************************************************************************************************
    746          *                                       Write_Ruler_Info()
    747          *
    748          * Description : Write infomation data to specified ruler.
    749          *               And before this function is called, the data to be written need have been stored in global varies : Emb_Buf_Cmd
    750          * Argument(s) : ruler_slot_id: 0~ 3.
    751          * Return(s)   : NO_ERR :   execute successfully
    752          *               others :   =error code .       
    753          *
    754          * Note(s)     : None.
    755          *********************************************************************************************************
    756          */
    757          unsigned char Write_Ruler_Info( unsigned char ruler_slot_id )
    758          {
    759              unsigned char   err;
    760              unsigned short  data_length;
    761              unsigned char   temp;
    762              unsigned char  *pdata;
    763              unsigned char   buf[4];  
    764              EMB_BUF        *pEBuf_Cmd;        
    765            
    766           #if OS_CRITICAL_METHOD == 3u
    767              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    768          #endif 
    769              
    770              pEBuf_Cmd  = &Emb_Buf_Cmd; //Golbal var
    771              buf[0] =  RULER_CMD_WRITE_RULER_INFO;
    772              buf[1] =  EMB_DATA_FRAME;  
    773              buf[2] = (pEBuf_Cmd->length) & 0xFF;    
    774              buf[3] = ((pEBuf_Cmd->length)>>8) & 0xFF;     
    775          
    776              //check ruler connection state 
    777              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_CONFIGURED ) {      
    778                  return RULER_STATE_ERR ;         
    779              } 
    780              OSSemPend( UART_MUX_Sem_lock, 0, &err );    
    781              if( Global_Ruler_Index != ruler_slot_id ) {
    782                  Check_UART_Mixer_Ready();
    783                  //OS_ENTER_CRITICAL(); 
    784                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    785                  //OS_EXIT_CRITICAL();  
    786                  UART1_Mixer( ruler_slot_id );
    787              }  
    788              
    789              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    790              if( OS_ERR_NONE != err ) { return err ; }
    791              pdata = pEBuf_Cmd->data;
    792              data_length = pEBuf_Cmd->length;
    793              while( data_length > 0 ){ 
    794                  temp = data_length > (NOAH_CMD_DATA_MLEN-1) ? (NOAH_CMD_DATA_MLEN-1) : data_length ;  
    795                  err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, pdata, temp, 0, buf, 1 ) ; 
    796                  if( OS_ERR_NONE != err ) { break;}
    797                  OSTimeDly(50); //wait for ruler operation
    798                  data_length -= temp;
    799                  pdata += temp;
    800              }
    801              if( OS_ERR_NONE == err ) {
    802                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    803                  if( OS_ERR_TIMEOUT == err ) {
    804                      APP_TRACE_INFO(("Write_Ruler_Info[%d] timeout\r\n",ruler_slot_id));
    805                  } else {
    806                      err = Ruler_CMD_Result; //exe result from GACK
    807                      if(OS_ERR_NONE != err ){
    808                          APP_TRACE_INFO(("Write_Ruler_Info[%d] err = %d\r\n",ruler_slot_id,err));
    809                      }
    810                  }
    811                  
    812              } else {
    813                  APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_slot_id,err));
    814              }
    815              OSSemPost( UART_MUX_Sem_lock );
    816              
    817              return err ;
    818              
    819          }
    820          
    821          
    822          /*
    823          *********************************************************************************************************
    824          *                                       Read_Mic_Cali_Data()
    825          *
    826          * Description : Get back specified ruler specified mic's calibration data.
    827          *               And the read back data is stored in global varies : Emb_Buf_Data
    828          * Argument(s) : ruler_slot_id : 0~ 3.
    829          *               mic_id        : 0~ 7
    830          * Return(s)   : NO_ERR :   execute successfully
    831          *               others :   =error code .  
    832          *
    833          * Note(s)     : None.
    834          *********************************************************************************************************
    835          */
    836          unsigned char Read_Mic_Cali_Data(unsigned char ruler_slot_id, unsigned char mic_id)
    837          {    
    838              unsigned char  err ; 
    839              unsigned char  buf[] = { RULER_CMD_READ_MIC_CALI_DATA, mic_id }; 
    840              
    841          #if OS_CRITICAL_METHOD == 3u
    842              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    843          #endif 
    844           
    845              //check ruler connection state 
    846              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_CONFIGURED ) {      
    847                  return RULER_STATE_ERR ;         
    848              }   
    849             
    850              OSSemPend( UART_MUX_Sem_lock, 0, &err );   
    851              if( Global_Ruler_Index != ruler_slot_id ) {
    852                  Check_UART_Mixer_Ready();
    853                  //OS_ENTER_CRITICAL(); 
    854                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    855                  //OS_EXIT_CRITICAL();  
    856                  UART1_Mixer( ruler_slot_id );
    857              }
    858              
    859              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    860              if( OS_ERR_NONE == err ) {
    861                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    862                  if( OS_ERR_TIMEOUT == err ) {
    863                      APP_TRACE_INFO(("Read_Mic_Cali_Data[%d] timeout\r\n",ruler_slot_id));
    864                  } else {
    865                      err = Ruler_CMD_Result; 
    866                      if(OS_ERR_NONE != err ){
    867                          APP_TRACE_INFO(("Read_Mic_Cali_Data[%d] err = %d\r\n",ruler_slot_id,err));
    868                      }
    869                  }
    870                  
    871              } else {
    872                  APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_slot_id,err));
    873              }      
    874              OSSemPost( UART_MUX_Sem_lock );    
    875              return err ;    
    876          }
    877          
    878          
    879          /*
    880          *********************************************************************************************************
    881          *                                       Write_Mic_Cali_Data()
    882          *
    883          * Description : Write calibration data to specified ruler specified mic.
    884          *               And before this function is called, the data to be written need have been stored in global varies : Emb_Buf_Cmd
    885          * Argument(s) : ruler_slot_id : 0~ 3.
    886          *               mic_id        : 0~ 7
    887          * Return(s)   : NO_ERR :   execute successfully
    888          *               others :   =error code .    
    889          *
    890          * Note(s)     : None.
    891          *********************************************************************************************************
    892          */
    893          unsigned char Write_Mic_Cali_Data(unsigned char ruler_slot_id, unsigned char mic_id)
    894          {    
    895              unsigned char   err;
    896              unsigned short  data_length;
    897              unsigned char   temp;
    898              unsigned char  *pdata;
    899              unsigned char   buf[5];  
    900              EMB_BUF        *pEBuf_Cmd;        
    901            
    902           #if OS_CRITICAL_METHOD == 3u
    903              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    904          #endif 
    905              
    906              pEBuf_Cmd  = &Emb_Buf_Cmd; //Golbal var
    907              buf[0] =  RULER_CMD_WRITE_MIC_CALI_DATA; 
    908              buf[1] =  mic_id;  
    909              buf[2] =  EMB_DATA_FRAME;  
    910              buf[3] = (pEBuf_Cmd->length) & 0xFF;    
    911              buf[4] = ((pEBuf_Cmd->length)>>8) & 0xFF;     
    912          
    913              //check ruler connection state 
    914              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_CONFIGURED ) {      
    915                  return RULER_STATE_ERR ;         
    916              } 
    917              OSSemPend( UART_MUX_Sem_lock, 0, &err ); 
    918              if( Global_Ruler_Index != ruler_slot_id ) {
    919                  Check_UART_Mixer_Ready();
    920                  //OS_ENTER_CRITICAL(); 
    921                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    922                  //OS_EXIT_CRITICAL();  
    923                  UART1_Mixer( ruler_slot_id );
    924              } 
    925              
    926              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    927              if( OS_ERR_NONE != err ) { return err ; }
    928              pdata = pEBuf_Cmd->data;
    929              data_length = pEBuf_Cmd->length;
    930              while( data_length > 0 ){ 
    931                  temp = data_length > (NOAH_CMD_DATA_MLEN-2) ? (NOAH_CMD_DATA_MLEN-2) : data_length ;  
    932                  err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, pdata, temp, 0, buf, 2 ) ; 
    933                  if( OS_ERR_NONE != err ) { break;}
    934                  OSTimeDly(50); //wait for ruler operation       
    935                  data_length -= temp;
    936                  pdata += temp;        
    937              }
    938              if( OS_ERR_NONE == err ) {
    939                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    940                  if( OS_ERR_TIMEOUT == err ) {
    941                      APP_TRACE_INFO(("Write_Mic_Cali_Data[%d][%d] timeout\r\n",ruler_slot_id, mic_id));
    942                  } else {
    943                      err = Ruler_CMD_Result; //exe result from GACK
    944                      if(OS_ERR_NONE != err ){
    945                          APP_TRACE_INFO(("Write_Mic_Cali_Data[%d] err = %d\r\n",ruler_slot_id,err));
    946                      }
    947                  }
    948              } else {
    949                  APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_slot_id,err));
    950              }
    951              OSSemPost( UART_MUX_Sem_lock );
    952              
    953              return err ;
    954              
    955          }
    956          
    957          
    958          /*
    959          *********************************************************************************************************
    960          *                                       Update_Mic_Mask()
    961          *
    962          * Description : Update specified ruler's all mic's active state.
    963          * Argument(s) : ruler_slot_id : 0~ 3.
    964          *               mic_mask      : bit[0..31]. 0 - deactive, 1 - active.
    965          * Return(s)   : NO_ERR :   execute successfully
    966          *               others :   =error code .    
    967          *
    968          * Note(s)     : Support: Ruler(8Mic) for Ruler
    969          *                        Handset(16Mic) for H01/H02/H02A
    970          *                        Handset(18Mic) for H03
    971          *********************************************************************************************************
    972          */
    973          unsigned char Update_Mic_Mask( unsigned char ruler_slot_id, unsigned int mic_mask )
    974          {    
    975              unsigned char err ;
    976              unsigned char buf_size_send ;
    977              unsigned char buf[] = { RULER_CMD_TOGGLE_MIC, mic_mask&0xFF, (mic_mask>>8)&0xFF,
    978                                      (mic_mask>>16)&0xFF,  (mic_mask>>24)&0xFF };
    979              
    980          #if OS_CRITICAL_METHOD == 3u
    981              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    982          #endif 
    983              //check ruler connection state 
    984              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_CONFIGURED ) {      
    985                  return RULER_STATE_ERR ;         
    986              }  
    987              
    988              OSSemPend( UART_MUX_Sem_lock, 0, &err );  
    989              if( Global_Ruler_Index != ruler_slot_id ) {
    990                  Check_UART_Mixer_Ready();
    991                  //OS_ENTER_CRITICAL(); 
    992                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    993                  //OS_EXIT_CRITICAL();  
    994                  UART1_Mixer( ruler_slot_id );
    995              }
    996              if( Global_Ruler_Type[ruler_slot_id] == RULER_TYPE_H03 ) {
    997                  buf_size_send = 5; //H03 cmd data size = 1+4 for 16> mic
    998              } else {
    999                  buf_size_send = 3; //Default cmd data size = 1+2 for <16 mic
   1000              }
   1001              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, buf_size_send, 0, NULL, 0 ) ; 
   1002              if( OS_ERR_NONE == err ) {
   1003                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
   1004                  if( OS_ERR_TIMEOUT == err ) {
   1005                      APP_TRACE_INFO(("Update_Mic_Mask for Ruler[%d] timeout\r\n",ruler_slot_id));
   1006                  }
   1007                  
   1008              } else {
   1009                  APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_slot_id,err));
   1010              }
   1011              OSSemPost( UART_MUX_Sem_lock );    
   1012              return err ;    
   1013          }
   1014          
   1015          /*
   1016          *********************************************************************************************************
   1017          *                                       Ruler_Active_Control()
   1018          *
   1019          * Description : Active/Deactive ruler(LED)when play and record start/stop.  
   1020          * Argument(s) : active_state : 0 - deactive ruler (LED)
   1021          *                              1 - active ruler (LED).
   1022          * Return(s)   : NO_ERR :   execute successfully
   1023          *               others :   =error code .    
   1024          *
   1025          * Note(s)     : Support Ruler(8Mic) and Handset(16Mic)
   1026          *********************************************************************************************************
   1027          */
   1028          unsigned char Ruler_Active_Control( unsigned char active_state )  
   1029          {    
   1030              unsigned char err ;
   1031              unsigned char ruler_id;
   1032              unsigned char buf[] = { RULER_CMD_ACTIVE_CTR, active_state };
   1033          
   1034          #if OS_CRITICAL_METHOD == 3u
   1035              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
   1036          #endif 
   1037              
   1038              err = 0;        
   1039              
   1040              for( ruler_id = 0 ; ruler_id < 4 ; ruler_id++ ) {   
   1041                  //check ruler connection state 
   1042                  if( //RULER_TYPE_MASK(Global_Ruler_Type[ruler_id]) == RULER_TYPE_HANDSET ||
   1043                      Global_Ruler_State[ruler_id] < RULER_STATE_CONFIGURED || 
   1044                      Global_Mic_Mask[ruler_id] == 0 ) {      
   1045                      continue;       
   1046                  } 
   1047                  APP_TRACE_INFO(("Ruler[%d]_Active_Control : [%d]\r\n",ruler_id,active_state));      
   1048                  OSSemPend( UART_MUX_Sem_lock, 0, &err );
   1049                  if( Global_Ruler_Index != ruler_id ) {
   1050                      Check_UART_Mixer_Ready();
   1051                      //OS_ENTER_CRITICAL(); 
   1052                      Global_Ruler_Index = ruler_id ; //for ruler status switch in TX/RX/Noah 
   1053                      //OS_EXIT_CRITICAL();  
   1054                      UART1_Mixer( ruler_id );
   1055                  }   
   1056                  err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
   1057                  if( OS_ERR_NONE == err ) {
   1058                      OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
   1059                      if( OS_ERR_TIMEOUT == err ) {
   1060                          APP_TRACE_INFO(("Ruler[%d]_Active_Control timeout\r\n",ruler_id));
   1061                      } else {
   1062                          err = Ruler_CMD_Result; //exe result from GACK
   1063                          if(OS_ERR_NONE != err ){
   1064                              APP_TRACE_INFO(("Ruler[%d]_Active_Control err = %d\r\n",ruler_id,err));
   1065                          }
   1066                      }
   1067                      
   1068                  } else {
   1069                      APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_id,err));
   1070                  }    
   1071                  OSSemPost( UART_MUX_Sem_lock );
   1072                  if( err != NO_ERR ) {
   1073                      break;
   1074                  }
   1075              }        
   1076              return err ;    
   1077          }
   1078          
   1079          
   1080          /*
   1081          *********************************************************************************************************
   1082          *                                       Get_Ruler_Version()
   1083          *
   1084          * Description : Get back specified ruler's version info.
   1085          *               And the version data is stored in global varies : Emb_Buf_Data
   1086          * Argument(s) : ruler_slot_id : 0~ 3.
   1087          * Return(s)   : NO_ERR :   execute successfully
   1088          *               others :   =error code .  
   1089          *
   1090          * Note(s)     : None.
   1091          *********************************************************************************************************
   1092          */
   1093          unsigned char Get_Ruler_Version( unsigned char ruler_slot_id )
   1094          {  
   1095              unsigned char err ;
   1096              unsigned char buf[] = { RULER_CMD_GET_RULER_VERSION };
   1097              EMB_BUF      *pEBuf_Data;         
   1098                
   1099              pEBuf_Data  = &Emb_Buf_Data;  //Global var   
   1100              
   1101          #if OS_CRITICAL_METHOD == 3u
   1102              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
   1103          #endif 
   1104              //check ruler connection state 
   1105              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
   1106                  return RULER_STATE_ERR ;         
   1107              }  
   1108              
   1109              OSSemPend( UART_MUX_Sem_lock, 0, &err ); 
   1110              if( Global_Ruler_Index != ruler_slot_id ) {
   1111                  Check_UART_Mixer_Ready();
   1112                  //OS_ENTER_CRITICAL(); 
   1113                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
   1114                  //OS_EXIT_CRITICAL();  
   1115                  UART1_Mixer( ruler_slot_id );
   1116              }
   1117              
   1118              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
   1119              if( OS_ERR_NONE == err ) {
   1120                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
   1121                  if( OS_ERR_TIMEOUT == err ) {
   1122                      APP_TRACE_INFO(("Get_Ruler_Version[%d] timeout\r\n",ruler_slot_id));
   1123                  } else {
   1124                      err = Ruler_CMD_Result;
   1125                      if(OS_ERR_NONE != err ){
   1126                          APP_TRACE_INFO(("Get_Ruler_Version[%d] err = %d\r\n",ruler_slot_id,err));
   1127                      }
   1128                  }
   1129                  if(err == OS_ERR_NONE ) {
   1130                      APP_TRACE_INFO(("Ruler[%d] FW Version: %s\r\n",ruler_slot_id, pEBuf_Data->data)); 
   1131                  }
   1132                  
   1133              } else {
   1134                  APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_slot_id,err));
   1135              }    
   1136              OSSemPost( UART_MUX_Sem_lock );    
   1137              return err ;        
   1138          }
   1139            
   1140          
   1141          
   1142          /*
   1143          *********************************************************************************************************
   1144          *                                       FLASHD_Write_Safe()
   1145          *
   1146          * Description : Add code area protection for FLASHD_Write()
   1147          *               Writes a data buffer in the internal flash. This function works in polling
   1148          *               mode, and thus only returns when the data has been effectively written.    
   1149          * Argument(s) :  address  Write address.
   1150          *                pBuffer  Data buffer.
   1151          *                size     Size of data buffer in bytes.
   1152          * Return(s)   : NO_ERR :   execute successfully
   1153          *               others :   =error code .  
   1154          *
   1155          * Note(s)     : None.
   1156          *********************************************************************************************************
   1157          */
   1158          unsigned char FLASHD_Write_Safe( unsigned int address, const void *pBuffer,  unsigned int size)
   1159          {
   1160              unsigned char err;
   1161              if( address < AT91C_IFLASH + AT91C_IFLASH_CODE_SIZE ) {
   1162                  APP_TRACE_INFO(("ERROR: this operation wanna flush code area!\r\n"));  
   1163                  return FW_BIN_SAVE_ADDR_ERR;
   1164              }
   1165              err = FLASHD_Write(  address, pBuffer, size );
   1166              return err;  
   1167              
   1168          }
   1169          
   1170          
   1171          /*
   1172          *********************************************************************************************************
   1173          *                                       Read_Flash_State()
   1174          *
   1175          * Description : Save ruler FW bin file to flash
   1176          *               
   1177          * Argument(s) : *pFlash_Info : pointer to FLASH_INFO type data where to save read data
   1178          *
   1179          * Return(s)   : None.
   1180          *
   1181          * Note(s)     : None.
   1182          *********************************************************************************************************
   1183          */
   1184          void Read_Flash_State( FLASH_INFO  *pFlash_Info )
   1185          {
   1186              
   1187              *pFlash_Info = *(FLASH_INFO *)FLASH_ADDR_FW_STATE ;    
   1188              
   1189          }
   1190          
   1191          
   1192          /*
   1193          *********************************************************************************************************
   1194          *                                       Write_Flash_State()
   1195          *
   1196          * Description : Save ruler FW bin file to flash
   1197          *               
   1198          * Argument(s) : *pFlash_Info : pointer to FLASH_INFO type data need to be saved
   1199          *
   1200          * Return(s)   : NO_ERR :   execute successfully
   1201          *               others :   =error code .  
   1202          *
   1203          * Note(s)     : None.
   1204          *********************************************************************************************************
   1205          */
   1206          unsigned char Write_Flash_State( FLASH_INFO   *pFlash_Info )
   1207          {
   1208              
   1209              unsigned char err;   
   1210              //save state to flash
   1211              pFlash_Info->s_w_counter++ ;
   1212              err = FLASHD_Write_Safe( FLASH_ADDR_FW_STATE, pFlash_Info, AT91C_IFLASH_PAGE_SIZE); 
   1213              if(err != NO_ERR ) {                     
   1214                  APP_TRACE_INFO(("ERROR: Write flash state failed!\r\n"));  
   1215              }
   1216              
   1217              return err;
   1218              
   1219          }
   1220          
   1221          
   1222          /*
   1223          *********************************************************************************************************
   1224          *                                       Save_Ruler_FW()
   1225          *
   1226          * Description : Save ruler FW bin file to flash
   1227          *               
   1228          * Argument(s) :  cmd  :  1~ 3.
   1229          *               *pBin : pointer to bin file data packge to be wriiten to flash
   1230          *               *pStr : pointer to file name string
   1231          *                size : bin package file size 
   1232          *
   1233          * Return(s)   : NO_ERR :   execute successfully
   1234          *               others :   =error code .  
   1235          *
   1236          * Note(s)     : None.
   1237          *********************************************************************************************************
   1238          */
   1239          unsigned char Save_Ruler_FW( unsigned int cmd, unsigned char *pBin, unsigned char *pStr, unsigned int size )
   1240          {  
   1241              unsigned char err; 
   1242              static unsigned int flash_addr = FLASH_ADDR_FW_BIN;
   1243           
   1244              FLASH_INFO    flash_info;
   1245              
   1246              err = NO_ERR;
   1247              Read_Flash_State(&flash_info);
   1248               
   1249              switch( cmd ) {
   1250                  case FW_DOWNLAD_CMD_START :
   1251                      APP_TRACE_INFO(("Start loading ruler bin file to AB01 flash ... \r\n"));
   1252                      flash_addr = FLASH_ADDR_FW_BIN;                
   1253                      flash_info.f_w_state = FW_DOWNLAD_STATE_UNFINISHED ;
   1254                      flash_info.bin_size  = 0;
   1255                  break;   
   1256                  case FW_DOWNLAD_CMD_DOING :
   1257                      APP_TRACE_INFO(("> ")); 
   1258                      if( flash_info.f_w_state != FW_DOWNLAD_STATE_UNFINISHED ) {
   1259                          APP_TRACE_INFO(("ERROR: flash state not match!\r\n"));
   1260                          err  =  FW_BIN_STATE_0_ERR;                
   1261                      } 
   1262                  break;
   1263                  case FW_DOWNLAD_CMD_DONE :
   1264                      APP_TRACE_INFO((">\r\n")); 
   1265                      if( flash_info.f_w_state != FW_DOWNLAD_STATE_UNFINISHED ) {
   1266                          APP_TRACE_INFO(("ERROR: flash state not match!\r\n"));
   1267                          err  =  FW_BIN_STATE_1_ERR;
   1268                          break;
   1269                      }
   1270                      flash_info.f_w_state = FW_DOWNLAD_STATE_FINISHED ;
   1271                      flash_info.f_w_counter++;            
   1272                   break;
   1273                   
   1274                   default:
   1275                      APP_TRACE_INFO(("ERROR:  Save ruler FW bad cmd!\r\n"));
   1276                      err = FW_BIN_SAVE_CMD_ERR;    
   1277                   break;
   1278                  
   1279              }
   1280              if( err != NO_ERR ) {
   1281                  return err;
   1282              }    
   1283              Buzzer_OnOff(1);               
   1284              LED_Toggle(LED_DS2);    
   1285              err = FLASHD_Write_Safe( flash_addr, pBin, size ); 
   1286              Buzzer_OnOff(0); 
   1287              if(err != NO_ERR ) {                     
   1288                  APP_TRACE_INFO(("ERROR: Write MCU flash failed!\r\n"));
   1289                  return err;
   1290              }
   1291              flash_addr += size;
   1292              flash_info.bin_size   = flash_addr - FLASH_ADDR_FW_BIN ;
   1293              strcpy(flash_info.bin_name, (char const*)pStr);  
   1294              if( cmd != FW_DOWNLAD_CMD_DOING ) {        
   1295                  err = Write_Flash_State( &flash_info ); 
   1296                  if( err == NO_ERR && cmd == FW_DOWNLAD_CMD_DONE ) { 
   1297                        APP_TRACE_INFO(("Bin file[%d Btyes] saved successfully!\r\n",flash_info.bin_size));     
   1298                  }   
   1299              } 
   1300              return err;  
   1301              
   1302          }
   1303          
   1304          
   1305          
   1306          /*
   1307          *********************************************************************************************************
   1308          *                                       Update_Ruler_FW()
   1309          *
   1310          * Description :  Write firmware to specified ruler's MCU flash
   1311          *               
   1312          * Argument(s) :  ruler_slot_id :  0~ 3.     
   1313          *
   1314          * Return(s)   : NO_ERR :   execute successfully
   1315          *               others :   =error code .  
   1316          *
   1317          * Note(s)     : Do not care if ruler is attached or not.Because host can not detect ruler if FW was crashed.
   1318          *********************************************************************************************************
   1319          */
   1320          unsigned char Update_Ruler_FW( unsigned char ruler_slot_id )
   1321          {
   1322              unsigned char err;
   1323              unsigned int  flash_addr; 
   1324              FLASH_INFO   *pFlash_Info;
   1325              unsigned char Buf[9];
   1326              unsigned char i;
   1327              
   1328              err = NO_ERR;
   1329              flash_addr  = FLASH_ADDR_FW_BIN;
   1330              pFlash_Info = (FLASH_INFO *)FLASH_ADDR_FW_STATE ;
   1331                  
   1332              if( pFlash_Info->f_w_state != FW_DOWNLAD_STATE_FINISHED ) {
   1333                  APP_TRACE_INFO(("ERROR: FW bin file missed!\r\n"));        
   1334                  return FW_BIN_STATE_ERR;
   1335              }
   1336              
   1337              APP_TRACE_INFO(("Start updating ruler[%d] firmware to \"%s\" version ...\r\n",ruler_slot_id,pFlash_Info->bin_name)); 
   1338              memset(Buf,'d',sizeof(Buf)); //send 'd' to start download  
   1339              Ruler_Power_Switch(0);   //power off ruler  
   1340              OSTimeDly(200);   
   1341              for( i = 0; i < 4; i++ ) {
   1342                  Global_Ruler_State[i] = RULER_STATE_DETACHED ;
   1343              }
   1344              UART_Init(RULER_UART,  NULL,  115200 );   //Init Ruler to inquire mode
   1345              Port_Detect_Enable(0); //disable ruler detect
   1346              
   1347              OSSemPend( UART_MUX_Sem_lock, 0, &err ); 
   1348              if( Global_Ruler_Index != ruler_slot_id ) {
   1349                  Check_UART_Mixer_Ready();
   1350                  //OS_ENTER_CRITICAL(); 
   1351                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
   1352                  //OS_EXIT_CRITICAL();  
   1353                  UART1_Mixer( ruler_slot_id );
   1354              }
   1355              
   1356              Ruler_Power_Switch(1);   //power on ruler
   1357              OSTimeDly(200);
   1358              err = USART_SendBuf( RULER_UART, Buf,  sizeof(Buf));
   1359              if( OS_ERR_NONE == err ) {     
   1360                  OSTimeDly(800);
   1361                  err = USART_Read_Timeout( RULER_UART, Buf, 3, 5000 );
   1362                  if( OS_ERR_NONE == err && ( Buf[0] == 'c' || Buf[0] == 'C' )) {
   1363                      Global_Ruler_State[ruler_slot_id] = RULER_STATE_RUN ;
   1364                      err = Xmodem_Transmit( (unsigned char *)flash_addr, pFlash_Info->bin_size );
   1365                      Global_Ruler_State[ruler_slot_id] = RULER_STATE_DETACHED ;            
   1366                  }         
   1367              }
   1368              if( OS_ERR_NONE != err ) {
   1369                  APP_TRACE_INFO(("\r\nFailed to init ruler bootloader. Err Code = [0x%X]\r\n", err));        
   1370              } else {
   1371                  APP_TRACE_INFO(("\r\nUpdate ruler[%d] firmware successfully!\r\n", ruler_slot_id));   
   1372              }
   1373              Port_Detect_Enable(1); //enable ruler detect
   1374              UART_Init(RULER_UART,  ISR_Ruler_UART,  115200 );  //Init Ruler back to interuption mode
   1375              Ruler_Power_Switch(0);   //power off ruler  
   1376              OSTimeDly(500);    
   1377              Ruler_Power_Switch(1);   //power on ruler
   1378              OSSemPost( UART_MUX_Sem_lock ); 
   1379              return err ;    
   1380              
   1381          }
   1382          //unsigned char Update_Ruler_FW( unsigned char ruler_slot_id )
   1383          //{
   1384          //    unsigned char err;
   1385          //    unsigned int  flash_addr; 
   1386          //    FLASH_INFO   *pFlash_Info;
   1387          //    
   1388          //    err = NO_ERR;
   1389          //    flash_addr  = FLASH_ADDR_FW_BIN;
   1390          //    pFlash_Info = (FLASH_INFO *)FLASH_ADDR_FW_STATE ;
   1391          //        
   1392          //    if( pFlash_Info->f_w_state != FW_DOWNLAD_STATE_FINISHED ) {
   1393          //        APP_TRACE_INFO(("ERROR: FW bin file missed!\r\n"));        
   1394          //        return FW_BIN_STATE_ERR;
   1395          //    }
   1396          //    
   1397          //    APP_TRACE_INFO(("Start updating MCU FW to [%s] on ruler[%d]...\r\n",pFlash_Info->bin_name,ruler_slot_id)); 
   1398          //    
   1399          //    UART_Init(RULER_UART,  NULL,  115200 );    //Init Ruler as no ISR  
   1400          //    
   1401          //    UART1_Mixer( ruler_slot_id );
   1402          //    Check_UART_Mixer_Ready();
   1403          //    if( USART_Start_Ruler_Bootloader() ) {  
   1404          //        APP_TRACE_INFO(("Failed to init ruler bootloader!\r\n"));     
   1405          //    }
   1406          //    
   1407          //    err = Xmodem_Transmit( (unsigned char *)flash_addr, pFlash_Info->bin_size);      
   1408          //         
   1409          //    UART_Init(RULER_UART,  ISR_Ruler_UART,  115200 );    //Init Ruler back to ISR 
   1410          //    
   1411          //    return err ;    
   1412          //    
   1413          //}
   1414          
   1415          
   1416          /*
   1417          *********************************************************************************************************
   1418          *                                       Toggle_Mic()
   1419          *
   1420          * Description : Toggle specified mic's active state by sending command to related ruler and updating 
   1421          *               FPGA mic signal switch array. 
   1422          *               One mic One time.
   1423          * Argument(s) : pdata : pointer to TOGGLE_MIC structure data
   1424          * Return(s)   : NO_ERR :   execute successfully
   1425          *               others :   =error code .  
   1426          *
   1427          * Note(s)     : None.
   1428          *********************************************************************************************************
   1429          */
   1430          unsigned char Toggle_Mic(  TOGGLE_MIC *pdata )
   1431          {  
   1432              unsigned char  err ;
   1433              unsigned char  id;
   1434              unsigned int   mic_mask;  
   1435              unsigned int   fpga_mask;
   1436              
   1437          #if OS_CRITICAL_METHOD == 3u
   1438              OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
   1439          #endif 
   1440              fpga_mask = 0;
   1441              //check ruler connection state 
   1442              if( Global_Ruler_State[pdata->ruler_id] < RULER_STATE_CONFIGURED ) {      
   1443                  return RULER_STATE_ERR ;         
   1444              }  
   1445              APP_TRACE_INFO(("Toggle Ruler[%d]-Mic[%d] : %d  : ", pdata->ruler_id, pdata->mic_id, pdata->on_off )); 
   1446              OS_ENTER_CRITICAL(); 
   1447              mic_mask = Global_Mic_Mask[pdata->ruler_id];
   1448              OS_EXIT_CRITICAL();  
   1449              mic_mask &= ~( 1<<(pdata->mic_id));
   1450              mic_mask |=  (pdata->on_off&0x01)<<( pdata->mic_id);
   1451              err = Update_Mic_Mask( pdata->ruler_id, mic_mask );
   1452              APP_TRACE_INFO((" %s [0x%X]\r\n", err == OS_ERR_NONE ? "OK" : "FAIL" , err )); 
   1453              if( OS_ERR_NONE != err ) {        
   1454                  return err;    
   1455              }
   1456              OS_ENTER_CRITICAL(); 
   1457              Global_Mic_Mask[pdata->ruler_id] = mic_mask; 
   1458              //APP_TRACE_INFO(("Update Ruler[%d] Mic_Mask:  %d\r\n",pdata->ruler_id,Global_Mic_Mask[pdata->ruler_id]));   
   1459              if( mic_mask == 0 ) {      
   1460                  Global_Ruler_State[pdata->ruler_id] = RULER_STATE_CONFIGURED;         
   1461              } else {
   1462                  Global_Ruler_State[pdata->ruler_id] = RULER_STATE_SELECTED;  
   1463              }
   1464              OS_EXIT_CRITICAL();
   1465              if( RULER_TYPE_MASK( Global_Ruler_Type[pdata->ruler_id] ) == RULER_TYPE_RULER ) { //ruler
   1466                  for( id = 0; id < 4; id++ ) {
   1467                      fpga_mask += (Global_Mic_Mask[id]&0xFF) << (id<<3);
   1468                  }
   1469              } else { //handset
   1470                 fpga_mask = 0x3F << ((pdata->ruler_id)<<3);
   1471              }
   1472              Init_FPGA(fpga_mask);
   1473              return err;  
   1474          }
   1475          
   1476          
   1477          /*
   1478          *********************************************************************************************************
   1479          *                                       Set_Volume()
   1480          *
   1481          * Description : Set DMIC PGA gain, LOUT and SPKOUT attenuation gain at the same time
   1482          *             
   1483          * Argument(s) : pdata : pointer to SET_VOLUME structure data
   1484          * Return(s)   : NO_ERR :   execute successfully
   1485          *               others :   =error code .  
   1486          *
   1487          * Note(s)     : None.
   1488          *********************************************************************************************************
   1489          */
   1490          unsigned char Set_Volume(  SET_VOLUME *pdata )
   1491          {  
   1492              unsigned char  err ;
   1493              
   1494              APP_TRACE_INFO(( "Set Volume :: " ));
   1495              if( pdata->mic == SET_VOLUME_MUTE ) {
   1496                  APP_TRACE_INFO(( "Mute MIC :  " ));
   1497              } else {
   1498                  APP_TRACE_INFO(( "Mic_Gain = %d dB :  ", pdata->mic )); 
   1499              }
   1500              
   1501              if( pdata->lout == SET_VOLUME_MUTE ) {
   1502                  APP_TRACE_INFO(( "Mute LOUT :  " ));
   1503              } else {
   1504                  APP_TRACE_INFO(( "LOUT_Gain = -%d.%d dB :  ", pdata->lout/10, pdata->lout%10 )); 
   1505              }
   1506              
   1507              if( pdata->spk == SET_VOLUME_MUTE ) {
   1508                  APP_TRACE_INFO(( "Mute SPK :  " ));
   1509              } else {
   1510                  APP_TRACE_INFO(( "SPK_Gain = -%d.%d dB :  ", pdata->spk/10, pdata->spk%10 )); 
   1511              }
   1512              
   1513              //APP_TRACE_INFO(("Set Volume : Mic_Gain[%d]dB, LOUT_Gain[-%d.%d]dB, SPKOUT_Gain[-%d.%d]dB : ", 
   1514              //                     pdata->mic, pdata->lout/10, pdata->lout%10, pdata->spk/10, pdata->spk%10 )); 
   1515              //APP_TRACE_INFO(("\r\n%6.6f, %6.6f\r\n",2.31,0.005));
   1516              err = DMIC_PGA_Control( pdata->mic ); 
   1517              //APP_TRACE_INFO((" %s [0x%X]\r\n", err == OS_ERR_NONE ? "OK" : "FAIL" , err )); 
   1518              if( OS_ERR_NONE != err ) {  
   1519                  APP_TRACE_INFO(( "FAIL [0x%X]\r\n", err )); 
   1520                  return err;    
   1521              }
   1522              err = CODEC_Set_Volume( pdata->spk, pdata->lout );
   1523              if( OS_ERR_NONE != err ) {    
   1524                  APP_TRACE_INFO(( "FAIL [0x%X]\r\n", err )); 
   1525                  return err;    
   1526              }
   1527              APP_TRACE_INFO(( "OK\r\n" )); 
   1528              return err;  
   1529          }
   1530          
   1531          
   1532          
   1533          /*
   1534          *********************************************************************************************************
   1535          *                                       Reset_Mic_Mask()
   1536          *
   1537          * Description : Reset all mics to deactived state on the specified rulers and update FPGA mic signal switch array.
   1538          * Argument(s) : pInt : pointer to a int data, the 4 bytes of wihch control 4 ruler's all mic need be 
   1539          *               reset to deactive state or not.
   1540          *                      1 - deactive all mics on this ruler
   1541          *                      0 - do nothing. ignore the reset operation
   1542          * Return(s)   : NO_ERR :   execute successfully
   1543          *               others :   =error code .  
   1544          *
   1545          * Note(s)     : None.
   1546          *********************************************************************************************************
   1547          */
   1548          unsigned char Reset_Mic_Mask(  unsigned int *pInt )
   1549          {  
   1550              unsigned char  err ;
   1551              unsigned char  id;
   1552              unsigned char  *pChar;  
   1553              unsigned int   fpga_mask;
   1554              
   1555              fpga_mask = 0;    
   1556              pChar     = (unsigned char *)pInt;
   1557              err       = 0;
   1558          
   1559              for( id = 0; id < 4; id++ ) {        
   1560                  if( *(pChar+id) == 0 ) { 
   1561                      continue;
   1562                  }
   1563                  if( Global_Ruler_State[id] < RULER_STATE_CONFIGURED ) { //why not RULER_STATE_SELECTED  ? Because UI need reset mic in any case
   1564                      continue;
   1565                  }
   1566                  Global_Ruler_State[id] = RULER_STATE_CONFIGURED ;
   1567                  err = Update_Mic_Mask( id, 0 );
   1568                  if( OS_ERR_NONE != err ) {        
   1569                      return err;    
   1570                  } 
   1571                  Global_Mic_Mask[id] = 0;  
   1572                  if( RULER_TYPE_MASK( Global_Ruler_Type[id] ) == RULER_TYPE_RULER ) {//ruler 
   1573                      fpga_mask += (Global_Mic_Mask[id]&0xFF) << (id<<3);
   1574                      
   1575                  } else {
   1576                      fpga_mask += 0x3F << (id<<3); //handset choose the lowest slot H01
   1577                  }        
   1578              }
   1579              
   1580              Init_FPGA(fpga_mask);    
   1581              return err;  
   1582          }
   1583          
   1584          
   1585          /*
   1586          *********************************************************************************************************
   1587          *                                       Ruler_Port_LED_Service()
   1588          *
   1589          * Description : Control the ruler port identify LED state:  
   1590          *               turn on LED after ruler configured, blink LED during recording
   1591          * Argument(s) : None.
   1592          * Return(s)   : None.
   1593          * Note(s)     : None.
   1594          *********************************************************************************************************
   1595          */
   1596          void Ruler_Port_LED_Service( void )
   1597          {    
   1598              static unsigned int counter; 
   1599              static unsigned int counter_buz;    
   1600              unsigned char ruler_id;
   1601              unsigned char ruler_state;    
   1602              unsigned char LED_Freq;
   1603              unsigned char post_err_flag;
   1604          
   1605              LED_Freq      = 0x3F; 
   1606              post_err_flag = 0;
   1607              
   1608              for( ruler_id = 0 ; ruler_id < 4 ; ruler_id++ ) {
   1609                
   1610                  ruler_state = Global_Ruler_State[ruler_id];  
   1611                  if( Global_Bridge_POST != NO_ERR ) { //if POST err, start all LED 
   1612                      ruler_state = RULER_STATE_RUN ;
   1613                      post_err_flag = 1;
   1614                  }
   1615                  switch( ruler_state ) {
   1616                    
   1617                      case RULER_STATE_DETACHED :
   1618                      case RULER_STATE_ATTACHED :
   1619                          LED_Clear( LED_P0 + ruler_id );
   1620                      break;            
   1621                      case RULER_STATE_CONFIGURED :
   1622                      case RULER_STATE_SELECTED :  
   1623                          LED_Set( LED_P0 + ruler_id );
   1624                      break;            
   1625                      case RULER_STATE_RUN :
   1626                          if( (counter & LED_Freq) == 0 ) {
   1627                              LED_Toggle( LED_P0 + ruler_id );   
   1628                              if( post_err_flag== 1 && ruler_id == 0 && (counter_buz++ < 6 ) ) {
   1629                                  //Buzzer_Toggle(); //buzzer off id POST err 
   1630                                  Buzzer_OnOff( counter_buz&0x01 );   //fix long buz issue in some case                  
   1631                              }
   1632                          }
   1633                      
   1634                      default:              
   1635                      break;
   1636                  }
   1637            
   1638              }    
   1639              counter++;    
   1640          }
   1641          
   1642          
   1643          
   1644          /*
   1645          *********************************************************************************************************
   1646          *                                       AB_POST()
   1647          *
   1648          * Description : Audio bridge Power-On-Self-Test use. 
   1649          *
   1650          * Argument(s) : None.
   1651          * Return(s)   : None.
   1652          * Note(s)     : None.
   1653          *********************************************************************************************************
   1654          */
   1655          void AB_POST( void )
   1656          {
   1657              unsigned char  err;
   1658              
   1659              APP_TRACE_INFO(("\r\nStart Audio Bridge POST :\r\n"));    
   1660              Enable_FPGA();
   1661          
   1662              APP_TRACE_INFO(("\r\n1. CODEC... \r\n"));
   1663              err = Init_CODEC( SAMPLE_RATE_DEF );    
   1664              if( err != NO_ERR ) {
   1665                  Global_Bridge_POST = POST_ERR_CODEC;
   1666                  APP_TRACE_INFO(("\r\n---Error : %d\r\n",err));
   1667                  return ;
   1668              } else {
   1669                  APP_TRACE_INFO(("\r\n---OK\r\n"));
   1670              }
   1671              
   1672              APP_TRACE_INFO(("\r\n2. FM36 DSP... \r\n"));
   1673          #ifdef BOARD_TYPE_AB03     
   1674              err = Init_FM36_AB03( SAMPLE_RATE_DEF, 0, 1, 0 ); //Lin from SP1.Slot0
   1675              //err = Init_FM36( SAMPLE_RATE_DEF );
   1676          #else 
   1677              err = Init_FM36( SAMPLE_RATE_DEF );
   1678          #endif
   1679              if( err != NO_ERR ) {
   1680                  Global_Bridge_POST = POST_ERR_FM36;
   1681                  APP_TRACE_INFO(("\r\n---Error : %d\r\n",err));
   1682                  return ;
   1683              } else {
   1684                  APP_TRACE_INFO(("\r\n---OK\r\n"));
   1685              }  
   1686              
   1687              APP_TRACE_INFO(("\r\n3. AUDIO MCU... \r\n"));
   1688              err = Get_Audio_Version();
   1689              if( err != NO_ERR ) {
   1690                  Global_Bridge_POST = POST_ERR_AUDIO;
   1691                  APP_TRACE_INFO(("\r\n---Error : %d\r\n",err));
   1692                  return ;
   1693              } else {
   1694                  APP_TRACE_INFO(("\r\n---OK\r\n"));
   1695              }    
   1696             
   1697              
   1698              
   1699          //    APP_TRACE_INFO(("\r\n4. external CODEC... \r\n"));
   1700          //    err = Init_CODEC_AIC3204( SAMPLE_RATE_DEF );    
   1701          //    if( err != NO_ERR ) {
   1702          //        Global_Bridge_POST = POST_ERR_CODEC;
   1703          //        APP_TRACE_INFO(("\r\n---Error : %d\r\n",err));
   1704          //        return ;
   1705          //    } else {
   1706          //        APP_TRACE_INFO(("\r\n---OK\r\n"));
   1707          //    }
   1708              
   1709              //Disable_FPGA(); 
   1710              //Ruler_Power_Switch(1); 
   1711              
   1712              err = Init_CODEC( 0 );
   1713              if( err != NO_ERR ) {
   1714                  Global_Bridge_POST = POST_ERR_CODEC ;
   1715                  APP_TRACE_INFO(("\r\nPower Down CODEC ERROR: %d\r\n",err)); 
   1716              }
   1717              
   1718          }
   1719          
   1720          
   1721          
   1722          /*
   1723          *********************************************************************************************************
   1724          *                                       Ruler_POST()
   1725          *
   1726          * Description : Get back specified ruler Power-On-Self-Test status. 
   1727          *
   1728          * Argument(s) : ruler_id :  0~ 3
   1729          * Return(s)   : NO_ERR :   execute successfully
   1730          *               others :   =error code . 
   1731          * Note(s)     : None.
   1732          *********************************************************************************************************
   1733          */
   1734          unsigned char Ruler_POST( unsigned char ruler_id )
   1735          {
   1736              unsigned char  err;
   1737              unsigned short result;   
   1738              
   1739              APP_TRACE_INFO(("\r\nRuler[%d] POST status check... \r\n",ruler_id)); 
   1740          
   1741              err = Read_Ruler_Status( ruler_id, &result);
   1742              if( err == RULER_STATE_ERR ) { //no ruler attached
   1743                  return err;;
   1744              }      
   1745              if( err != NO_ERR ) {
   1746                 return err;
   1747              }
   1748              if( result != 0 ) {
   1749                  if( result != 0x8000 ) {        
   1750                      APP_TRACE_INFO(("\r\n---Error Ruler[%d]: %d-0x%X\r\n",ruler_id,err,result));
   1751                      return 1; 
   1752                  } else {
   1753                      APP_TRACE_INFO(("\r\n---WARNING Ruler[%d]: Mic calibration data NOT Initialized!\r\n",ruler_id));  
   1754                  }
   1755              } 
   1756              APP_TRACE_INFO(("\r\n---OK\r\n"));  
   1757                   
   1758              return err;
   1759          }
   1760          
   1761          
   1762          /*
   1763          *********************************************************************************************************
   1764          *                                       simple_test_use()
   1765          *
   1766          * Description : debug use.
   1767          *
   1768          * Argument(s) : None.
   1769          * Return(s)   : None.
   1770          * Note(s)     : None.
   1771          *********************************************************************************************************
   1772          */
   1773          void simple_test_use( void )
   1774          {      
   1775              APP_TRACE_INFO(("\r\nHi,man. Simple play/rec test triggered...\r\n"));   
   1776              
   1777          #if 0  
   1778              
   1779           //R01      
   1780              TOGGLE_MIC toggle_mic[6] = {    
   1781                                              {0, 6, 1 }, {0, 7, 1 }, {0, 8, 1 },
   1782                                              {0, 12, 1 }, {0, 13, 1 }, {0, 14, 1 }  
   1783                                          }; 
   1784            
   1785              for (unsigned char i = 0; i< 6 ; i++ ) {
   1786                  Toggle_Mic(&toggle_mic[i]); 
   1787              } 
   1788              
   1789          #else
   1790              
   1791          //H01
   1792              Update_Mic_Mask( 0, 0x3f); 
   1793              Init_FPGA(0x3F);
   1794              Global_Ruler_State[0] = RULER_STATE_RUN; 
   1795                  
   1796              AUDIO_CFG audio_config_play = {SAMPLE_RATE_DEF, AUDIO_TYPE_PLAY, 6 };
   1797              AUDIO_CFG audio_config_rec  = {SAMPLE_RATE_DEF, AUDIO_TYPE_REC,  6 };
   1798              Setup_Audio( &audio_config_play );                   
   1799              Setup_Audio( &audio_config_rec );                 
   1800              //Start_Audio( AUDIO_START_PALYREC ); 
   1801              
   1802          #endif
   1803              
   1804          }
   1805          
   1806          
   1807          unsigned char Ruler_Setup_Sync( unsigned char ruler_slot_id )
   1808          {
   1809              unsigned char err ;
   1810              unsigned char buf[] = { RULER_CMD_SETUP_SYNC, Ruler_Setup_Sync_Data, ruler_slot_id };
   1811          
   1812          #if OS_CRITICAL_METHOD == 3u
   1813              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
   1814          #endif 
   1815              
   1816              //check ruler connection state 
   1817              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
   1818                  return RULER_STATE_ERR ;         
   1819              } 
   1820              
   1821              OSSemPend( UART_MUX_Sem_lock, 0, &err );
   1822              if( Global_Ruler_Index != ruler_slot_id ) {
   1823                  Check_UART_Mixer_Ready();
   1824                  //OS_ENTER_CRITICAL(); 
   1825                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
   1826                  //OS_EXIT_CRITICAL();  
   1827                  UART1_Mixer( ruler_slot_id );
   1828              }
   1829              
   1830              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
   1831              if( OS_ERR_NONE == err ) {
   1832                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
   1833                  if( OS_ERR_TIMEOUT == err ) {
   1834                      APP_TRACE_INFO(("Ruler_Setup_Sync[%d] timeout\r\n",ruler_slot_id));
   1835                  } else {
   1836                      err = Ruler_CMD_Result; //exe result from GACK
   1837                      if(OS_ERR_NONE != err ){
   1838                          APP_TRACE_INFO(("Ruler_Setup_Sync[%d] err = %d\r\n",ruler_slot_id,err));
   1839                      }
   1840                  }
   1841                  
   1842              } else {
   1843                  APP_TRACE_INFO(("Ruler[%d] pcSendDateToBuf failed: %d\r\n",ruler_slot_id,err));
   1844              }    
   1845              OSSemPost( UART_MUX_Sem_lock );    
   1846              return err ;    
   1847              
   1848              
   1849          }
   1850          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AB_POST
         8   -> BSP_Ser_Printf
         8   -> Enable_FPGA
         8   -> Get_Audio_Version
         8   -> Init_CODEC
         8   -> Init_FM36_AB03
       0   Check_Actived_Mic_Number
      16   Check_UART_Mixer_Ready
        16   -> BSP_Ser_Printf
        16   -> OSQGet
        16   -> OSTimeDly
        16   -> Queue_NData
       0   Check_Watch_Attach_State
      24   FLASHD_Write_Safe
        24   -> BSP_Ser_Printf
        24   -> FLASHD_Write
      16   Get_Audio_Version
        16   -> BSP_Ser_Printf
        16   -> UART2_Mixer
        16   -> USART_Read_Timeout
        16   -> USART_SendBuf
      32   Get_Ruler_Type
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      32   Get_Ruler_Version
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
       0   Init_Global_Var
      24   Init_Ruler
        24   -> BSP_Ser_Printf
        24   -> Check_UART_Mixer_Ready
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> UART1_Mixer
        24   -> pcSendDateToBuf
       8   Read_Flash_State
         8   -> __aeabi_memcpy4
      32   Read_Mic_Cali_Data
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      24   Read_Ruler_Info
        24   -> BSP_Ser_Printf
        24   -> Check_UART_Mixer_Ready
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> UART1_Mixer
        24   -> pcSendDateToBuf
      32   Read_Ruler_Status
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      16   Reset_Audio
        16   -> BSP_Ser_Printf
        16   -> UART2_Mixer
        16   -> USART_Read_Timeout
        16   -> USART_SendBuf
      24   Reset_Mic_Mask
        24   -> Init_FPGA
        24   -> Update_Mic_Mask
      32   Ruler_Active_Control
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      16   Ruler_POST
        16   -> BSP_Ser_Printf
        16   -> Read_Ruler_Status
      24   Ruler_Port_LED_Service
        24   -> Buzzer_OnOff
        24   -> LED_Clear
        24   -> LED_Set
        24   -> LED_Toggle
      32   Ruler_Setup_Sync
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      72   Save_Ruler_FW
        72   -> BSP_Ser_Printf
        72   -> Buzzer_OnOff
        72   -> FLASHD_Write_Safe
        72   -> LED_Toggle
        72   -> Read_Flash_State
        72   -> Write_Flash_State
        72   -> strcpy
      16   Set_Volume
        16   -> BSP_Ser_Printf
        16   -> CODEC_Set_Volume
        16   -> DMIC_PGA_Control
        16   -> __aeabi_uidiv
        16   -> __aeabi_uidivmod
      32   Setup_Audio
        32   -> BSP_Ser_Printf
        32   -> Check_Actived_Mic_Number
        32   -> Check_SR_Support
        32   -> Check_Watch_Attach_State
        32   -> DMIC_Ploarity_Control
        32   -> Init_CODEC
        32   -> Init_FM36_AB03
        32   -> UART2_Mixer
        32   -> USART_Read_Timeout
        32   -> USART_SendBuf
      32   Setup_Ruler
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      32   Start_Audio
        32   -> BSP_Ser_Printf
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> UART2_Mixer
        32   -> USART_Read_Timeout
        32   -> USART_SendBuf
      24   Stop_Audio
        24   -> BSP_Ser_Printf
        24   -> Init_CODEC
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> UART2_Mixer
        24   -> USART_Read_Timeout
        24   -> USART_SendBuf
      32   Toggle_Mic
        32   -> BSP_Ser_Printf
        32   -> Init_FPGA
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> Update_Mic_Mask
      40   Update_Mic_Mask
        40   -> BSP_Ser_Printf
        40   -> Check_UART_Mixer_Ready
        40   -> OSSemPend
        40   -> OSSemPost
        40   -> UART1_Mixer
        40   -> pcSendDateToBuf
      40   Update_Ruler_FW
        40   -> BSP_Ser_Printf
        40   -> Check_UART_Mixer_Ready
        40   -> OSSemPend
        40   -> OSSemPost
        40   -> OSTimeDly
        40   -> Port_Detect_Enable
        40   -> Ruler_Power_Switch
        40   -> UART1_Mixer
        40   -> UART_Init
        40   -> USART_Read_Timeout
        40   -> USART_SendBuf
        40   -> Xmodem_Transmit
        40   -> memset
      16   Write_Flash_State
        16   -> BSP_Ser_Printf
        16   -> FLASHD_Write_Safe
      56   Write_Mic_Cali_Data
        56   -> BSP_Ser_Printf
        56   -> Check_UART_Mixer_Ready
        56   -> OSSemPend
        56   -> OSSemPost
        56   -> OSTimeDly
        56   -> UART1_Mixer
        56   -> pcSendDateToBuf
      48   Write_Ruler_Info
        48   -> BSP_Ser_Printf
        48   -> Check_UART_Mixer_Ready
        48   -> OSSemPend
        48   -> OSSemPost
        48   -> OSTimeDly
        48   -> UART1_Mixer
        48   -> pcSendDateToBuf
      24   simple_test_use
        24   -> BSP_Ser_Printf
        24   -> Init_FPGA
        24   -> Setup_Audio
        24   -> Update_Mic_Mask


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant " %s [0x%X]\r\n">
       4  ?<Constant "> ">
       4  ?<Constant ">\r\n">
      44  ?<Constant "Bin file[%d Btyes] sa...">
      48  ?<Constant "Check_UART_Mixer_Read...">
      48  ?<Constant "Check_UART_Mixer_Read...">_1
      36  ?<Constant "ERROR:  Save ruler FW...">
      32  ?<Constant "ERROR: FW bin file mi...">
      36  ?<Constant "ERROR: Write MCU flas...">
      36  ?<Constant "ERROR: Write flash st...">
      32  ?<Constant "ERROR: flash state no...">
      48  ?<Constant "ERROR: this operation...">
      76  ?<Constant "ERROR:(Setup_Audio Pl...">
      16  ?<Constant "FAIL [0x%X]\r\n">
       8  ?<Constant "FAIL">
      36  ?<Constant "Get Ruler_Setup_Sync_...">
      32  ?<Constant "Get_Ruler_Type[%d] er...">
      32  ?<Constant "Get_Ruler_Version[%d]...">
      36  ?<Constant "Get_Ruler_Version[%d]...">_1
      28  ?<Constant "Init ruler[%d] timeou...">
      28  ?<Constant "Init_Ruler[%d] err = ...">
      16  ?<Constant "LIN Disabled">
      12  ?<Constant "LIN Enabled">
      28  ?<Constant "LOUT_Gain = -%d.%d dB...">
      28  ?<Constant "Lin 2 channels added....">
      24  ?<Constant "Mic_Gain = %d dB :  ">
      16  ?<Constant "Mute LOUT :  ">
      16  ?<Constant "Mute MIC :  ">
      16  ?<Constant "Mute SPK :  ">
       4  ?<Constant "OK">
       8  ?<Constant "OK\r\n">
      36  ?<Constant "Read_Mic_Cali_Data[%d...">
      36  ?<Constant "Read_Mic_Cali_Data[%d...">_1
      32  ?<Constant "Read_Ruler_Info[%d] e...">
      32  ?<Constant "Read_Ruler_Info[%d] t...">
      32  ?<Constant "Read_Ruler_Status[%d]...">
      36  ?<Constant "Read_Ruler_Status[%d]...">_1
      32  ?<Constant "Read_Ruler_Type[%d] t...">
      16  ?<Constant "Reset_Audio\r\n">
      32  ?<Constant "Revert DMIC polarity ...">
      28  ?<Constant "Ruler[%d] FW Version:...">
      40  ?<Constant "Ruler[%d] pcSendDateT...">
      36  ?<Constant "Ruler[%d]_Active_Cont...">
      36  ?<Constant "Ruler[%d]_Active_Cont...">_1
      36  ?<Constant "Ruler[%d]_Active_Cont...">_2
      32  ?<Constant "Ruler_Setup_Sync[%d] ...">
      32  ?<Constant "Ruler_Setup_Sync[%d] ...">_1
      28  ?<Constant "SPK_Gain = -%d.%d dB :  ">
      16  ?<Constant "Set Volume :: ">
      40  ?<Constant "Setup_Audio [PLAY]:[%...">
      40  ?<Constant "Setup_Audio [REC]:[%d...">
      28  ?<Constant "Setup_Ruler[%d] err =...">
      28  ?<Constant "Setup_Ruler[%d] timeo...">
      52  ?<Constant "Start loading ruler b...">
      56  ?<Constant "Start updating ruler[...">
      48  ?<Constant "Start_Audio : type = ...">
      16  ?<Constant "Stop_Audio\r\n">
      36  ?<Constant "Toggle Ruler[%d]-Mic[...">
      40  ?<Constant "Update_Mic_Mask for R...">
      52  ?<Constant "WARN:(Setup_Audio Pla...">
      72  ?<Constant "WARN:(Setup_Audio Rec...">
      60  ?<Constant "WARN:(Setup_Audio Rec...">_1
      40  ?<Constant "Write_Mic_Cali_Data[%...">
      36  ?<Constant "Write_Mic_Cali_Data[%...">_1
      32  ?<Constant "Write_Ruler_Info[%d] ...">
      32  ?<Constant "Write_Ruler_Info[%d] ...">_1
      20  ?<Constant "\r\n---Error : %d\r\n">
      32  ?<Constant "\r\n---Error Ruler[%d]:...">
      12  ?<Constant "\r\n---OK\r\n">
      64  ?<Constant "\r\n---WARNING Ruler[%d...">
      20  ?<Constant "\r\n1. CODEC... \r\n">
      20  ?<Constant "\r\n2. FM36 DSP... \r\n">
      24  ?<Constant "\r\n3. AUDIO MCU... \r\n">
      36  ?<Constant "\r\nDMIC_Ploarity_Contr...">
      48  ?<Constant "\r\nERROR: Check_Active...">
      56  ?<Constant "\r\nFailed to init rule...">
      40  ?<Constant "\r\nGet_Audio_Version E...">
      48  ?<Constant "\r\nHi,man. Simple play...">
      32  ?<Constant "\r\nPower Down CODEC ER...">
      32  ?<Constant "\r\nReset_Audio ERROR: ...">
      28  ?<Constant "\r\nReset_Audio ERROR: ...">_1
      36  ?<Constant "\r\nRuler[%d] POST stat...">
      48  ?<Constant "\r\nSetup_Audio ERROR: ...">
      32  ?<Constant "\r\nSetup_Audio ERROR: ...">_1
      28  ?<Constant "\r\nSetup_Audio ERROR: ...">_2
      40  ?<Constant "\r\nSetup_Audio Init_CO...">
      40  ?<Constant "\r\nSetup_Audio ReInit_...">
      32  ?<Constant "\r\nStart Audio Bridge ...">
      36  ?<Constant "\r\nStart_Audio ERROR: ...">
      36  ?<Constant "\r\nStart_Audio ERROR: ...">_1
      28  ?<Constant "\r\nStop_Audio ERROR: %...">
      32  ?<Constant "\r\nStop_Audio ERROR: t...">
      44  ?<Constant "\r\nStop_Audio Power Do...">
      32  ?<Constant "\r\nUSB Audio FW Versio...">
      44  ?<Constant "\r\nUpdate ruler[%d] fi...">
       8  ?<Constant {10, 0, 0, 0, 0}>
       1  ?<Constant {12}>
       2  ?<Constant {13, 0}>
       1  ?<Constant {14}>
       4  ?<Constant {15, 0, 0}>
       8  ?<Constant {235, 144, 1, 0, 0, 0, 0}>
       4  ?<Constant {235, 144, 11}>
       4  ?<Constant {235, 144, 16}>
       8  ?<Constant {235, 144, 2, 0, 0}>
       4  ?<Constant {235, 144, 3}>
       8  ?<Constant {32000, 0, 6}>
       8  ?<Constant {32000, 1, 6}>
       2  ?<Constant {4, 0}>
       1  ?<Constant {5}>
       1  ?<Constant {6}>
       2  ?<Constant {8, 0}>
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_10
       4  ??DataTable31_11
       4  ??DataTable31_12
       4  ??DataTable31_13
       4  ??DataTable31_14
       4  ??DataTable31_15
       4  ??DataTable31_16
       4  ??DataTable31_17
       4  ??DataTable31_18
       4  ??DataTable31_19
       4  ??DataTable31_2
       4  ??DataTable31_20
       4  ??DataTable31_21
       4  ??DataTable31_22
       4  ??DataTable31_23
       4  ??DataTable31_24
       4  ??DataTable31_25
       4  ??DataTable31_26
       4  ??DataTable31_27
       4  ??DataTable31_28
       4  ??DataTable31_29
       4  ??DataTable31_3
       4  ??DataTable31_30
       4  ??DataTable31_31
       4  ??DataTable31_32
       4  ??DataTable31_33
       4  ??DataTable31_34
       4  ??DataTable31_35
       4  ??DataTable31_36
       4  ??DataTable31_37
       4  ??DataTable31_38
       4  ??DataTable31_39
       4  ??DataTable31_4
       4  ??DataTable31_40
       4  ??DataTable31_41
       4  ??DataTable31_42
       4  ??DataTable31_43
       4  ??DataTable31_44
       4  ??DataTable31_45
       4  ??DataTable31_46
       4  ??DataTable31_47
       4  ??DataTable31_48
       4  ??DataTable31_49
       4  ??DataTable31_5
       4  ??DataTable31_50
       4  ??DataTable31_51
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       4  ??DataTable31_9
     316  AB_POST
      12  Audio_Version
     112  Check_Actived_Mic_Number
     156  Check_UART_Mixer_Ready
      96  Check_Watch_Attach_State
      76  FLASHD_Write_Safe
     132  Get_Audio_Version
     368  Get_Ruler_Type
     380  Get_Ruler_Version
       1  Global_Bridge_POST
      16  Global_Mic_Mask
       4  Global_Mic_State
       1  Global_Ruler_Index
       4  Global_Ruler_State
       4  Global_Ruler_Type
     120  Init_Global_Var
     320  Init_Ruler
      32  Read_Flash_State
     348  Read_Mic_Cali_Data
     336  Read_Ruler_Info
     364  Read_Ruler_Status
     168  Reset_Audio
     304  Reset_Mic_Mask
     444  Ruler_Active_Control
       1  Ruler_CMD_Result
     200  Ruler_POST
     320  Ruler_Port_LED_Service
     356  Ruler_Setup_Sync
       1  Ruler_Setup_Sync_Data
     476  Save_Ruler_FW
     344  Set_Volume
     796  Setup_Audio
     380  Setup_Ruler
     316  Start_Audio
     308  Stop_Audio
     440  Toggle_Mic
     380  Update_Mic_Mask
     564  Update_Ruler_FW
      80  Write_Flash_State
     576  Write_Mic_Cali_Data
     560  Write_Ruler_Info
       4  counter
       4  counter_buz
       4  flash_addr
     108  simple_test_use

 
     52 bytes in section .bss
      4 bytes in section .data
  3 206 bytes in section .rodata
 10 872 bytes in section .text
 
 10 872 bytes of CODE  memory
  3 206 bytes of CONST memory
     56 bytes of DATA  memory

Errors: none
Warnings: none
