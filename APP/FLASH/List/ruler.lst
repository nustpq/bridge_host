###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Dec/2014  15:45:04
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\ruler.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\ruler.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\ruler.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\ruler.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Noah\ruler.c
      1          /*
      2          *********************************************************************************************************
      3          *                               iSAM TEST BENCH AUDIO BRIDGE BOARD APP PACKAGE
      4          *
      5          *                            (c) Copyright 2013 - 2016; Fortemedia Inc.; Nanjing, China
      6          *
      7          *                   All rights reserved.  Protected by international copyright laws.
      8          *                   Knowledge of the source code may not be used to write a similar
      9          *                   product.  This file may only be used in accordance with a license
     10          *                   and should not be redistributed in any way.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                        RULER RELATED OPERATIONS REALIZATION
     18          *
     19          *                                          Atmel AT91SAM7A3
     20          *                                               on the
     21          *                                      iSAM Audio Bridge Board
     22          *
     23          * Filename      : ruler.c
     24          * Version       : V1.0.0
     25          * Programmer(s) : PQ
     26          *********************************************************************************************************
     27          * Note(s)       :
     28          *********************************************************************************************************
     29          */
     30          
     31          #include <includes.h>
     32          
     33          
     34          volatile unsigned int   Global_Mic_Mask[4] ;      //MIC sellection status
     35          volatile unsigned char  Global_Ruler_Index = 0 ;  //the ruler index for UART comm NOW
     36          volatile unsigned char  Global_Bridge_POST = 0 ;  //audio bridge POST status
     37          volatile unsigned char  Global_Ruler_State[4];    //ruler status
     38          volatile unsigned char  Global_Ruler_Type[4];     //ruler type
     39          volatile unsigned char  Global_Mic_State[4];      //MIC (8*4=32) status(calib info error or not)
     40          unsigned char           Audio_Version[12];        //fixed size
     41          unsigned char           Ruler_CMD_Result;
     42          volatile unsigned char  Ruler_Setup_Sync_Data;
     43          
     44          extern EMB_BUF   Emb_Buf_Data;
     45          extern EMB_BUF   Emb_Buf_Cmd;
     46          
     47          
     48          
     49          /*
     50          *********************************************************************************************************
     51          *                                           Init_Global_Var()
     52          *
     53          * Description : Initialize Ruler and MIC related global variables to defalut value.
     54          * Argument(s) : None.
     55          * Return(s)   : None.
     56          *
     57          * Note(s)     : None.
     58          *********************************************************************************************************
     59          */
     60          void Init_Global_Var( void )
     61          {
     62              unsigned char ruler_id;    
     63              
     64              for( ruler_id = 0; ruler_id < 4; ruler_id++ ) {        
     65                  Global_Ruler_State[ruler_id] = RULER_STATE_DETACHED;
     66                  Global_Ruler_Type[ruler_id]  = 0;
     67                  Global_Mic_State[ruler_id]   = 0 ;
     68                  Global_Mic_Mask[ruler_id]    = 0 ;        
     69              }   
     70          }
     71          
     72          
     73          /*
     74          *********************************************************************************************************
     75          *                                           Check_Actived_Mic_Number()
     76          *
     77          * Description : Check MIC mask global variable to get the total actived MICs number.
     78          * Argument(s) : None.
     79          * Return(s)   : mic_counter : the total actived MICs number.
     80          *
     81          * Note(s)     : None.
     82          *********************************************************************************************************
     83          */
     84          static unsigned char Check_Actived_Mic_Number( void )
     85          {
     86              unsigned char mic_counter = 0;
     87              unsigned char i, j;    
     88          
     89              for( i = 0; i < 4 ; i++ ) { //scan 4 slots
     90                  for( j = 0; j < 32; j++ ) { //scan max 32mics per slot
     91                      if( (Global_Mic_Mask[i]>>j)&1) {
     92                          mic_counter++;
     93                      }
     94                  }
     95              } 
     96             
     97              return mic_counter;
     98          }
     99          
    100          
    101          
    102          /*
    103          *********************************************************************************************************
    104          *                                           Watch_Mic_Revert()
    105          *
    106          * Description : Revert Mics in FPGA mask For MIC revert issue on W01 mockup
    107          * Argument(s) : unsigned int *p_mask: pointer to mask data
    108          * Return(s)   : None.
    109          *
    110          * Note(s)     : Toggle_Mic() use
    111          *********************************************************************************************************
    112          */       
    113          void Watch_Mic_Revert( unsigned int *p_mask )
    114          {
    115              unsigned char i;
    116              unsigned char mask, temp; 
    117          
    118              mask   = *(unsigned char *)p_mask;    
    119              for( i = 0; i < 4 ; i++ ) { //4 pairs mic       
    120                  temp = (mask>>(i<<1)) & 3;
    121                  if( temp == 1 ) {
    122                      mask &= ~(3<<(i<<1));
    123                      mask |= 2<<(i<<1); 
    124                  } else if(temp == 2) {
    125                      mask &= ~(3<<(i<<1));
    126                      mask |= 1<<(i<<1); 
    127                  }
    128              }
    129              *p_mask = mask;
    130             
    131          }
    132          
    133          
    134          /*
    135          *********************************************************************************************************
    136          *                                           Check_Watch_Mic_Mask_State()
    137          *
    138          * Description : Check if Mics on Watch ruler is used. For MIC revert issue on W01 mickup
    139          * Argument(s) : None.
    140          * Return(s)   : 0   : OK.
    141          *               err : not support.
    142          * Note(s)     : pass this info for revert mic in FM36 PDM input.
    143          *********************************************************************************************************
    144          */
    145          unsigned char Check_Watch_Mic_Mask_State( unsigned int mask, unsigned char *p_revert_mic )
    146          {
    147              unsigned char i;
    148              unsigned char temp;
    149              unsigned char flag1, flag2;    
    150              flag1  = 0;
    151              flag2  = 0;     
    152              for( i = 0; i < 4 ; i++ ) { //4 pairs mic       
    153                  temp = (mask>>(i<<1)) & 3;
    154                  switch( temp ) {
    155                      case  1 :           
    156                      case  2 :
    157                          flag2++;              
    158                      break;
    159                      case  3 : //both mic seleced in one pair mic
    160                          flag1++;
    161                          *p_revert_mic = 1;
    162                      break;
    163                  }
    164              }        
    165              if( flag1 && flag2 ) {        
    166                  return W01_MIC_NOT_SUPPORT_ERR;
    167              }        
    168              return 0;    
    169          }
    170          
    171          
    172          /*
    173          *********************************************************************************************************
    174          *                                           Check_Watch_Attach_State()
    175          *
    176          * Description : Check if Mics on Watch ruler is used. For MIC revert issue on W01 mickup
    177          * Argument(s) : None.
    178          * Return(s)   : 0 : no watch attachd or Mics on watch not used.
    179          *               1 : Mics on watch used, no need revert mic.
    180          *               2 : Mics on watch used, need revert mic.
    181          *
    182          * Note(s)     : pass this info for revert mic in FM36 PDM input.
    183          *********************************************************************************************************
    184          */
    185          unsigned char Check_Watch_Attach_State( void )
    186          {
    187              unsigned char err;
    188              unsigned char ruler_id;
    189              unsigned char revert_mic;
    190              
    191              revert_mic = 0;
    192              
    193              for( ruler_id = 0; ruler_id < 4; ruler_id++ ) {
    194                  
    195                  if( Global_Ruler_State[ruler_id] < RULER_STATE_SELECTED ) {
    196                      continue;
    197                  }
    198                  
    199                  if( Global_Ruler_Type[ruler_id] == RULER_TYPE_W01 ) {
    200                      err = Check_Watch_Mic_Mask_State( Global_Mic_Mask[ruler_id], &revert_mic );
    201                      if( OS_ERR_NONE != err ) {
    202                          APP_TRACE_INFO_T(("ERROR: Toggled W01 Mic group NOT support!\r\n")); 
    203                          return err; 
    204                      }         
    205                      if( revert_mic ) {
    206                          return 2;
    207                      } else {
    208                          return 1;
    209                      }
    210                  }   
    211                  
    212                  
    213              }
    214              
    215              return 0;    
    216          }
    217          
    218          
    219          
    220                   
    221          
    222          
    223          /*
    224          *********************************************************************************************************
    225          *                                           Check_UART_Mixer_Ready()
    226          *
    227          * Description : Check and wait until all data transmission inbuffer for current channel ruler is done .
    228          *               To make sure ruler channels will not be mix up.
    229          *               HW switch is important for this !
    230          * Argument(s) : None.
    231          * Return(s)   : mic_counter : the total actived MICs number.
    232          *
    233          * Note(s)     : If HW switch fast enough, no need this routine.
    234          *********************************************************************************************************
    235          */
    236          void Check_UART_Mixer_Ready( void )
    237          {
    238              unsigned char err; 
    239              unsigned int  counter;
    240              
    241              counter = 0;
    242              while( OSQGet( EVENT_MsgQ_Noah2RulerUART, &err ) ) {
    243                  OSTimeDly(1);
    244                  counter++;        
    245              } 
    246              if( counter) {
    247                  APP_TRACE_INFO_T(("Check_UART_Mixer_Ready, stage 1 : wait %d ms",counter));  
    248              }
    249                  
    250              counter = 0;
    251              while( Queue_NData((void*)pUART_Send_Buf[RULER_UART]) ) {
    252                  OSTimeDly(1);
    253                  counter++;  
    254              } 
    255              if( counter) {
    256                  APP_TRACE_INFO_T(("Check_UART_Mixer_Ready, stage 2 : wait %d ms",counter));  
    257              }
    258              OSTimeDly(5);   
    259              
    260          }
    261          
    262          
    263          /*
    264          *********************************************************************************************************
    265          *                                           Setup_Audio()
    266          *
    267          * Description : Send command to configure USB audio.
    268          * Argument(s) : pAudioCfg : pointer to AUDIO_CFG type data.
    269          * Return(s)   : NO_ERR :   execute successfully
    270          *               others :   refer to error code defines.           
    271          *
    272          * Note(s)     : None.
    273          *********************************************************************************************************
    274          */
    275          unsigned char Setup_Audio( AUDIO_CFG *pAudioCfg )
    276          {
    277              unsigned char err; 
    278              unsigned char mic_num; 
    279              unsigned char data  = 0xFF;
    280              unsigned char buf[] = { 
    281                  CMD_DATA_SYNC1, CMD_DATA_SYNC2, RULER_CMD_SET_AUDIO_CFG,\
    282                  pAudioCfg->type, pAudioCfg->channels,\
    283                 (pAudioCfg->sr)&0xFF, ((pAudioCfg->sr)>>8)&0xFF
    284              };
    285              
    286              //APP_TRACE_INFO_T(("Setup_Audio [%s]:[%d SR]:[%d CH]: %s",(pAudioCfg->type == 0) ? "REC " : "PLAY", pAudioCfg->sr, pAudioCfg->channels,((pAudioCfg->type == 0) && (pAudioCfg->lin_ch_mask == 0)) ? "LIN Disabled" : "LIN Enabled"));
    287              if( pAudioCfg->type == 0 ) {
    288                  APP_TRACE_INFO_T(("Setup_Audio [REC]:[%d SR]:[%d CH]: %s", pAudioCfg->sr, pAudioCfg->channels, pAudioCfg->lin_ch_mask == 0 ? "LIN Disabled" : "LIN Enabled" ));
    289              } else {
    290                  APP_TRACE_INFO_T(("Setup_Audio [PLAY]:[%d SR]:[%d CH]", pAudioCfg->sr, pAudioCfg->channels ));
    291              }
    292              
    293              err = Check_SR_Support( pAudioCfg->sr );
    294              if( err != NO_ERR ) { 
    295                  APP_TRACE_INFO_T(("Setup_Audio ERROR: Sample rate NOT support!")); 
    296                  return err;
    297              }    
    298              mic_num = Check_Actived_Mic_Number();
    299              if( mic_num > 6 ) {
    300                  APP_TRACE_INFO_T(("ERROR: Check_Actived_Mic_Number = %d > 6",mic_num));
    301                  return AUD_CFG_MIC_NUM_MAX_ERR;//if report err, need UI support!  
    302              } 
    303              //check rec mic num    
    304              if( (pAudioCfg->type == 0) && ( mic_num != pAudioCfg->channels) ) {
    305                  APP_TRACE_INFO_T(("WARN:(Setup_Audio Rec)pAudioCfg->channels(%d) !=  Active MICs Num(%d)",pAudioCfg->channels,mic_num));
    306                  buf[4] = mic_num;
    307                  return AUD_CFG_MIC_NUM_DISMATCH_ERR;
    308              }
    309              //check channel num    
    310              if( (pAudioCfg->type == 1) && (pAudioCfg->channels == 0) ) {
    311                  APP_TRACE_INFO_T(("WARN:(Setup_Audio Play)pAudioCfg->channels =  0" ));        
    312                  //return AUD_CFG_PLAY_CH_ZERO_ERR;  UI not support
    313              }  
    314              if( (pAudioCfg->type == 0) && (pAudioCfg->channels == 0) && (pAudioCfg->lin_ch_mask == 0) ) {
    315                  APP_TRACE_INFO_T(("WARN:(Setup_Audio Rec)pAudioCfg->channels + ch_lin =  0" ));        
    316                  //return AUD_CFG_PLAY_CH_ZERO_ERR; UI not support
    317              }
    318              //check sample rate
    319              //No add here!
    320              //
    321              //
    322           #ifdef BOARD_TYPE_AB03    
    323              //check play ch num
    324              if(  (pAudioCfg->type == 1) && ( pAudioCfg->channels > 4 ) ) { //for AB03
    325                  APP_TRACE_INFO_T(("ERROR:(Setup_Audio Play)pAudioCfg->channels(=%d) > 4 NOT allowed for AB03",pAudioCfg->channels));
    326                  return AUD_CFG_PLAY_CH_ERR ;
    327              }
    328          #endif
    329              if ( (pAudioCfg->type == 0) && (pAudioCfg->lin_ch_mask != 0) ) {         
    330                   buf[4] += 2; //add 2 channel  
    331                   APP_TRACE_INFO_T(("Lin 2 channels added...%d",buf[4])); 
    332              }
    333              UART2_Mixer(3); 
    334              USART_SendBuf( AUDIO_UART, buf, sizeof(buf)) ; 
    335              err = USART_Read_Timeout( AUDIO_UART, &data, 1, TIMEOUT_AUDIO_COM);
    336              if( err != NO_ERR ) { 
    337                  APP_TRACE_INFO_T(("Setup_Audio ERROR: timeout")); 
    338                  return err;
    339              }
    340              if( data != NO_ERR ) {
    341                  APP_TRACE_INFO_T(("Setup_Audio ERROR: %d\r\n ",data)); 
    342                  return data; 
    343              }
    344              err = Init_CODEC( pAudioCfg->sr );
    345              if( err != NO_ERR ) {
    346                  APP_TRACE_INFO_T(("Setup_Audio Init_CODEC ERROR: %d",err)); 
    347              } 
    348          #ifdef BOARD_TYPE_AB03    
    349              err = Init_FM36_AB03( pAudioCfg->sr, mic_num, 1, 0 ); //Lin from SP1_RX, slot0~1
    350          #else
    351              err = ReInit_FM36( pAudioCfg->sr ); 
    352          #endif
    353              if( err != NO_ERR ) {
    354                  APP_TRACE_INFO_T(("Setup_Audio ReInit_FM36 ERROR: %d",err)); 
    355              }
    356              data = Check_Watch_Attach_State();
    357              if( data == 1 ) { 
    358                  APP_TRACE_INFO_T(("No need revert DMIC polarity for W01.")); 
    359              } else if(data == 2 ) { 
    360                  APP_TRACE_INFO_T(("Revert DMIC polarity for W01.")); 
    361              }
    362              err = DMIC_Ploarity_Control( data == 2 );
    363              if( err != NO_ERR ) {
    364                  APP_TRACE_INFO_T(("DMIC_Ploarity_Control ERROR: %d",err)); 
    365              }
    366          //    if ( pAudioCfg->lin_ch_mask != 0 ) {
    367          //        err = Set_AIC3204_DSP_Offset( mic_num );
    368          //        if( err != NO_ERR ) {
    369          //            APP_TRACE_INFO_T(("\r\nSetup_Audio Init AIC3204 ERROR: %d",err)); 
    370          //        }
    371          //    }
    372              
    373              return err ; 
    374          }
    375          
    376          
    377          /*
    378          *********************************************************************************************************
    379          *                                           Start_Audio()
    380          *
    381          * Description : Send command to start USB audio play/record.
    382          * Argument(s) : cmd_type : record£¨== 1£©/play£¨== 2£©/record & play £¨== 3£©
    383          *               padding :  used for usb audio BI/BO first package padding
    384          * Return(s)   : NO_ERR :   execute successfully
    385          *               others :   refer to error code defines.           
    386          *
    387          * Note(s)     : None.
    388          *********************************************************************************************************
    389          */
    390          unsigned char Start_Audio( START_AUDIO start_audio )
    391          {   
    392              unsigned char err   = 0xFF;  
    393              unsigned char data  = 0xFF; 
    394              unsigned char ruler_id;    
    395              unsigned char buf[] = { CMD_DATA_SYNC1, CMD_DATA_SYNC2, RULER_CMD_START_AUDIO, start_audio.type&0x03, start_audio.padding }; 
    396              
    397          #if OS_CRITICAL_METHOD == 3u
    398              OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    399          #endif 
    400              APP_TRACE_INFO_T(("Start_Audio : type = [%d], padding = [0x%X]", start_audio.type, start_audio.padding));
    401              UART2_Mixer(3); 
    402              USART_SendBuf( AUDIO_UART, buf,  sizeof(buf) );    
    403              err = USART_Read_Timeout( AUDIO_UART, &data, 1, TIMEOUT_AUDIO_COM );  
    404              if( err != NO_ERR ) { 
    405                  APP_TRACE_INFO_T(("Start_Audio ERROR: Timeout : %d",err));
    406                  return err;
    407              }
    408              if( data != NO_ERR ) {
    409                  APP_TRACE_INFO_T(("Start_Audio ERROR: Data : %d\r\n ",data)); 
    410                  return data; 
    411              } else {
    412                  OS_ENTER_CRITICAL(); 
    413                  for( ruler_id = 0 ; ruler_id < 4 ; ruler_id++ ) {       
    414                      if( Global_Ruler_State[ruler_id] ==  RULER_STATE_SELECTED ) {//given: if mic selected, then ruler used
    415                          Global_Ruler_State[ruler_id] = RULER_STATE_RUN;                 
    416                      }      
    417                  }
    418                  OS_EXIT_CRITICAL();  
    419                  
    420              }
    421              return 0 ;   
    422          }
    423          
    424          
    425          /*
    426          *********************************************************************************************************
    427          *                                           Stop_Audio()
    428          *
    429          * Description : Send command to stop USB audio play/record.
    430          * Argument(s) : None.
    431          * Return(s)   : NO_ERR :   execute successfully
    432          *               others :   refer to error code defines.           
    433          *
    434          * Note(s)     : None.
    435          *********************************************************************************************************
    436          */
    437          unsigned char Stop_Audio( void )
    438          {  
    439              unsigned char err   = 0xFF;  
    440              unsigned char data  = 0xFF; 
    441              unsigned char ruler_id;     
    442              unsigned char buf[] = { CMD_DATA_SYNC1, CMD_DATA_SYNC2, RULER_CMD_STOP_AUDIO };
    443              
    444          #if OS_CRITICAL_METHOD == 3u
    445              OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    446          #endif 
    447              APP_TRACE_INFO_T(("Stop_Audio"));
    448              UART2_Mixer(3); 
    449              USART_SendBuf( AUDIO_UART, buf,  sizeof(buf)) ;    
    450              err = USART_Read_Timeout( AUDIO_UART, &data, 1, TIMEOUT_AUDIO_COM); 
    451              if( err != NO_ERR ) { 
    452                  APP_TRACE_INFO_T(("Stop_Audio ERROR: timeout")); 
    453                  return err;
    454              }
    455              if( data != NO_ERR ) {
    456                  APP_TRACE_INFO_T(("Stop_Audio ERROR: %d\r\n ",data)); 
    457                  return data; 
    458              } 
    459             
    460              err = Init_CODEC( 0 );
    461              if( err != NO_ERR ) {
    462                  APP_TRACE_INFO_T(("Stop_Audio Power Down CODEC ERROR: %d",err)); 
    463              }
    464              
    465              OS_ENTER_CRITICAL(); 
    466              for( ruler_id = 0 ; ruler_id < 4 ; ruler_id++ ) {       
    467                  if( Global_Ruler_State[ruler_id] ==  RULER_STATE_RUN ) {//given: if mic selected, then ruler used
    468                      Global_Ruler_State[ruler_id] = RULER_STATE_SELECTED;            
    469                  }                   
    470              }
    471              OS_EXIT_CRITICAL();
    472                
    473          //clear mic toggle after each audio stop to avoid issues in scripts test using USBTEST.exe
    474          #ifdef FOR_USE_USBTEST_EXE    
    475              for( ruler_id = 0; ruler_id < 4; ruler_id++ ) {
    476                  Global_Mic_Mask[ruler_id] = 0 ;
    477              }
    478          #endif
    479              
    480              return 0 ;    
    481          }
    482          
    483          
    484          /*
    485          *********************************************************************************************************
    486          *                                           Reset_Audio()
    487          *
    488          * Description : Send command to reset USB audio data stream.
    489          * Argument(s) : None.
    490          * Return(s)   : NO_ERR :   execute successfully
    491          *               others :   refer to error code defines.           
    492          *
    493          * Note(s)     : None.
    494          *********************************************************************************************************
    495          */
    496          unsigned char Reset_Audio( void )
    497          {  
    498              unsigned char err   = 0xFF;  
    499              unsigned char data  = 0xFF;    
    500              unsigned char buf[] = { CMD_DATA_SYNC1, CMD_DATA_SYNC2, RULER_CMD_RESET_AUDIO };
    501              
    502              APP_TRACE_INFO_T(("Reset_Audio"));
    503              UART2_Mixer(3); 
    504              USART_SendBuf( AUDIO_UART, buf,  sizeof(buf)) ;    
    505              err = USART_Read_Timeout( AUDIO_UART, &data, 1, TIMEOUT_AUDIO_COM); 
    506              if( err != NO_ERR ) { 
    507                  APP_TRACE_INFO_T(("Reset_Audio ERROR: timeout")); 
    508                  return err;
    509              }
    510              if( data != NO_ERR ) {
    511                  APP_TRACE_INFO_T(("Reset_Audio ERROR: %d\r\n ",data)); 
    512                  return data; 
    513              } 
    514               
    515              return 0 ;    
    516          }
    517          
    518          
    519          /*
    520          *********************************************************************************************************
    521          *                                       Get_Audio_Version()
    522          *
    523          * Description : Get USB audio MCU firmware version info, and stored in a global variable.
    524          * Argument(s) : None.
    525          * Return(s)   : NO_ERR :   execute successfully
    526          *               others :   refer to error code defines.           
    527          *
    528          * Note(s)     : None.
    529          *********************************************************************************************************
    530          */
    531          unsigned char Get_Audio_Version( void )
    532          {  
    533              unsigned char err;      
    534              unsigned char buf[] = { CMD_DATA_SYNC1, CMD_DATA_SYNC2, RULER_CMD_GET_AUDIO_VERSION };
    535             
    536              UART2_Mixer(3); 
    537              USART_SendBuf( AUDIO_UART, buf,  sizeof(buf)) ;    
    538              err = USART_Read_Timeout( AUDIO_UART, &Audio_Version, sizeof(Audio_Version), TIMEOUT_AUDIO_COM); 
    539              if( err != NO_ERR ) { 
    540                  APP_TRACE_INFO_T(("Get_Audio_Version ERROR: timeout")); 
    541                  return err;        
    542              } else {        
    543                  APP_TRACE_INFO_T(("USB Audio FW Version: %s ",Audio_Version));
    544              }     
    545              return 0 ;   
    546          }
    547          
    548          
    549          
    550          
    551          
    552          /*
    553          *********************************************************************************************************
    554          *                                       Init_Ruler()
    555          *
    556          * Description : Communicate with ruler to check connected or not
    557          *    
    558          * Argument(s) : ruler_slot_id: 0~ 3.
    559          * Return(s)   : NO_ERR :   ruler connected
    560          *               others :   =error code . ruler connection error,           
    561          *
    562          * Note(s)     : None.
    563          *********************************************************************************************************
    564          */
    565          unsigned char Init_Ruler( unsigned char ruler_slot_id ) //0 ~ 3
    566          {
    567              unsigned char err ;
    568          
    569          #if OS_CRITICAL_METHOD == 3u
    570              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    571          #endif 
    572                
    573              //check ruler connection state 
    574              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
    575                  return RULER_STATE_ERR ;         
    576              } 
    577              OSSemPend( UART_MUX_Sem_lock, 0, &err );
    578              if( Global_Ruler_Index != ruler_slot_id ) {
    579                  Check_UART_Mixer_Ready();
    580                  //OS_ENTER_CRITICAL(); 
    581                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    582                  //OS_EXIT_CRITICAL();  
    583                  UART1_Mixer( ruler_slot_id );
    584              } 
    585              
    586              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_EST, NULL, 0, 0, NULL, 0 ) ; 
    587              if( OS_ERR_NONE == err ) {
    588                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    589                  if( OS_ERR_TIMEOUT == err ) {
    590                      APP_TRACE_INFO_T(("Init ruler[%d] timeout!",ruler_slot_id));            
    591                  } else {
    592                      err = Ruler_CMD_Result; //exe result from GACK
    593                      if(OS_ERR_NONE != err ){
    594                          APP_TRACE_INFO_T(("Init_Ruler[%d] err = %d",ruler_slot_id,err));
    595                      }
    596                  }
    597                  
    598              } else {
    599                  APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_slot_id,err));        
    600              }    
    601              OSSemPost( UART_MUX_Sem_lock );    
    602              return err ;    
    603          }
    604                          
    605          
    606          /*
    607          *********************************************************************************************************
    608          *                                       Setup_Ruler()
    609          *
    610          * Description : Send ruler slot id to ruler for identification.
    611          *             
    612          * Argument(s) : ruler_slot_id: 0~ 3.
    613          * Return(s)   : NO_ERR :   execute successfully
    614          *               others :   =error code . ruler connection error,           
    615          *
    616          * Note(s)     : None.
    617          *********************************************************************************************************
    618          */
    619          unsigned char Setup_Ruler( unsigned char ruler_slot_id ) //0 ~ 3
    620          {    
    621              unsigned char err ;
    622              EMB_BUF        *pEBuf_Data; 
    623              unsigned char buf[] = { RULER_CMD_SET_RULER, ruler_slot_id };
    624              
    625          #if OS_CRITICAL_METHOD == 3u
    626              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    627          #endif 
    628              
    629              pEBuf_Data  = &Emb_Buf_Data; //Golbal var
    630              //check ruler connection state 
    631              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
    632                  return RULER_STATE_ERR ;         
    633              } 
    634              
    635              OSSemPend( UART_MUX_Sem_lock, 0, &err );
    636              if( Global_Ruler_Index != ruler_slot_id ) {
    637                  Check_UART_Mixer_Ready();
    638                  //OS_ENTER_CRITICAL(); 
    639                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    640                  //OS_EXIT_CRITICAL();  
    641                  UART1_Mixer( ruler_slot_id );
    642              }
    643              
    644              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    645              if( OS_ERR_NONE == err ) {
    646                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    647                  if( OS_ERR_TIMEOUT == err ) {
    648                      APP_TRACE_INFO_T(("Setup_Ruler[%d] timeout",ruler_slot_id));
    649                  } else {            
    650                      Ruler_Setup_Sync_Data = pEBuf_Data->data[0] ;
    651                      APP_TRACE_INFO_T(("Get Ruler_Setup_Sync_Data : 0x%X",Ruler_Setup_Sync_Data));
    652                      err = Ruler_CMD_Result; //exe result from GACK
    653                      if(OS_ERR_NONE != err ){
    654                          APP_TRACE_INFO_T(("Setup_Ruler[%d] err = %d",ruler_slot_id,err));
    655                      }
    656                  }
    657                  
    658              } else {
    659                  APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_slot_id,err));
    660              }    
    661              OSSemPost( UART_MUX_Sem_lock );    
    662              return err ;    
    663          }
    664          
    665          
    666          /*
    667          *********************************************************************************************************
    668          *                                       Get_Ruler_Type()
    669          *
    670          * Description : Get the specified ruler's type, and stored in a global variable, in which
    671          *               bit7: 0-ruler, 1- handset. Other bits reserved.
    672          * Argument(s) : ruler_slot_id: 0~ 3.
    673          * Return(s)   : NO_ERR :   execute successfully
    674          *               others :   refer to error code defines.           
    675          *
    676          * Note(s)     : None.
    677          *********************************************************************************************************
    678          */
    679          unsigned char Get_Ruler_Type(  unsigned char ruler_slot_id )
    680          {  
    681              unsigned char err ;
    682              EMB_BUF        *pEBuf_Data; 
    683              unsigned char buf[] = { RULER_CMD_GET_RULER_TYPE };
    684              
    685          #if OS_CRITICAL_METHOD == 3u
    686              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    687          #endif 
    688              
    689              pEBuf_Data  = &Emb_Buf_Data; //Golbal var
    690              //check ruler connection state 
    691              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
    692                  return RULER_STATE_ERR ;         
    693              } 
    694          
    695              OSSemPend( UART_MUX_Sem_lock, 0, &err ); 
    696              if( Global_Ruler_Index != ruler_slot_id ) {
    697                  Check_UART_Mixer_Ready();
    698                  //OS_ENTER_CRITICAL(); 
    699                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    700                  //OS_EXIT_CRITICAL();  
    701                  UART1_Mixer( ruler_slot_id );
    702              }
    703              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    704              if( OS_ERR_NONE == err ) {
    705                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    706                  if( OS_ERR_TIMEOUT == err ) {
    707                      APP_TRACE_INFO_T(("Read_Ruler_Type[%d] timeout",ruler_slot_id));
    708                  } else {
    709                      Global_Ruler_Type[ruler_slot_id] =  pEBuf_Data->data[0] ;
    710                      err = Ruler_CMD_Result; //exe result from GACK 
    711                      if(OS_ERR_NONE != err ){
    712                          APP_TRACE_INFO_T(("Get_Ruler_Type[%d] err = %d",ruler_slot_id,err));
    713                      }
    714                  }          
    715                  
    716              } else {
    717                  APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_slot_id,err));        
    718              }       
    719              OSSemPost( UART_MUX_Sem_lock );    
    720              return err ;    
    721          }
    722          
    723          
    724          /*
    725          *********************************************************************************************************
    726          *                                       Read_Ruler_Status()
    727          *
    728          * Description : Get back specified ruler's POST status.
    729          *             
    730          * Argument(s) : ruler_slot_id: 0~ 3.
    731          *               status_data:   pointer to the address that store the read status data 
    732          * Return(s)   : NO_ERR :   execute successfully
    733          *               others :   =error code .           
    734          *
    735          * Note(s)     : None.
    736          *********************************************************************************************************
    737          */
    738          unsigned char Read_Ruler_Status( unsigned char ruler_slot_id, unsigned short *status_data )
    739          {    
    740              unsigned char err ;
    741              EMB_BUF        *pEBuf_Data; 
    742              unsigned char buf[] = { RULER_CMD_RAED_RULER_STATUS };
    743              
    744          #if OS_CRITICAL_METHOD == 3u
    745              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    746          #endif 
    747              
    748              pEBuf_Data  = &Emb_Buf_Data; //Golbal var
    749              //check ruler connection state 
    750              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
    751                  return RULER_STATE_ERR ;         
    752              } 
    753              OSSemPend( UART_MUX_Sem_lock, 0, &err ); 
    754              if( Global_Ruler_Index != ruler_slot_id ) {
    755                  Check_UART_Mixer_Ready();
    756                  //OS_ENTER_CRITICAL(); 
    757                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    758                  //OS_EXIT_CRITICAL();  
    759                  UART1_Mixer( ruler_slot_id );
    760              }
    761              
    762              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    763              if( OS_ERR_NONE == err ) {
    764                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    765                  if( OS_ERR_TIMEOUT == err ) {
    766                      APP_TRACE_INFO_T(("Read_Ruler_Status[%d] timeout",ruler_slot_id));
    767                  } else {
    768                      *status_data = (pEBuf_Data->data[1] << 8) + pEBuf_Data->data[0] ;       
    769                      err = Ruler_CMD_Result; //exe result from GACK
    770                      if(OS_ERR_NONE != err ){
    771                          APP_TRACE_INFO_T(("Read_Ruler_Status[%d] err = %d",ruler_slot_id,err));
    772                      } 
    773                  }   
    774                  
    775              } else {
    776                  APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_slot_id,err));
    777              }        
    778              OSSemPost( UART_MUX_Sem_lock );    
    779              return err ;    
    780          }
    781          
    782          
    783          /*
    784          *********************************************************************************************************
    785          *                                       Read_Ruler_Info()
    786          *
    787          * Description : Get back specified ruler's infomation data.
    788          *               And the read back data is stored in global varies : Emb_Buf_Data
    789          * Argument(s) : ruler_slot_id: 0~ 3.
    790          * Return(s)   : NO_ERR :   execute successfully
    791          *               others :   =error code . ruler connection error,           
    792          *
    793          * Note(s)     : None.
    794          *********************************************************************************************************
    795          */
    796          unsigned char Read_Ruler_Info( unsigned char ruler_slot_id )
    797          {    
    798              unsigned char  err ; 
    799              unsigned char  buf[] = { RULER_CMD_RAED_RULER_INFO }; 
    800              
    801          #if OS_CRITICAL_METHOD == 3u
    802              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    803          #endif 
    804           
    805              //check ruler connection state 
    806              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_CONFIGURED ) {      
    807                  return RULER_STATE_ERR ;         
    808              }    
    809              OSSemPend( UART_MUX_Sem_lock, 0, &err );  
    810              if( Global_Ruler_Index != ruler_slot_id ) {
    811                  Check_UART_Mixer_Ready();
    812                  //OS_ENTER_CRITICAL(); 
    813                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    814                  //OS_EXIT_CRITICAL();  
    815                  UART1_Mixer( ruler_slot_id );
    816              }
    817              
    818              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    819              if( OS_ERR_NONE == err ) {
    820                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    821                  if( OS_ERR_TIMEOUT == err ) {
    822                      APP_TRACE_INFO_T(("Read_Ruler_Info[%d] timeout",ruler_slot_id));
    823                  } else {
    824                      err = Ruler_CMD_Result;
    825                      if(OS_ERR_NONE != err ){
    826                          APP_TRACE_INFO_T(("Read_Ruler_Info[%d] err = %d",ruler_slot_id,err));
    827                      }
    828                  }
    829                  
    830              } else {
    831                  APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_slot_id,err));
    832              }    
    833              OSSemPost( UART_MUX_Sem_lock );    
    834              return err ;    
    835          }
    836          
    837          
    838          /*
    839          *********************************************************************************************************
    840          *                                       Write_Ruler_Info()
    841          *
    842          * Description : Write infomation data to specified ruler.
    843          *               And before this function is called, the data to be written need have been stored in global varies : Emb_Buf_Cmd
    844          * Argument(s) : ruler_slot_id: 0~ 3.
    845          * Return(s)   : NO_ERR :   execute successfully
    846          *               others :   =error code .       
    847          *
    848          * Note(s)     : None.
    849          *********************************************************************************************************
    850          */
    851          unsigned char Write_Ruler_Info( unsigned char ruler_slot_id )
    852          {
    853              unsigned char   err;
    854              unsigned short  data_length;
    855              unsigned char   temp;
    856              unsigned char  *pdata;
    857              unsigned char   buf[4];  
    858              EMB_BUF        *pEBuf_Cmd;        
    859            
    860           #if OS_CRITICAL_METHOD == 3u
    861              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    862          #endif 
    863              
    864              pEBuf_Cmd  = &Emb_Buf_Cmd; //Golbal var
    865              buf[0] =  RULER_CMD_WRITE_RULER_INFO;
    866              buf[1] =  EMB_DATA_FRAME;  
    867              buf[2] = (pEBuf_Cmd->length) & 0xFF;    
    868              buf[3] = ((pEBuf_Cmd->length)>>8) & 0xFF;     
    869          
    870              //check ruler connection state 
    871              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_CONFIGURED ) {      
    872                  return RULER_STATE_ERR ;         
    873              } 
    874              OSSemPend( UART_MUX_Sem_lock, 0, &err );    
    875              if( Global_Ruler_Index != ruler_slot_id ) {
    876                  Check_UART_Mixer_Ready();
    877                  //OS_ENTER_CRITICAL(); 
    878                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    879                  //OS_EXIT_CRITICAL();  
    880                  UART1_Mixer( ruler_slot_id );
    881              }  
    882              
    883              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    884              if( OS_ERR_NONE != err ) { return err ; }
    885              pdata = pEBuf_Cmd->data;
    886              data_length = pEBuf_Cmd->length;
    887              while( data_length > 0 ){ 
    888                  temp = data_length > (NOAH_CMD_DATA_MLEN-1) ? (NOAH_CMD_DATA_MLEN-1) : data_length ;  
    889                  err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, pdata, temp, 0, buf, 1 ) ; 
    890                  if( OS_ERR_NONE != err ) { break;}
    891                  OSTimeDly(50); //wait for ruler operation
    892                  data_length -= temp;
    893                  pdata += temp;
    894              }
    895              if( OS_ERR_NONE == err ) {
    896                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    897                  if( OS_ERR_TIMEOUT == err ) {
    898                      APP_TRACE_INFO_T(("Write_Ruler_Info[%d] timeout",ruler_slot_id));
    899                  } else {
    900                      err = Ruler_CMD_Result; //exe result from GACK
    901                      if(OS_ERR_NONE != err ){
    902                          APP_TRACE_INFO_T(("Write_Ruler_Info[%d] err = %d",ruler_slot_id,err));
    903                      }
    904                  }
    905                  
    906              } else {
    907                  APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_slot_id,err));
    908              }
    909              OSSemPost( UART_MUX_Sem_lock );
    910              
    911              return err ;
    912              
    913          }
    914          
    915          
    916          /*
    917          *********************************************************************************************************
    918          *                                       Read_Mic_Cali_Data()
    919          *
    920          * Description : Get back specified ruler specified mic's calibration data.
    921          *               And the read back data is stored in global varies : Emb_Buf_Data
    922          * Argument(s) : ruler_slot_id : 0~ 3.
    923          *               mic_id        : 0~ 7
    924          * Return(s)   : NO_ERR :   execute successfully
    925          *               others :   =error code .  
    926          *
    927          * Note(s)     : None.
    928          *********************************************************************************************************
    929          */
    930          unsigned char Read_Mic_Cali_Data(unsigned char ruler_slot_id, unsigned char mic_id)
    931          {    
    932              unsigned char  err ; 
    933              unsigned char  buf[] = { RULER_CMD_READ_MIC_CALI_DATA, mic_id }; 
    934              
    935          #if OS_CRITICAL_METHOD == 3u
    936              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    937          #endif 
    938           
    939              //check ruler connection state 
    940              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_CONFIGURED ) {      
    941                  return RULER_STATE_ERR ;         
    942              }   
    943             
    944              OSSemPend( UART_MUX_Sem_lock, 0, &err );   
    945              if( Global_Ruler_Index != ruler_slot_id ) {
    946                  Check_UART_Mixer_Ready();
    947                  //OS_ENTER_CRITICAL(); 
    948                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
    949                  //OS_EXIT_CRITICAL();  
    950                  UART1_Mixer( ruler_slot_id );
    951              }
    952              
    953              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
    954              if( OS_ERR_NONE == err ) {
    955                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
    956                  if( OS_ERR_TIMEOUT == err ) {
    957                      APP_TRACE_INFO_T(("Read_Mic_Cali_Data[%d] timeout",ruler_slot_id));
    958                  } else {
    959                      err = Ruler_CMD_Result; 
    960                      if(OS_ERR_NONE != err ){
    961                          APP_TRACE_INFO_T(("Read_Mic_Cali_Data[%d] err = %d",ruler_slot_id,err));
    962                      }
    963                  }
    964                  
    965              } else {
    966                  APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_slot_id,err));
    967              }      
    968              OSSemPost( UART_MUX_Sem_lock );    
    969              return err ;    
    970          }
    971          
    972          
    973          /*
    974          *********************************************************************************************************
    975          *                                       Write_Mic_Cali_Data()
    976          *
    977          * Description : Write calibration data to specified ruler specified mic.
    978          *               And before this function is called, the data to be written need have been stored in global varies : Emb_Buf_Cmd
    979          * Argument(s) : ruler_slot_id : 0~ 3.
    980          *               mic_id        : 0~ 7
    981          * Return(s)   : NO_ERR :   execute successfully
    982          *               others :   =error code .    
    983          *
    984          * Note(s)     : None.
    985          *********************************************************************************************************
    986          */
    987          unsigned char Write_Mic_Cali_Data(unsigned char ruler_slot_id, unsigned char mic_id)
    988          {    
    989              unsigned char   err;
    990              unsigned short  data_length;
    991              unsigned char   temp;
    992              unsigned char  *pdata;
    993              unsigned char   buf[5];  
    994              EMB_BUF        *pEBuf_Cmd;        
    995            
    996           #if OS_CRITICAL_METHOD == 3u
    997              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
    998          #endif 
    999              
   1000              pEBuf_Cmd  = &Emb_Buf_Cmd; //Golbal var
   1001              buf[0] =  RULER_CMD_WRITE_MIC_CALI_DATA; 
   1002              buf[1] =  mic_id;  
   1003              buf[2] =  EMB_DATA_FRAME;  
   1004              buf[3] = (pEBuf_Cmd->length) & 0xFF;    
   1005              buf[4] = ((pEBuf_Cmd->length)>>8) & 0xFF;     
   1006          
   1007              //check ruler connection state 
   1008              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_CONFIGURED ) {      
   1009                  return RULER_STATE_ERR ;         
   1010              } 
   1011              OSSemPend( UART_MUX_Sem_lock, 0, &err ); 
   1012              if( Global_Ruler_Index != ruler_slot_id ) {
   1013                  Check_UART_Mixer_Ready();
   1014                  //OS_ENTER_CRITICAL(); 
   1015                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
   1016                  //OS_EXIT_CRITICAL();  
   1017                  UART1_Mixer( ruler_slot_id );
   1018              } 
   1019              
   1020              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
   1021              if( OS_ERR_NONE != err ) { return err ; }
   1022              pdata = pEBuf_Cmd->data;
   1023              data_length = pEBuf_Cmd->length;
   1024              while( data_length > 0 ){ 
   1025                  temp = data_length > (NOAH_CMD_DATA_MLEN-2) ? (NOAH_CMD_DATA_MLEN-2) : data_length ;  
   1026                  err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, pdata, temp, 0, buf, 2 ) ; 
   1027                  if( OS_ERR_NONE != err ) { break;}
   1028                  OSTimeDly(50); //wait for ruler operation       
   1029                  data_length -= temp;
   1030                  pdata += temp;        
   1031              }
   1032              if( OS_ERR_NONE == err ) {
   1033                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
   1034                  if( OS_ERR_TIMEOUT == err ) {
   1035                      APP_TRACE_INFO_T(("Write_Mic_Cali_Data[%d][%d] timeout",ruler_slot_id, mic_id));
   1036                  } else {
   1037                      err = Ruler_CMD_Result; //exe result from GACK
   1038                      if(OS_ERR_NONE != err ){
   1039                          APP_TRACE_INFO_T(("Write_Mic_Cali_Data[%d] err = %d",ruler_slot_id,err));
   1040                      }
   1041                  }
   1042              } else {
   1043                  APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_slot_id,err));
   1044              }
   1045              OSSemPost( UART_MUX_Sem_lock );
   1046              
   1047              return err ;
   1048              
   1049          }
   1050          
   1051          
   1052          /*
   1053          *********************************************************************************************************
   1054          *                                       Update_Mic_Mask()
   1055          *
   1056          * Description : Update specified ruler's all mic's active state.
   1057          * Argument(s) : ruler_slot_id : 0~ 3.
   1058          *               mic_mask      : bit[0..31]. 0 - deactive, 1 - active.
   1059          * Return(s)   : NO_ERR :   execute successfully
   1060          *               others :   =error code .    
   1061          *
   1062          * Note(s)     : Support: Ruler(8Mic) for Ruler
   1063          *                        Handset(16Mic) for H01/H02/H02A
   1064          *                        Handset(18Mic) for H03
   1065          *********************************************************************************************************
   1066          */
   1067          unsigned char Update_Mic_Mask( unsigned char ruler_slot_id, unsigned int mic_mask )
   1068          {    
   1069              unsigned char err ;
   1070              unsigned char buf_size_send ;
   1071              unsigned char buf[] = { RULER_CMD_TOGGLE_MIC, mic_mask&0xFF, (mic_mask>>8)&0xFF,
   1072                                      (mic_mask>>16)&0xFF,  (mic_mask>>24)&0xFF };
   1073              
   1074          #if OS_CRITICAL_METHOD == 3u
   1075              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
   1076          #endif 
   1077              //check ruler connection state 
   1078              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_CONFIGURED ) {      
   1079                  return RULER_STATE_ERR ;         
   1080              }  
   1081              
   1082              OSSemPend( UART_MUX_Sem_lock, 0, &err );  
   1083              if( Global_Ruler_Index != ruler_slot_id ) {
   1084                  Check_UART_Mixer_Ready();
   1085                  //OS_ENTER_CRITICAL(); 
   1086                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
   1087                  //OS_EXIT_CRITICAL();  
   1088                  UART1_Mixer( ruler_slot_id );
   1089              }
   1090              if( Global_Ruler_Type[ruler_slot_id] == RULER_TYPE_H03 ) {
   1091                  buf_size_send = 5; //H03 cmd data size = 1+4 for 16> mic
   1092              } else {
   1093                  buf_size_send = 3; //Default cmd data size = 1+2 for <16 mic
   1094              }
   1095              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, buf_size_send, 0, NULL, 0 ) ; 
   1096              if( OS_ERR_NONE == err ) {
   1097                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
   1098                  if( OS_ERR_TIMEOUT == err ) {
   1099                      APP_TRACE_INFO_T(("Update_Mic_Mask for Ruler[%d] timeout",ruler_slot_id));
   1100                  }
   1101                  
   1102              } else {
   1103                  APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_slot_id,err));
   1104              }
   1105              OSSemPost( UART_MUX_Sem_lock );    
   1106              return err ;    
   1107          }
   1108          
   1109          /*
   1110          *********************************************************************************************************
   1111          *                                       Ruler_Active_Control()
   1112          *
   1113          * Description : Active/Deactive ruler(LED)when play and record start/stop.  
   1114          * Argument(s) : active_state : 0 - deactive ruler (LED)
   1115          *                              1 - active ruler (LED).
   1116          * Return(s)   : NO_ERR :   execute successfully
   1117          *               others :   =error code .    
   1118          *
   1119          * Note(s)     : Support Ruler(8Mic) and Handset(16Mic)
   1120          *********************************************************************************************************
   1121          */
   1122          unsigned char Ruler_Active_Control( unsigned char active_state )  
   1123          {    
   1124              unsigned char err ;
   1125              unsigned char ruler_id;
   1126              unsigned char buf[] = { RULER_CMD_ACTIVE_CTR, active_state };
   1127          
   1128          #if OS_CRITICAL_METHOD == 3u
   1129              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
   1130          #endif 
   1131              
   1132              err = 0;        
   1133              
   1134              for( ruler_id = 0 ; ruler_id < 4 ; ruler_id++ ) {   
   1135                  //check ruler connection state 
   1136                  if( //RULER_TYPE_MASK(Global_Ruler_Type[ruler_id]) == RULER_TYPE_HANDSET ||
   1137                      Global_Ruler_State[ruler_id] < RULER_STATE_CONFIGURED || 
   1138                      Global_Mic_Mask[ruler_id] == 0 ) {      
   1139                      continue;       
   1140                  } 
   1141                  APP_TRACE_INFO_T(("Ruler[%d]_Active_Control : [%d]",ruler_id,active_state));      
   1142                  OSSemPend( UART_MUX_Sem_lock, 0, &err );
   1143                  if( Global_Ruler_Index != ruler_id ) {
   1144                      Check_UART_Mixer_Ready();
   1145                      //OS_ENTER_CRITICAL(); 
   1146                      Global_Ruler_Index = ruler_id ; //for ruler status switch in TX/RX/Noah 
   1147                      //OS_EXIT_CRITICAL();  
   1148                      UART1_Mixer( ruler_id );
   1149                  }   
   1150                  err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
   1151                  if( OS_ERR_NONE == err ) {
   1152                      OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
   1153                      if( OS_ERR_TIMEOUT == err ) {
   1154                          APP_TRACE_INFO_T(("Ruler[%d]_Active_Control timeout",ruler_id));
   1155                      } else {
   1156                          err = Ruler_CMD_Result; //exe result from GACK
   1157                          if(OS_ERR_NONE != err ){
   1158                              APP_TRACE_INFO_T(("Ruler[%d]_Active_Control err = %d",ruler_id,err));
   1159                          }
   1160                      }
   1161                      
   1162                  } else {
   1163                      APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_id,err));
   1164                  }    
   1165                  OSSemPost( UART_MUX_Sem_lock );
   1166                  if( err != NO_ERR ) {
   1167                      break;
   1168                  }
   1169              }        
   1170              return err ;    
   1171          }
   1172          
   1173          
   1174          /*
   1175          *********************************************************************************************************
   1176          *                                       Get_Ruler_Version()
   1177          *
   1178          * Description : Get back specified ruler's version info.
   1179          *               And the version data is stored in global varies : Emb_Buf_Data
   1180          * Argument(s) : ruler_slot_id : 0~ 3.
   1181          * Return(s)   : NO_ERR :   execute successfully
   1182          *               others :   =error code .  
   1183          *
   1184          * Note(s)     : None.
   1185          *********************************************************************************************************
   1186          */
   1187          unsigned char Get_Ruler_Version( unsigned char ruler_slot_id )
   1188          {  
   1189              unsigned char err ;
   1190              unsigned char buf[] = { RULER_CMD_GET_RULER_VERSION };
   1191              EMB_BUF      *pEBuf_Data;         
   1192                
   1193              pEBuf_Data  = &Emb_Buf_Data;  //Global var   
   1194              
   1195          #if OS_CRITICAL_METHOD == 3u
   1196              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
   1197          #endif 
   1198              //check ruler connection state 
   1199              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
   1200                  return RULER_STATE_ERR ;         
   1201              }  
   1202              
   1203              OSSemPend( UART_MUX_Sem_lock, 0, &err ); 
   1204              if( Global_Ruler_Index != ruler_slot_id ) {
   1205                  Check_UART_Mixer_Ready();
   1206                  //OS_ENTER_CRITICAL(); 
   1207                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
   1208                  //OS_EXIT_CRITICAL();  
   1209                  UART1_Mixer( ruler_slot_id );
   1210              }
   1211              
   1212              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
   1213              if( OS_ERR_NONE == err ) {
   1214                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
   1215                  if( OS_ERR_TIMEOUT == err ) {
   1216                      APP_TRACE_INFO_T(("Get_Ruler_Version[%d] timeout",ruler_slot_id));
   1217                  } else {
   1218                      err = Ruler_CMD_Result;
   1219                      if(OS_ERR_NONE != err ){
   1220                          APP_TRACE_INFO_T(("Get_Ruler_Version[%d] err = %d",ruler_slot_id,err));
   1221                      }
   1222                  }
   1223                  if(err == OS_ERR_NONE ) {
   1224                      APP_TRACE_INFO_T(("Ruler[%d] FW Version: %s",ruler_slot_id, pEBuf_Data->data)); 
   1225                  }
   1226                  
   1227              } else {
   1228                  APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_slot_id,err));
   1229              }    
   1230              OSSemPost( UART_MUX_Sem_lock );    
   1231              return err ;        
   1232          }
   1233            
   1234          
   1235          
   1236          /*
   1237          *********************************************************************************************************
   1238          *                                       FLASHD_Write_Safe()
   1239          *
   1240          * Description : Add code area protection for FLASHD_Write()
   1241          *               Writes a data buffer in the internal flash. This function works in polling
   1242          *               mode, and thus only returns when the data has been effectively written.    
   1243          * Argument(s) :  address  Write address.
   1244          *                pBuffer  Data buffer.
   1245          *                size     Size of data buffer in bytes.
   1246          * Return(s)   : NO_ERR :   execute successfully
   1247          *               others :   =error code .  
   1248          *
   1249          * Note(s)     : None.
   1250          *********************************************************************************************************
   1251          */
   1252          unsigned char FLASHD_Write_Safe( unsigned int address, const void *pBuffer,  unsigned int size)
   1253          {
   1254              unsigned char err;
   1255              if( address < AT91C_IFLASH + AT91C_IFLASH_CODE_SIZE ) {
   1256                  APP_TRACE_INFO_T(("ERROR: this operation wanna flush code area!"));  
   1257                  return FW_BIN_SAVE_ADDR_ERR;
   1258              }
   1259              err = FLASHD_Write(  address, pBuffer, size );
   1260              return err;  
   1261              
   1262          }
   1263          
   1264          
   1265          /*
   1266          *********************************************************************************************************
   1267          *                                       Read_Flash_State()
   1268          *
   1269          * Description : Save ruler FW bin file to flash
   1270          *               
   1271          * Argument(s) : *pFlash_Info : pointer to FLASH_INFO type data where to save read data
   1272          *
   1273          * Return(s)   : None.
   1274          *
   1275          * Note(s)     : None.
   1276          *********************************************************************************************************
   1277          */
   1278          void Read_Flash_State( FLASH_INFO  *pFlash_Info )
   1279          {
   1280              
   1281              *pFlash_Info = *(FLASH_INFO *)FLASH_ADDR_FW_STATE ;    
   1282              
   1283          }
   1284          
   1285          
   1286          /*
   1287          *********************************************************************************************************
   1288          *                                       Write_Flash_State()
   1289          *
   1290          * Description : Save ruler FW bin file to flash
   1291          *               
   1292          * Argument(s) : *pFlash_Info : pointer to FLASH_INFO type data need to be saved
   1293          *
   1294          * Return(s)   : NO_ERR :   execute successfully
   1295          *               others :   =error code .  
   1296          *
   1297          * Note(s)     : None.
   1298          *********************************************************************************************************
   1299          */
   1300          unsigned char Write_Flash_State( FLASH_INFO   *pFlash_Info )
   1301          {
   1302              
   1303              unsigned char err;   
   1304              //save state to flash
   1305              pFlash_Info->s_w_counter++ ;
   1306              err = FLASHD_Write_Safe( FLASH_ADDR_FW_STATE, pFlash_Info, AT91C_IFLASH_PAGE_SIZE); 
   1307              if(err != NO_ERR ) {                     
   1308                  APP_TRACE_INFO_T(("ERROR: Write flash state failed!"));  
   1309              }
   1310              
   1311              return err;
   1312              
   1313          }
   1314          
   1315          
   1316          /*
   1317          *********************************************************************************************************
   1318          *                                       Save_Ruler_FW()
   1319          *
   1320          * Description : Save ruler FW bin file to flash
   1321          *               
   1322          * Argument(s) :  cmd  :  1~ 3.
   1323          *               *pBin : pointer to bin file data packge to be wriiten to flash
   1324          *               *pStr : pointer to file name string
   1325          *                size : bin package file size 
   1326          *
   1327          * Return(s)   : NO_ERR :   execute successfully
   1328          *               others :   =error code .  
   1329          *
   1330          * Note(s)     : None.
   1331          *********************************************************************************************************
   1332          */
   1333          unsigned char Save_Ruler_FW( unsigned int cmd, unsigned char *pBin, unsigned char *pStr, unsigned int size )
   1334          {  
   1335              unsigned char err; 
   1336              static unsigned int flash_addr = FLASH_ADDR_FW_BIN;
   1337           
   1338              FLASH_INFO    flash_info;
   1339              
   1340              err = NO_ERR;
   1341              Read_Flash_State(&flash_info);
   1342               
   1343              switch( cmd ) {
   1344                  case FW_DOWNLAD_CMD_START :
   1345                      APP_TRACE_INFO_T(("Start loading ruler bin file to AB01 flash ... "));
   1346                      flash_addr = FLASH_ADDR_FW_BIN;                
   1347                      flash_info.f_w_state = FW_DOWNLAD_STATE_UNFINISHED ;
   1348                      flash_info.bin_size  = 0;
   1349                  break;   
   1350                  case FW_DOWNLAD_CMD_DOING :
   1351                      APP_TRACE_INFO_T(("> ")); 
   1352                      if( flash_info.f_w_state != FW_DOWNLAD_STATE_UNFINISHED ) {
   1353                          APP_TRACE_INFO_T(("ERROR: flash state not match!"));
   1354                          err  =  FW_BIN_STATE_0_ERR;                
   1355                      } 
   1356                  break;
   1357                  case FW_DOWNLAD_CMD_DONE :
   1358                      APP_TRACE_INFO_T((">")); 
   1359                      if( flash_info.f_w_state != FW_DOWNLAD_STATE_UNFINISHED ) {
   1360                          APP_TRACE_INFO_T(("ERROR: flash state not match!"));
   1361                          err  =  FW_BIN_STATE_1_ERR;
   1362                          break;
   1363                      }
   1364                      flash_info.f_w_state = FW_DOWNLAD_STATE_FINISHED ;
   1365                      flash_info.f_w_counter++;            
   1366                   break;
   1367                   
   1368                   default:
   1369                      APP_TRACE_INFO_T(("ERROR:  Save ruler FW bad cmd!"));
   1370                      err = FW_BIN_SAVE_CMD_ERR;    
   1371                   break;
   1372                  
   1373              }
   1374              if( err != NO_ERR ) {
   1375                  return err;
   1376              }    
   1377              Buzzer_OnOff(1);               
   1378              LED_Toggle(LED_DS2);    
   1379              err = FLASHD_Write_Safe( flash_addr, pBin, size ); 
   1380              Buzzer_OnOff(0); 
   1381              if(err != NO_ERR ) {                     
   1382                  APP_TRACE_INFO_T(("ERROR: Write MCU flash failed!"));
   1383                  return err;
   1384              }
   1385              flash_addr += size;
   1386              flash_info.bin_size   = flash_addr - FLASH_ADDR_FW_BIN ;
   1387              strcpy(flash_info.bin_name, (char const*)pStr);  
   1388              if( cmd != FW_DOWNLAD_CMD_DOING ) {        
   1389                  err = Write_Flash_State( &flash_info ); 
   1390                  if( err == NO_ERR && cmd == FW_DOWNLAD_CMD_DONE ) { 
   1391                        APP_TRACE_INFO_T(("Bin file[%d Btyes] saved successfully!",flash_info.bin_size));     
   1392                  }   
   1393              } 
   1394              return err;  
   1395              
   1396          }
   1397          
   1398          
   1399          
   1400          /*
   1401          *********************************************************************************************************
   1402          *                                       Update_Ruler_FW()
   1403          *
   1404          * Description :  Write firmware to specified ruler's MCU flash
   1405          *               
   1406          * Argument(s) :  ruler_slot_id :  0~ 3.     
   1407          *
   1408          * Return(s)   : NO_ERR :   execute successfully
   1409          *               others :   =error code .  
   1410          *
   1411          * Note(s)     : Do not care if ruler is attached or not.Because host can not detect ruler if FW was crashed.
   1412          *********************************************************************************************************
   1413          */
   1414          unsigned char Update_Ruler_FW( unsigned char ruler_slot_id )
   1415          {
   1416              unsigned char err;
   1417              unsigned int  flash_addr; 
   1418              FLASH_INFO   *pFlash_Info;
   1419              unsigned char Buf[9];
   1420              unsigned char i;
   1421              
   1422              err = NO_ERR;
   1423              flash_addr  = FLASH_ADDR_FW_BIN;
   1424              pFlash_Info = (FLASH_INFO *)FLASH_ADDR_FW_STATE ;
   1425                  
   1426              if( pFlash_Info->f_w_state != FW_DOWNLAD_STATE_FINISHED ) {
   1427                  APP_TRACE_INFO_T(("ERROR: FW bin file missed!"));        
   1428                  return FW_BIN_STATE_ERR;
   1429              }
   1430              
   1431              APP_TRACE_INFO_T(("Start updating ruler[%d] firmware to \"%s\" version ...",ruler_slot_id,pFlash_Info->bin_name)); 
   1432              memset(Buf,'d',sizeof(Buf)); //send 'd' to start download  
   1433              Ruler_Power_Switch(0);   //power off ruler  
   1434              OSTimeDly(200);   
   1435              for( i = 0; i < 4; i++ ) {
   1436                  Global_Ruler_State[i] = RULER_STATE_DETACHED ;
   1437              }
   1438              UART_Init(RULER_UART,  NULL,  115200 );   //Init Ruler to inquire mode
   1439              Port_Detect_Enable(0); //disable ruler detect
   1440              
   1441              OSSemPend( UART_MUX_Sem_lock, 0, &err ); 
   1442              if( Global_Ruler_Index != ruler_slot_id ) {
   1443                  Check_UART_Mixer_Ready();
   1444                  //OS_ENTER_CRITICAL(); 
   1445                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
   1446                  //OS_EXIT_CRITICAL();  
   1447                  UART1_Mixer( ruler_slot_id );
   1448              }
   1449              
   1450              Ruler_Power_Switch(1);   //power on ruler
   1451              OSTimeDly(200);
   1452              err = USART_SendBuf( RULER_UART, Buf,  sizeof(Buf));
   1453              if( OS_ERR_NONE == err ) {     
   1454                  OSTimeDly(800);
   1455                  err = USART_Read_Timeout( RULER_UART, Buf, 3, 5000 );
   1456                  if( OS_ERR_NONE == err && ( Buf[0] == 'c' || Buf[0] == 'C' )) {
   1457                      Global_Ruler_State[ruler_slot_id] = RULER_STATE_RUN ;
   1458                      err = Xmodem_Transmit( (unsigned char *)flash_addr, pFlash_Info->bin_size );
   1459                      Global_Ruler_State[ruler_slot_id] = RULER_STATE_DETACHED ;            
   1460                  }         
   1461              }
   1462              if( OS_ERR_NONE != err ) {
   1463                  APP_TRACE_INFO_T(("Failed to init ruler bootloader. Err Code = [0x%X]", err));        
   1464              } else {
   1465                  APP_TRACE_INFO_T(("Update ruler[%d] firmware successfully!", ruler_slot_id));   
   1466              }
   1467              Port_Detect_Enable(1); //enable ruler detect
   1468              UART_Init(RULER_UART,  ISR_Ruler_UART,  115200 );  //Init Ruler back to interuption mode
   1469              Ruler_Power_Switch(0);   //power off ruler  
   1470              OSTimeDly(500);    
   1471              Ruler_Power_Switch(1);   //power on ruler
   1472              OSSemPost( UART_MUX_Sem_lock ); 
   1473              return err ;    
   1474              
   1475          }
   1476          //unsigned char Update_Ruler_FW( unsigned char ruler_slot_id )
   1477          //{
   1478          //    unsigned char err;
   1479          //    unsigned int  flash_addr; 
   1480          //    FLASH_INFO   *pFlash_Info;
   1481          //    
   1482          //    err = NO_ERR;
   1483          //    flash_addr  = FLASH_ADDR_FW_BIN;
   1484          //    pFlash_Info = (FLASH_INFO *)FLASH_ADDR_FW_STATE ;
   1485          //        
   1486          //    if( pFlash_Info->f_w_state != FW_DOWNLAD_STATE_FINISHED ) {
   1487          //        APP_TRACE_INFO_T(("ERROR: FW bin file missed!"));        
   1488          //        return FW_BIN_STATE_ERR;
   1489          //    }
   1490          //    
   1491          //    APP_TRACE_INFO_T(("Start updating MCU FW to [%s] on ruler[%d]...",pFlash_Info->bin_name,ruler_slot_id)); 
   1492          //    
   1493          //    UART_Init(RULER_UART,  NULL,  115200 );    //Init Ruler as no ISR  
   1494          //    
   1495          //    UART1_Mixer( ruler_slot_id );
   1496          //    Check_UART_Mixer_Ready();
   1497          //    if( USART_Start_Ruler_Bootloader() ) {  
   1498          //        APP_TRACE_INFO_T(("Failed to init ruler bootloader!"));     
   1499          //    }
   1500          //    
   1501          //    err = Xmodem_Transmit( (unsigned char *)flash_addr, pFlash_Info->bin_size);      
   1502          //         
   1503          //    UART_Init(RULER_UART,  ISR_Ruler_UART,  115200 );    //Init Ruler back to ISR 
   1504          //    
   1505          //    return err ;    
   1506          //    
   1507          //}
   1508          
   1509          
   1510          /*
   1511          *********************************************************************************************************
   1512          *                                       Toggle_Mic()
   1513          *
   1514          * Description : Toggle specified mic's active state by sending command to related ruler and updating 
   1515          *               FPGA mic signal switch array. 
   1516          *               One mic One time.
   1517          * Argument(s) : pdata : pointer to TOGGLE_MIC structure data
   1518          * Return(s)   : NO_ERR :   execute successfully
   1519          *               others :   =error code .  
   1520          *
   1521          * Note(s)     : None.
   1522          *********************************************************************************************************
   1523          */
   1524          unsigned char Toggle_Mic(  TOGGLE_MIC *pdata )
   1525          {  
   1526              unsigned char  err ;
   1527              unsigned char  id;
   1528              unsigned int   mic_mask;  
   1529              unsigned int   fpga_mask;
   1530              
   1531          #if OS_CRITICAL_METHOD == 3u
   1532              OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
   1533          #endif 
   1534              fpga_mask = 0;
   1535              APP_TRACE_INFO_T(("Toggle Ruler[%d]-Mic[%d] : %d  : ", pdata->ruler_id, pdata->mic_id, pdata->on_off )); 
   1536              //check ruler connection state 
   1537              if( Global_Ruler_State[pdata->ruler_id] < RULER_STATE_CONFIGURED ) {      
   1538                  return RULER_STATE_ERR ;         
   1539              }  
   1540                OS_ENTER_CRITICAL(); 
   1541              mic_mask = Global_Mic_Mask[pdata->ruler_id];
   1542              OS_EXIT_CRITICAL();  
   1543              mic_mask &= ~( 1<<(pdata->mic_id));
   1544              mic_mask |=  (pdata->on_off&0x01)<<( pdata->mic_id);
   1545              err = Update_Mic_Mask( pdata->ruler_id, mic_mask );
   1546              APP_TRACE_INFO((" %s [0x%X]", err == OS_ERR_NONE ? "OK" : "FAIL" , err )); 
   1547              if( OS_ERR_NONE != err ) {        
   1548                  return err;    
   1549              }
   1550              OS_ENTER_CRITICAL(); 
   1551              Global_Mic_Mask[pdata->ruler_id] = mic_mask; 
   1552              //APP_TRACE_INFO_T(("Update Ruler[%d] Mic_Mask:  %d",pdata->ruler_id,Global_Mic_Mask[pdata->ruler_id]));   
   1553              if( mic_mask == 0 ) {      
   1554                  Global_Ruler_State[pdata->ruler_id] = RULER_STATE_CONFIGURED;         
   1555              } else {
   1556                  Global_Ruler_State[pdata->ruler_id] = RULER_STATE_SELECTED;  
   1557              }
   1558              OS_EXIT_CRITICAL();
   1559              if( RULER_TYPE_MASK( Global_Ruler_Type[pdata->ruler_id] ) == RULER_TYPE_RULER ) { //ruler
   1560                  if( Global_Ruler_Type[pdata->ruler_id] == RULER_TYPE_W01 ) { //fix W01 mic revert bug       
   1561                      Watch_Mic_Revert( &mic_mask );        
   1562                      fpga_mask = mic_mask << ((pdata->ruler_id)<<3);            
   1563                  } else {
   1564                      for( id = 0; id < 4; id++ ) {
   1565                          fpga_mask += (Global_Mic_Mask[id]&0xFF) << (id<<3);
   1566                      }    
   1567                  }
   1568              } else { //handset
   1569                 fpga_mask = 0x3F << ((pdata->ruler_id)<<3);
   1570                 
   1571              }     
   1572              Init_FPGA(fpga_mask);
   1573              return err;  
   1574          }
   1575          
   1576          
   1577          /*
   1578          *********************************************************************************************************
   1579          *                                       Set_Volume()
   1580          *
   1581          * Description : Set DMIC PGA gain, LOUT and SPKOUT attenuation gain at the same time
   1582          *             
   1583          * Argument(s) : pdata : pointer to SET_VOLUME structure data
   1584          * Return(s)   : NO_ERR :   execute successfully
   1585          *               others :   =error code .  
   1586          *
   1587          * Note(s)     : None.
   1588          *********************************************************************************************************
   1589          */
   1590          unsigned char Set_Volume(  SET_VOLUME *pdata )
   1591          {  
   1592              unsigned char  err ;
   1593              
   1594              APP_TRACE_INFO_T(( "Set Volume :: " ));
   1595              if( pdata->mic == SET_VOLUME_MUTE ) {
   1596                  APP_TRACE_INFO(( "Mute MIC :  " ));
   1597              } else {
   1598                  APP_TRACE_INFO(( "Mic_Gain = %2d dB :  ", pdata->mic )); 
   1599              }
   1600              
   1601              if( pdata->lout == SET_VOLUME_MUTE ) {
   1602                  APP_TRACE_INFO(( "Mute LOUT :  " ));
   1603              } else {
   1604                  APP_TRACE_INFO(( "LOUT_Gain = -%2d.%1d dB :  ", pdata->lout/10, pdata->lout%10 )); 
   1605              }
   1606              
   1607              if( pdata->spk == SET_VOLUME_MUTE ) {
   1608                  APP_TRACE_INFO(( "Mute SPK :  " ));
   1609              } else {
   1610                  APP_TRACE_INFO(( "SPK_Gain = -%2d.%1d dB :  ", pdata->spk/10, pdata->spk%10 )); 
   1611              }
   1612              
   1613              //APP_TRACE_INFO_T(("Set Volume : Mic_Gain[%d]dB, LOUT_Gain[-%d.%d]dB, SPKOUT_Gain[-%d.%d]dB : ", 
   1614              //                     pdata->mic, pdata->lout/10, pdata->lout%10, pdata->spk/10, pdata->spk%10 )); 
   1615              //APP_TRACE_INFO_T(("\r\n%6.6f, %6.6f",2.31,0.005));
   1616              err = DMIC_PGA_Control( pdata->mic ); 
   1617              //APP_TRACE_INFO_T((" %s [0x%X]", err == OS_ERR_NONE ? "OK" : "FAIL" , err )); 
   1618              if( OS_ERR_NONE != err ) {  
   1619                  APP_TRACE_INFO(( "FAIL [0x%X]", err )); 
   1620                  return err;    
   1621              }
   1622              err = CODEC_Set_Volume( pdata->spk, pdata->lout );
   1623              if( OS_ERR_NONE != err ) {    
   1624                  APP_TRACE_INFO(( "FAIL [0x%X]", err )); 
   1625                  return err;    
   1626              }
   1627              APP_TRACE_INFO(( "OK" )); 
   1628              return err;  
   1629          }
   1630          
   1631          
   1632          
   1633          /*
   1634          *********************************************************************************************************
   1635          *                                       Reset_Mic_Mask()
   1636          *
   1637          * Description : Reset all mics to deactived state on the specified rulers and update FPGA mic signal switch array.
   1638          * Argument(s) : pInt : pointer to a int data, the 4 bytes of wihch control 4 ruler's all mic need be 
   1639          *               reset to deactive state or not.
   1640          *                      1 - deactive all mics on this ruler
   1641          *                      0 - do nothing. ignore the reset operation
   1642          * Return(s)   : NO_ERR :   execute successfully
   1643          *               others :   =error code .  
   1644          *
   1645          * Note(s)     : None.
   1646          *********************************************************************************************************
   1647          */
   1648          unsigned char Reset_Mic_Mask(  unsigned int *pInt )
   1649          {  
   1650              unsigned char  err ;
   1651              unsigned char  id;
   1652              unsigned char  *pChar;  
   1653              unsigned int   fpga_mask;
   1654              
   1655              fpga_mask = 0;    
   1656              pChar     = (unsigned char *)pInt;
   1657              err       = 0;
   1658          
   1659              for( id = 0; id < 4; id++ ) {        
   1660                  if( *(pChar+id) == 0 ) { 
   1661                      continue;
   1662                  }
   1663                  if( Global_Ruler_State[id] < RULER_STATE_CONFIGURED ) { //why not RULER_STATE_SELECTED  ? Because UI need reset mic in any case
   1664                      continue;
   1665                  }
   1666                  Global_Ruler_State[id] = RULER_STATE_CONFIGURED ;
   1667                  err = Update_Mic_Mask( id, 0 );
   1668                  if( OS_ERR_NONE != err ) {        
   1669                      return err;    
   1670                  } 
   1671                  Global_Mic_Mask[id] = 0;  
   1672                  if( RULER_TYPE_MASK( Global_Ruler_Type[id] ) == RULER_TYPE_RULER ) {//ruler 
   1673                      fpga_mask += (Global_Mic_Mask[id]&0xFF) << (id<<3);
   1674                      
   1675                  } else {
   1676                      fpga_mask += 0x3F << (id<<3); //handset choose the lowest slot H01
   1677                  }        
   1678              }
   1679              
   1680              Init_FPGA(fpga_mask);    
   1681              return err;  
   1682          }
   1683          
   1684          
   1685          /*
   1686          *********************************************************************************************************
   1687          *                                       Ruler_Port_LED_Service()
   1688          *
   1689          * Description : Control the ruler port identify LED state:  
   1690          *               turn on LED after ruler configured, blink LED during recording
   1691          * Argument(s) : None.
   1692          * Return(s)   : None.
   1693          * Note(s)     : None.
   1694          *********************************************************************************************************
   1695          */
   1696          void Ruler_Port_LED_Service( void )
   1697          {    
   1698              static unsigned int counter; 
   1699              static unsigned int counter_buz;    
   1700              unsigned char ruler_id;
   1701              unsigned char ruler_state;    
   1702              unsigned char LED_Freq;
   1703              unsigned char post_err_flag;
   1704          
   1705              LED_Freq      = 0x3F; 
   1706              post_err_flag = 0;
   1707              
   1708              for( ruler_id = 0 ; ruler_id < 4 ; ruler_id++ ) {
   1709                
   1710                  ruler_state = Global_Ruler_State[ruler_id];  
   1711                  if( Global_Bridge_POST != NO_ERR ) { //if POST err, start all LED 
   1712                      ruler_state = RULER_STATE_RUN ;
   1713                      post_err_flag = 1;
   1714                  }
   1715                  switch( ruler_state ) {
   1716                    
   1717                      case RULER_STATE_DETACHED :
   1718                      case RULER_STATE_ATTACHED :
   1719                          LED_Clear( LED_P0 + ruler_id );
   1720                      break;            
   1721                      case RULER_STATE_CONFIGURED :
   1722                      case RULER_STATE_SELECTED :  
   1723                          LED_Set( LED_P0 + ruler_id );
   1724                      break;            
   1725                      case RULER_STATE_RUN :
   1726                          if( (counter & LED_Freq) == 0 ) {
   1727                              LED_Toggle( LED_P0 + ruler_id );   
   1728                              if( post_err_flag== 1 && ruler_id == 0 && (counter_buz++ < 6 ) ) {
   1729                                  //Buzzer_Toggle(); //buzzer off id POST err 
   1730                                  Buzzer_OnOff( counter_buz&0x01 );   //fix long buz issue in some case                  
   1731                              }
   1732                          }
   1733                      
   1734                      default:              
   1735                      break;
   1736                  }
   1737            
   1738              }    
   1739              counter++;    
   1740          }
   1741          
   1742          
   1743          
   1744          /*
   1745          *********************************************************************************************************
   1746          *                                       AB_POST()
   1747          *
   1748          * Description : Audio bridge Power-On-Self-Test use. 
   1749          *
   1750          * Argument(s) : None.
   1751          * Return(s)   : None.
   1752          * Note(s)     : None.
   1753          *********************************************************************************************************
   1754          */
   1755          void AB_POST( void )
   1756          {
   1757              unsigned char  err;
   1758              
   1759              APP_TRACE_INFO_T(("Start Audio Bridge POST :"));    
   1760              Enable_FPGA();
   1761          
   1762              APP_TRACE_INFO_T(("1. CODEC... "));
   1763              err = Init_CODEC( SAMPLE_RATE_DEF );    
   1764              if( err != NO_ERR ) {
   1765                  Global_Bridge_POST = POST_ERR_CODEC;
   1766                  APP_TRACE_INFO_T(("---Error : %d\r\n",err));
   1767                  return ;
   1768              } else {
   1769                  APP_TRACE_INFO_T(("---OK\r\n"));
   1770              }
   1771              
   1772              APP_TRACE_INFO_T(("2. FM36 DSP... "));
   1773          #ifdef BOARD_TYPE_AB03     
   1774              err = Init_FM36_AB03( SAMPLE_RATE_DEF, 0, 1, 0 ); //Lin from SP1.Slot0
   1775              //err = Init_FM36( SAMPLE_RATE_DEF );
   1776          #else 
   1777              err = Init_FM36( SAMPLE_RATE_DEF );
   1778          #endif
   1779              if( err != NO_ERR ) {
   1780                  Global_Bridge_POST = POST_ERR_FM36;
   1781                  APP_TRACE_INFO_T(("---Error : %d\r\n",err));
   1782                  return ;
   1783              } else {
   1784                  APP_TRACE_INFO_T(("---OK\r\n"));
   1785              }  
   1786              
   1787              APP_TRACE_INFO_T(("3. AUDIO MCU... "));
   1788              err = Get_Audio_Version();
   1789              if( err != NO_ERR ) {
   1790                  Global_Bridge_POST = POST_ERR_AUDIO;
   1791                  APP_TRACE_INFO_T(("---Error : %d\r\n",err));
   1792                  return ;
   1793              } else {
   1794                  APP_TRACE_INFO_T(("---OK\r\n"));
   1795              }    
   1796             
   1797              
   1798              
   1799          //    APP_TRACE_INFO_T(("\r\n4. external CODEC... "));
   1800          //    err = Init_CODEC_AIC3204( SAMPLE_RATE_DEF );    
   1801          //    if( err != NO_ERR ) {
   1802          //        Global_Bridge_POST = POST_ERR_CODEC;
   1803          //        APP_TRACE_INFO(("\r\n---Error : %d",err));
   1804          //        return ;
   1805          //    } else {
   1806          //        APP_TRACE_INFO(("\r\n---OK"));
   1807          //    }
   1808              
   1809              //Disable_FPGA(); 
   1810              //Ruler_Power_Switch(1); 
   1811              
   1812              err = Init_CODEC( 0 );
   1813              if( err != NO_ERR ) {
   1814                  Global_Bridge_POST = POST_ERR_CODEC ;
   1815                  APP_TRACE_INFO_T(("Power Down CODEC ERROR: %d",err)); 
   1816              }
   1817              
   1818          }
   1819          
   1820          
   1821          
   1822          /*
   1823          *********************************************************************************************************
   1824          *                                       Ruler_POST()
   1825          *
   1826          * Description : Get back specified ruler Power-On-Self-Test status. 
   1827          *
   1828          * Argument(s) : ruler_id :  0~ 3
   1829          * Return(s)   : NO_ERR :   execute successfully
   1830          *               others :   =error code . 
   1831          * Note(s)     : None.
   1832          *********************************************************************************************************
   1833          */
   1834          unsigned char Ruler_POST( unsigned char ruler_id )
   1835          {
   1836              unsigned char  err;
   1837              unsigned short result;   
   1838              
   1839              APP_TRACE_INFO_T(("Ruler[%d] POST status check... ",ruler_id)); 
   1840          
   1841              err = Read_Ruler_Status( ruler_id, &result);
   1842              if( err == RULER_STATE_ERR ) { //no ruler attached
   1843                  return err;;
   1844              }      
   1845              if( err != NO_ERR ) {
   1846                 return err;
   1847              }
   1848              if( result != 0 ) {
   1849                  if( result != 0x8000 ) {        
   1850                      APP_TRACE_INFO_T(("---Error Ruler[%d]: %d-0x%X\r\n",ruler_id,err,result));
   1851                      return 1; 
   1852                  } else {
   1853                      APP_TRACE_INFO_T(("---WARNING Ruler[%d]: Mic calibration data NOT Initialized!\r\n",ruler_id));  
   1854                  }
   1855              } else {
   1856                  APP_TRACE_INFO_T(("---OK\r\n"));  
   1857              }
   1858              
   1859              return err;
   1860          }
   1861          
   1862          
   1863          /*
   1864          *********************************************************************************************************
   1865          *                                       simple_test_use()
   1866          *
   1867          * Description : debug use.
   1868          *
   1869          * Argument(s) : None.
   1870          * Return(s)   : None.
   1871          * Note(s)     : None.
   1872          *********************************************************************************************************
   1873          */
   1874          void simple_test_use( void )
   1875          {      
   1876              APP_TRACE_INFO_T(("\r\nHi,man. Simple play/rec test triggered..."));   
   1877              
   1878          #if 0  
   1879              
   1880           //R01      
   1881              TOGGLE_MIC toggle_mic[6] = {    
   1882                                              {0, 6, 1 }, {0, 7, 1 }, {0, 8, 1 },
   1883                                              {0, 12, 1 }, {0, 13, 1 }, {0, 14, 1 }  
   1884                                          }; 
   1885            
   1886              for (unsigned char i = 0; i< 6 ; i++ ) {
   1887                  Toggle_Mic(&toggle_mic[i]); 
   1888              } 
   1889              
   1890          #else
   1891              
   1892          //H01
   1893              Update_Mic_Mask( 0, 0x3f); 
   1894              Init_FPGA(0x3F);
   1895              Global_Ruler_State[0] = RULER_STATE_RUN; 
   1896                  
   1897              AUDIO_CFG audio_config_play = {SAMPLE_RATE_DEF, AUDIO_TYPE_PLAY, 6 };
   1898              AUDIO_CFG audio_config_rec  = {SAMPLE_RATE_DEF, AUDIO_TYPE_REC,  6 };
   1899              Setup_Audio( &audio_config_play );                   
   1900              Setup_Audio( &audio_config_rec );                 
   1901              //Start_Audio( AUDIO_START_PALYREC ); 
   1902              
   1903          #endif
   1904              
   1905          }
   1906          
   1907          
   1908          unsigned char Ruler_Setup_Sync( unsigned char ruler_slot_id )
   1909          {
   1910              unsigned char err ;
   1911              unsigned char buf[] = { RULER_CMD_SETUP_SYNC, Ruler_Setup_Sync_Data, ruler_slot_id };
   1912          
   1913          #if OS_CRITICAL_METHOD == 3u
   1914              //OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
   1915          #endif 
   1916              
   1917              //check ruler connection state 
   1918              if( Global_Ruler_State[ruler_slot_id] < RULER_STATE_ATTACHED ) {      
   1919                  return RULER_STATE_ERR ;         
   1920              } 
   1921              
   1922              OSSemPend( UART_MUX_Sem_lock, 0, &err );
   1923              if( Global_Ruler_Index != ruler_slot_id ) {
   1924                  Check_UART_Mixer_Ready();
   1925                  //OS_ENTER_CRITICAL(); 
   1926                  Global_Ruler_Index = ruler_slot_id ; //for ruler status switch in TX/RX/Noah 
   1927                  //OS_EXIT_CRITICAL();  
   1928                  UART1_Mixer( ruler_slot_id );
   1929              }
   1930              
   1931              err = pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, FRAM_TYPE_DATA, buf, sizeof(buf), 0, NULL, 0 ) ; 
   1932              if( OS_ERR_NONE == err ) {
   1933                  OSSemPend( Done_Sem_RulerUART, TIMEOUT_RULER_COM, &err );  
   1934                  if( OS_ERR_TIMEOUT == err ) {
   1935                      APP_TRACE_INFO_T(("Ruler_Setup_Sync[%d] timeout",ruler_slot_id));
   1936                  } else {
   1937                      err = Ruler_CMD_Result; //exe result from GACK
   1938                      if(OS_ERR_NONE != err ){
   1939                          APP_TRACE_INFO_T(("Ruler_Setup_Sync[%d] err = %d",ruler_slot_id,err));
   1940                      }
   1941                  }
   1942                  
   1943              } else {
   1944                  APP_TRACE_INFO_T(("Ruler[%d] pcSendDateToBuf failed: %d",ruler_slot_id,err));
   1945              }    
   1946              OSSemPost( UART_MUX_Sem_lock );    
   1947              return err ;    
   1948              
   1949              
   1950          }
   1951          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AB_POST
         8   -> BSP_Ser_Printf
         8   -> Enable_FPGA
         8   -> Get_Audio_Version
         8   -> Init_CODEC
         8   -> Init_FM36_AB03
         8   -> Time_Stamp
       0   Check_Actived_Mic_Number
      16   Check_UART_Mixer_Ready
        16   -> BSP_Ser_Printf
        16   -> OSQGet
        16   -> OSTimeDly
        16   -> Queue_NData
        16   -> Time_Stamp
      16   Check_Watch_Attach_State
        16   -> BSP_Ser_Printf
        16   -> Check_Watch_Mic_Mask_State
        16   -> Time_Stamp
       8   Check_Watch_Mic_Mask_State
      24   FLASHD_Write_Safe
        24   -> BSP_Ser_Printf
        24   -> FLASHD_Write
        24   -> Time_Stamp
      16   Get_Audio_Version
        16   -> BSP_Ser_Printf
        16   -> Time_Stamp
        16   -> UART2_Mixer
        16   -> USART_Read_Timeout
        16   -> USART_SendBuf
      32   Get_Ruler_Type
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> Time_Stamp
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      32   Get_Ruler_Version
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> Time_Stamp
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
       0   Init_Global_Var
      24   Init_Ruler
        24   -> BSP_Ser_Printf
        24   -> Check_UART_Mixer_Ready
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> Time_Stamp
        24   -> UART1_Mixer
        24   -> pcSendDateToBuf
       8   Read_Flash_State
         8   -> __aeabi_memcpy4
      32   Read_Mic_Cali_Data
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> Time_Stamp
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      24   Read_Ruler_Info
        24   -> BSP_Ser_Printf
        24   -> Check_UART_Mixer_Ready
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> Time_Stamp
        24   -> UART1_Mixer
        24   -> pcSendDateToBuf
      32   Read_Ruler_Status
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> Time_Stamp
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      16   Reset_Audio
        16   -> BSP_Ser_Printf
        16   -> Time_Stamp
        16   -> UART2_Mixer
        16   -> USART_Read_Timeout
        16   -> USART_SendBuf
      24   Reset_Mic_Mask
        24   -> Init_FPGA
        24   -> Update_Mic_Mask
      32   Ruler_Active_Control
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> Time_Stamp
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      16   Ruler_POST
        16   -> BSP_Ser_Printf
        16   -> Read_Ruler_Status
        16   -> Time_Stamp
      24   Ruler_Port_LED_Service
        24   -> Buzzer_OnOff
        24   -> LED_Clear
        24   -> LED_Set
        24   -> LED_Toggle
      32   Ruler_Setup_Sync
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> Time_Stamp
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      72   Save_Ruler_FW
        72   -> BSP_Ser_Printf
        72   -> Buzzer_OnOff
        72   -> FLASHD_Write_Safe
        72   -> LED_Toggle
        72   -> Read_Flash_State
        72   -> Time_Stamp
        72   -> Write_Flash_State
        72   -> strcpy
      16   Set_Volume
        16   -> BSP_Ser_Printf
        16   -> CODEC_Set_Volume
        16   -> DMIC_PGA_Control
        16   -> Time_Stamp
        16   -> __aeabi_uidiv
        16   -> __aeabi_uidivmod
      32   Setup_Audio
        32   -> BSP_Ser_Printf
        32   -> Check_Actived_Mic_Number
        32   -> Check_SR_Support
        32   -> Check_Watch_Attach_State
        32   -> DMIC_Ploarity_Control
        32   -> Init_CODEC
        32   -> Init_FM36_AB03
        32   -> Time_Stamp
        32   -> UART2_Mixer
        32   -> USART_Read_Timeout
        32   -> USART_SendBuf
      32   Setup_Ruler
        32   -> BSP_Ser_Printf
        32   -> Check_UART_Mixer_Ready
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> Time_Stamp
        32   -> UART1_Mixer
        32   -> pcSendDateToBuf
      32   Start_Audio
        32   -> BSP_Ser_Printf
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> Time_Stamp
        32   -> UART2_Mixer
        32   -> USART_Read_Timeout
        32   -> USART_SendBuf
      24   Stop_Audio
        24   -> BSP_Ser_Printf
        24   -> Init_CODEC
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> Time_Stamp
        24   -> UART2_Mixer
        24   -> USART_Read_Timeout
        24   -> USART_SendBuf
      32   Toggle_Mic
        32   -> BSP_Ser_Printf
        32   -> Init_FPGA
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> Time_Stamp
        32   -> Update_Mic_Mask
        32   -> Watch_Mic_Revert
      40   Update_Mic_Mask
        40   -> BSP_Ser_Printf
        40   -> Check_UART_Mixer_Ready
        40   -> OSSemPend
        40   -> OSSemPost
        40   -> Time_Stamp
        40   -> UART1_Mixer
        40   -> pcSendDateToBuf
      40   Update_Ruler_FW
        40   -> BSP_Ser_Printf
        40   -> Check_UART_Mixer_Ready
        40   -> OSSemPend
        40   -> OSSemPost
        40   -> OSTimeDly
        40   -> Port_Detect_Enable
        40   -> Ruler_Power_Switch
        40   -> Time_Stamp
        40   -> UART1_Mixer
        40   -> UART_Init
        40   -> USART_Read_Timeout
        40   -> USART_SendBuf
        40   -> Xmodem_Transmit
        40   -> memset
       4   Watch_Mic_Revert
      16   Write_Flash_State
        16   -> BSP_Ser_Printf
        16   -> FLASHD_Write_Safe
        16   -> Time_Stamp
      56   Write_Mic_Cali_Data
        56   -> BSP_Ser_Printf
        56   -> Check_UART_Mixer_Ready
        56   -> OSSemPend
        56   -> OSSemPost
        56   -> OSTimeDly
        56   -> Time_Stamp
        56   -> UART1_Mixer
        56   -> pcSendDateToBuf
      48   Write_Ruler_Info
        48   -> BSP_Ser_Printf
        48   -> Check_UART_Mixer_Ready
        48   -> OSSemPend
        48   -> OSSemPost
        48   -> OSTimeDly
        48   -> Time_Stamp
        48   -> UART1_Mixer
        48   -> pcSendDateToBuf
      24   simple_test_use
        24   -> BSP_Ser_Printf
        24   -> Init_FPGA
        24   -> Setup_Audio
        24   -> Time_Stamp
        24   -> Update_Mic_Mask


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant " %s [0x%X]">
      16  ?<Constant "---Error : %d\r\n">
      32  ?<Constant "---Error Ruler[%d]: %...">
       8  ?<Constant "---OK\r\n">
      64  ?<Constant "---WARNING Ruler[%d]:...">
      16  ?<Constant "1. CODEC... ">
      16  ?<Constant "2. FM36 DSP... ">
      20  ?<Constant "3. AUDIO MCU... ">
       4  ?<Constant "> ">
       2  ?<Constant ">">
      40  ?<Constant "Bin file[%d Btyes] sa...">
      48  ?<Constant "Check_UART_Mixer_Read...">
      48  ?<Constant "Check_UART_Mixer_Read...">_1
      32  ?<Constant "DMIC_Ploarity_Control...">
      32  ?<Constant "ERROR:  Save ruler FW...">
      44  ?<Constant "ERROR: Check_Actived_...">
      28  ?<Constant "ERROR: FW bin file mi...">
      44  ?<Constant "ERROR: Toggled W01 Mi...">
      32  ?<Constant "ERROR: Write MCU flas...">
      36  ?<Constant "ERROR: Write flash st...">
      32  ?<Constant "ERROR: flash state no...">
      48  ?<Constant "ERROR: this operation...">
      76  ?<Constant "ERROR:(Setup_Audio Pl...">
      12  ?<Constant "FAIL [0x%X]">
       8  ?<Constant "FAIL">
      52  ?<Constant "Failed to init ruler ...">
      36  ?<Constant "Get Ruler_Setup_Sync_...">
      36  ?<Constant "Get_Audio_Version ERR...">
      28  ?<Constant "Get_Ruler_Type[%d] er...">
      32  ?<Constant "Get_Ruler_Version[%d]...">
      32  ?<Constant "Get_Ruler_Version[%d]...">_1
      24  ?<Constant "Init ruler[%d] timeout!">
      24  ?<Constant "Init_Ruler[%d] err = %d">
      16  ?<Constant "LIN Disabled">
      12  ?<Constant "LIN Enabled">
      28  ?<Constant "LOUT_Gain = -%2d.%1d ...">
      28  ?<Constant "Lin 2 channels added....">
      24  ?<Constant "Mic_Gain = %2d dB :  ">
      16  ?<Constant "Mute LOUT :  ">
      16  ?<Constant "Mute MIC :  ">
      16  ?<Constant "Mute SPK :  ">
      40  ?<Constant "No need revert DMIC p...">
       4  ?<Constant "OK">
      28  ?<Constant "Power Down CODEC ERRO...">
      32  ?<Constant "Read_Mic_Cali_Data[%d...">
      32  ?<Constant "Read_Mic_Cali_Data[%d...">_1
      32  ?<Constant "Read_Ruler_Info[%d] e...">
      28  ?<Constant "Read_Ruler_Info[%d] t...">
      32  ?<Constant "Read_Ruler_Status[%d]...">
      32  ?<Constant "Read_Ruler_Status[%d]...">_1
      28  ?<Constant "Read_Ruler_Type[%d] t...">
      28  ?<Constant "Reset_Audio ERROR: %d\r\n ">
      28  ?<Constant "Reset_Audio ERROR: ti...">
      12  ?<Constant "Reset_Audio">
      32  ?<Constant "Revert DMIC polarity ...">
      28  ?<Constant "Ruler[%d] FW Version: %s">
      32  ?<Constant "Ruler[%d] POST status...">
      40  ?<Constant "Ruler[%d] pcSendDateT...">
      32  ?<Constant "Ruler[%d]_Active_Cont...">
      36  ?<Constant "Ruler[%d]_Active_Cont...">_1
      36  ?<Constant "Ruler[%d]_Active_Cont...">_2
      32  ?<Constant "Ruler_Setup_Sync[%d] ...">
      32  ?<Constant "Ruler_Setup_Sync[%d] ...">_1
      28  ?<Constant "SPK_Gain = -%2d.%1d d...">
      16  ?<Constant "Set Volume :: ">
      28  ?<Constant "Setup_Audio ERROR: %d\r\n ">
      44  ?<Constant "Setup_Audio ERROR: Sa...">
      28  ?<Constant "Setup_Audio ERROR: ti...">
      36  ?<Constant "Setup_Audio Init_CODE...">
      36  ?<Constant "Setup_Audio ReInit_FM...">
      36  ?<Constant "Setup_Audio [PLAY]:[%...">
      40  ?<Constant "Setup_Audio [REC]:[%d...">
      28  ?<Constant "Setup_Ruler[%d] err = %d">
      24  ?<Constant "Setup_Ruler[%d] timeout">
      28  ?<Constant "Start Audio Bridge PO...">
      48  ?<Constant "Start loading ruler b...">
      56  ?<Constant "Start updating ruler[...">
      44  ?<Constant "Start_Audio : type = ...">
      32  ?<Constant "Start_Audio ERROR: Da...">
      32  ?<Constant "Start_Audio ERROR: Ti...">
      24  ?<Constant "Stop_Audio ERROR: %d\r\n ">
      28  ?<Constant "Stop_Audio ERROR: tim...">
      40  ?<Constant "Stop_Audio Power Down...">
      12  ?<Constant "Stop_Audio">
      36  ?<Constant "Toggle Ruler[%d]-Mic[...">
      28  ?<Constant "USB Audio FW Version:...">
      40  ?<Constant "Update ruler[%d] firm...">
      40  ?<Constant "Update_Mic_Mask for R...">
      48  ?<Constant "WARN:(Setup_Audio Pla...">
      72  ?<Constant "WARN:(Setup_Audio Rec...">
      56  ?<Constant "WARN:(Setup_Audio Rec...">_1
      36  ?<Constant "Write_Mic_Cali_Data[%...">
      36  ?<Constant "Write_Mic_Cali_Data[%...">_1
      32  ?<Constant "Write_Ruler_Info[%d] ...">
      32  ?<Constant "Write_Ruler_Info[%d] ...">_1
      44  ?<Constant "\r\nHi,man. Simple play...">
       8  ?<Constant {10, 0, 0, 0, 0}>
       1  ?<Constant {12}>
       2  ?<Constant {13, 0}>
       1  ?<Constant {14}>
       4  ?<Constant {15, 0, 0}>
       8  ?<Constant {235, 144, 1, 0, 0, 0, 0}>
       4  ?<Constant {235, 144, 11}>
       4  ?<Constant {235, 144, 16}>
       8  ?<Constant {235, 144, 2, 0, 0}>
       4  ?<Constant {235, 144, 3}>
       8  ?<Constant {32000, 0, 6}>
       8  ?<Constant {32000, 1, 6}>
       2  ?<Constant {4, 0}>
       1  ?<Constant {5}>
       1  ?<Constant {6}>
       2  ?<Constant {8, 0}>
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_2
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_10
       4  ??DataTable31_11
       4  ??DataTable31_12
       4  ??DataTable31_13
       4  ??DataTable31_14
       4  ??DataTable31_15
       4  ??DataTable31_16
       4  ??DataTable31_17
       4  ??DataTable31_18
       4  ??DataTable31_19
       4  ??DataTable31_2
       4  ??DataTable31_20
       4  ??DataTable31_21
       4  ??DataTable31_22
       4  ??DataTable31_23
       4  ??DataTable31_24
       4  ??DataTable31_25
       4  ??DataTable31_26
       4  ??DataTable31_27
       4  ??DataTable31_28
       4  ??DataTable31_29
       4  ??DataTable31_3
       4  ??DataTable31_30
       4  ??DataTable31_31
       4  ??DataTable31_32
       4  ??DataTable31_33
       4  ??DataTable31_34
       4  ??DataTable31_35
       4  ??DataTable31_36
       4  ??DataTable31_37
       4  ??DataTable31_38
       4  ??DataTable31_39
       4  ??DataTable31_4
       4  ??DataTable31_40
       4  ??DataTable31_41
       4  ??DataTable31_42
       4  ??DataTable31_43
       4  ??DataTable31_44
       4  ??DataTable31_45
       4  ??DataTable31_46
       4  ??DataTable31_5
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       4  ??DataTable31_9
     360  AB_POST
      12  Audio_Version
     112  Check_Actived_Mic_Number
     164  Check_UART_Mixer_Ready
     204  Check_Watch_Attach_State
     176  Check_Watch_Mic_Mask_State
      80  FLASHD_Write_Safe
     140  Get_Audio_Version
     380  Get_Ruler_Type
     396  Get_Ruler_Version
       1  Global_Bridge_POST
      16  Global_Mic_Mask
       4  Global_Mic_State
       1  Global_Ruler_Index
       4  Global_Ruler_State
       4  Global_Ruler_Type
     120  Init_Global_Var
     332  Init_Ruler
      32  Read_Flash_State
     360  Read_Mic_Cali_Data
     348  Read_Ruler_Info
     376  Read_Ruler_Status
     180  Reset_Audio
     304  Reset_Mic_Mask
     460  Ruler_Active_Control
       1  Ruler_CMD_Result
     220  Ruler_POST
     320  Ruler_Port_LED_Service
     368  Ruler_Setup_Sync
       1  Ruler_Setup_Sync_Data
     508  Save_Ruler_FW
     348  Set_Volume
     908  Setup_Audio
     396  Setup_Ruler
     328  Start_Audio
     324  Stop_Audio
     524  Toggle_Mic
     388  Update_Mic_Mask
     580  Update_Ruler_FW
     188  Watch_Mic_Revert
      84  Write_Flash_State
     588  Write_Mic_Cali_Data
     572  Write_Ruler_Info
       4  counter
       4  counter_buz
       4  flash_addr
     112  simple_test_use

 
     52 bytes in section .bss
      4 bytes in section .data
  3 080 bytes in section .rodata
 11 888 bytes in section .text
 
 11 888 bytes of CODE  memory
  3 080 bytes of CONST memory
     56 bytes of DATA  memory

Errors: none
Warnings: none
