###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        21/Jun/2016  16:45:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\timer.c
#    Command line =  
#        "F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\timer.c" -lcN
#        "F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "F:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "F:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "F:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\timer.lst
#    Object file  =  
#        F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\timer.o
#
###############################################################################

F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\timer.c
      1          #include  <board.h>
      2          #include  <bsp.h>
      3          #include  <at91sam7a3.h>
      4          #include  "timer.h"
      5          #include  <pio.h>
      6          
      7          
      8          
      9          #define TIMER_C
     10          
     11          
     12          
     13          static AT91PS_TC  pTCREG[] =
     14          {
     15               AT91C_BASE_TC0,    
     16               AT91C_BASE_TC1,  
     17               AT91C_BASE_TC2    
     18          
     19          };
     20          
     21          static CPU_INT08U ppcer_offset[]=
     22          {  
     23               AT91C_ID_TC0,
     24               AT91C_ID_TC1,
     25               AT91C_ID_TC2
     26          };
     27          
     28          
     29          
     30          
     31          #if 0
     32          
     33          static __ramfunc void TIMER0_ISR( void )        
     34          {
     35            
     36              CPU_INT32U status = pTCREG[0]->TC_SR;	
     37              
     38              if((status & AT91C_TC_CPCS) ) {        
     39                  pTCREG[0]->TC_CCR = AT91C_TC_CLKEN +  AT91C_TC_SWTRG ; //restart timer  
     40                  //CtrFlage.pcCmdTimeOver = 1; //set global flag
     41              }    
     42          }
     43          
     44          
     45          static __ramfunc void TIMER1_ISR( void )        
     46          {
     47            
     48              CPU_INT32U status = pTCREG[1]->TC_SR;
     49          	
     50              if((status & AT91C_TC_CPCS) ) {
     51                 //pTCREG[0]->TC_CCR = AT91C_TC_CLKDIS;   //stop timer
     52                 pTCREG[1]->TC_CCR = AT91C_TC_SWTRG | AT91C_TC_CLKEN;  //restart timer  
     53                 
     54              }       
     55          }
     56          
     57          
     58          static __ramfunc void TIMER2_ISR( void )  
     59          {
     60              CPU_INT32U status = pTCREG[2]->TC_SR;  
     61              
     62              if((status & AT91C_TC_CPCS) )  {      
     63                  pTCREG[2]->TC_CCR = AT91C_TC_CLKDIS; //stop timer
     64                  //CtrFlage.Time2Over = 1;  //set global flag
     65                  
     66              }
     67          }
     68          
     69          static void (*pTimer_ISR[])(void)=
     70          {
     71              TIMER0_ISR,
     72              TIMER1_ISR,
     73              TIMER2_ISR
     74            
     75          };
     76          
     77          
     78          #endif
     79          
     80          
     81          
     82          void AT91_TC_Init( CPU_INT08U timer_index, CPU_INT08U timer_div, void (*handler)( void ), CPU_INT32U delay_us )
     83          {
     84              CPU_INT16U DIV[5] = {         2,//1 us ~ 2730 us
     85                                            8,
     86                                            32,
     87                                            128,
     88                                            1024  // 22us - 1.4s maxium
     89                                  };   
     90              CPU_INT32U counter_top =   MCK / (1000*1000) * delay_us / ( DIV[timer_div] )  ; 
     91              
     92              if( counter_top & 0xFFFF0000 ) {
     93                  counter_top = 0xFFFF; // if exceeds TC_RC ...
     94                 
     95              }
     96              AT91C_BASE_PMC->PMC_PCER = (1 << ppcer_offset[timer_index]);
     97              pTCREG[timer_index]->TC_CCR = AT91C_TC_CLKDIS;
     98              pTCREG[timer_index]->TC_IDR = 0xFFFFFFFF;
     99              pTCREG[timer_index]->TC_CMR = timer_div
    100                                          | AT91C_TC_CPCSTOP
    101                                          | AT91C_TC_CPCDIS
    102                                          | AT91C_TC_WAVESEL_UP_AUTO
    103                                          | AT91C_TC_WAVE;
    104              
    105              pTCREG[timer_index]->TC_RC  = (CPU_INT16U) counter_top ;
    106              
    107              if( handler != NULL ) {
    108                  pTCREG[timer_index]->TC_IER = AT91C_TC_CPCS | AT91C_TC_COVFS;    
    109                  
    110                  BSP_IntVectSet( ppcer_offset[timer_index],
    111                                  (CPU_INT08U   )AT91C_AIC_PRIOR_HIGHEST,
    112                                  (CPU_INT08U   )BSP_INT_SCR_TYPE_INT_HIGH_LEVEL_SENSITIVE,
    113                                  (CPU_FNCT_VOID)handler);        
    114                  BSP_IntClr(ppcer_offset[timer_index] );     
    115                  BSP_IntEn(ppcer_offset[timer_index]); 
    116                  pTCREG[timer_index]->TC_CCR = AT91C_TC_CLKEN +  AT91C_TC_SWTRG ;
    117                  
    118              }    
    119              
    120          }
    121          
    122          
    123          
    124          
    125          
    126          
    127          
    128          
    129          
    130          /******************************************************************************
    131           Function Description:  Delay us in session, 
    132                                  Inquiry method is used instead of interruption, fater!
    133           
    134           @param:   delay_us,  1. Range :   1 us  ~ 2730 us.               
    135                                2. Delay time is not guaranteed  when < 10 us
    136                                3. One PIO_Set/Clear operation time is compensated.
    137          
    138           @return:  void.
    139          
    140              Note:   1. Compile None Optimizations, exe in  __ramfunc.
    141                      2. This function must be called in a session noah cmd, or used between 
    142                          OS_ENTER_CRITICAL() to OS_EXIT_CRITICAL() 
    143          *******************************************************************************/
    144          
    145          void  __ramfunc delay_us(CPU_INT32U delay_us)  
    146          {   
    147            
    148              CPU_INT32U i ;
    149              CPU_INT32U counter_top;    
    150              
    151              if(  delay_us <=  1  ){
    152                 __asm ("NOP");
    153                 __asm ("NOP");
    154                 __asm ("NOP");
    155                 
    156              } else if( delay_us == 2 ) {       
    157                for ( i = 0 ; i< 6; i++) {
    158                  __asm ("NOP");  
    159                } 
    160                  
    161              } else {
    162                  // MCK / (1000*1000) / ( DIV[timer_div] ) * delay_us ; = 48000000/1000000/2 *delay_us = 24*  *delay_us   
    163                  counter_top =  (delay_us - 2) * 24 ;               
    164                  if( counter_top & 0xFFFF0000 ) {
    165                      counter_top = 0; // if exceeds TC_RC ...       
    166                  }   
    167                  pTCREG[2]->TC_RC  = counter_top;// if exceeds TC_RC ...
    168                  pTCREG[2]->TC_CCR = AT91C_TC_CLKEN +  AT91C_TC_SWTRG ;
    169                  while( !( pTCREG[2]->TC_SR & AT91C_TC_CPCS) ) ;  
    170                  pTCREG[2]->TC_CCR = AT91C_TC_CLKDIS; 
    171              }  
    172             
    173              
    174          }
    175          
    176          
    177          
    178          
    179          
    180          
    181          /******************************************************************************
    182           Function Description:  Delay ms in session, 
    183                                  Inquiry method is used instead of interruption, fater!
    184           
    185           @param:   delay_us,  1. Range :   1 ms  ~ 174 ms.               
    186                                2. Delay time is not guaranteed  when < 10 us ?
    187          
    188           @return:  void.
    189          
    190              Note:   1. Compile None Optimizations, exe in flash not __ramfunc.
    191                      2. This function must be called in a session noah cmd, or used between 
    192                          OS_ENTER_CRITICAL() to OS_EXIT_CRITICAL() 
    193          *******************************************************************************/
    194          
    195          void  delay_ms( CPU_INT32U delay_ms ) //
    196          {   
    197              CPU_INT32U counter_top;
    198              CPU_INT32U counter_cycle;
    199              
    200              // MCK / (1000) / ( DIV[timer_div] ) * delay_ms ; = 48000000/1000/128 *delay_ms = 375 * delay_ms    
    201              counter_cycle   = delay_ms / 174 ;
    202              counter_top     = delay_ms - counter_cycle * 174 ;
    203              
    204              if( counter_cycle > 0 ) {     
    205                  while( counter_cycle-- >0 ) { 
    206                      pTCREG[1]->TC_RC  = 174 * 375 ;
    207                      pTCREG[1]->TC_CCR = AT91C_TC_CLKEN +  AT91C_TC_SWTRG ;
    208                      while( !(pTCREG[1]->TC_SR & AT91C_TC_CPCS) ) ;  
    209                  }
    210                  
    211              }             
    212              counter_top =  (counter_top - 0) * 375 ;   
    213              pTCREG[1]->TC_RC  = counter_top;
    214              pTCREG[1]->TC_CCR = AT91C_TC_CLKEN +  AT91C_TC_SWTRG ;
    215              
    216              while( !(pTCREG[1]->TC_SR & AT91C_TC_CPCS) ) ;  // real app use
    217              //while( pTCREG[1]->TC_CV < counter_top ) ;  //debug use, 
    218              
    219              pTCREG[1]->TC_CCR = AT91C_TC_CLKDIS;     
    220           
    221              
    222          }
    223          
    224          
    225          
    226          
    227          
    228          void Timer_Init( void )
    229          {  
    230              //AT91_TC_Init(0, AT91C_TC_CLKS_TIMER_DIV5_CLOCK,pTimer_ISR[0], 1000*1000) ; // 1000ms interval for : Task_Transmit_Data
    231              
    232              AT91_TC_Init(1, AT91C_TC_CLKS_TIMER_DIV4_CLOCK, NULL, 1) ; // Init for function:  delay_ms() 
    233          
    234              AT91_TC_Init(2, AT91C_TC_CLKS_TIMER_DIV1_CLOCK, NULL, 1) ;     // Init for function:  delay_us() 
    235            
    236              
    237          }
    238              

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   AT91_TC_Init
        40   -> BSP_IntClr
        40   -> BSP_IntEn
        40   -> BSP_IntVectSet
        40   -> __aeabi_uidiv
       8   Timer_Init
         8   -> AT91_TC_Init
      16   delay_ms
        16   -> __aeabi_uidiv
       0   delay_us


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant {2, 8, 32, 128, 1024}>
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
     428  AT91_TC_Init
      52  Timer_Init
     208  delay_ms
     172  delay_us
      12  pTCREG
       4  ppcer_offset

 
  16 bytes in section .data
  12 bytes in section .rodata
 700 bytes in section .text
 172 bytes in section .textrw
 
 872 bytes of CODE  memory
  12 bytes of CONST memory
  16 bytes of DATA  memory

Errors: none
Warnings: none
