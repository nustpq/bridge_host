###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        13/Jun/2014  16:27:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\uCOS-II\Source\os_mbox.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\uCOS-II\Source\os_mbox.c" -lcN "E:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb "E:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o "E:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\FLASH\List\os_mbox.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\os_mbox.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\uCOS-II\Source\os_mbox.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                       MESSAGE MAILBOX MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_MBOX.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.89
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          #if OS_MBOX_EN > 0u
     29          /*
     30          *********************************************************************************************************
     31          *                                     ACCEPT MESSAGE FROM MAILBOX
     32          *
     33          * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
     34          *              OSMboxAccept() does not suspend the calling task if a message is not available.
     35          *
     36          * Arguments  : pevent        is a pointer to the event control block
     37          *
     38          * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
     39          *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
     40          *              == (void *)0  if the mailbox is empty or,
     41          *                            if 'pevent' is a NULL pointer or,
     42          *                            if you didn't pass the proper event pointer.
     43          *********************************************************************************************************
     44          */
     45          
     46          #if OS_MBOX_ACCEPT_EN > 0u
     47          void  *OSMboxAccept (OS_EVENT *pevent)
     48          {
     49              void      *pmsg;
     50          #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
     51              OS_CPU_SR  cpu_sr = 0u;
     52          #endif
     53          
     54          
     55          
     56          #if OS_ARG_CHK_EN > 0u
     57              if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
     58                  return ((void *)0);
     59              }
     60          #endif
     61              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
     62                  return ((void *)0);
     63              }
     64              OS_ENTER_CRITICAL();
     65              pmsg               = pevent->OSEventPtr;
     66              pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
     67              OS_EXIT_CRITICAL();
     68              return (pmsg);                                        /* Return the message received (or NULL)     */
     69          }
     70          #endif
     71          /*$PAGE*/
     72          /*
     73          *********************************************************************************************************
     74          *                                        CREATE A MESSAGE MAILBOX
     75          *
     76          * Description: This function creates a message mailbox if free event control blocks are available.
     77          *
     78          * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
     79          *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
     80          *                            will be considered empty.
     81          *
     82          * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
     83          *                                created mailbox
     84          *              == (OS_EVENT *)0  if no event control blocks were available
     85          *********************************************************************************************************
     86          */
     87          
     88          OS_EVENT  *OSMboxCreate (void *pmsg)
     89          {
     90              OS_EVENT  *pevent;
     91          #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
     92              OS_CPU_SR  cpu_sr = 0u;
     93          #endif
     94          
     95          
     96          
     97              if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
     98                  return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
     99              }
    100              OS_ENTER_CRITICAL();
    101              pevent = OSEventFreeList;                    /* Get next free event control block                  */
    102              if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
    103                  OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    104              }
    105              OS_EXIT_CRITICAL();
    106              if (pevent != (OS_EVENT *)0) {
    107                  pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
    108                  pevent->OSEventCnt     = 0u;
    109                  pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
    110          #if OS_EVENT_NAME_EN > 0u
    111                  pevent->OSEventName    = (INT8U *)"?";
    112          #endif
    113                  OS_EventWaitListInit(pevent);
    114              }
    115              return (pevent);                             /* Return pointer to event control block              */
    116          }
    117          /*$PAGE*/
    118          /*
    119          *********************************************************************************************************
    120          *                                         DELETE A MAIBOX
    121          *
    122          * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
    123          *
    124          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    125          *                            mailbox.
    126          *
    127          *              opt           determines delete options as follows:
    128          *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
    129          *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
    130          *                                                    In this case, all the tasks pending will be readied.
    131          *
    132          *              perr          is a pointer to an error code that can contain one of the following values:
    133          *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
    134          *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
    135          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    136          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
    137          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
    138          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    139          *
    140          * Returns    : pevent        upon error
    141          *              (OS_EVENT *)0 if the mailbox was successfully deleted.
    142          *
    143          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    144          *                 the mailbox MUST check the return code of OSMboxPend().
    145          *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
    146          *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
    147          *                 time is directly proportional to the number of tasks waiting on the mailbox.
    148          *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
    149          *                 applications where the mailbox is used for mutual exclusion because the resource(s)
    150          *                 will no longer be guarded by the mailbox.
    151          *********************************************************************************************************
    152          */
    153          
    154          #if OS_MBOX_DEL_EN > 0u
    155          OS_EVENT  *OSMboxDel (OS_EVENT  *pevent, 
    156                                INT8U      opt, 
    157                                INT8U     *perr)
    158          {
    159              BOOLEAN    tasks_waiting;
    160              OS_EVENT  *pevent_return;
    161          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    162              OS_CPU_SR  cpu_sr = 0u;
    163          #endif
    164          
    165          
    166          
    167          #if OS_ARG_CHK_EN > 0u
    168              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    169                  return (pevent);
    170              }
    171              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    172                  *perr = OS_ERR_PEVENT_NULL;
    173                  return (pevent);
    174              }
    175          #endif
    176              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
    177                  *perr = OS_ERR_EVENT_TYPE;
    178                  return (pevent);
    179              }
    180              if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
    181                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
    182                  return (pevent);
    183              }
    184              OS_ENTER_CRITICAL();
    185              if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
    186                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
    187              } else {
    188                  tasks_waiting = OS_FALSE;                          /* No                                       */
    189              }
    190              switch (opt) {
    191                  case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
    192                       if (tasks_waiting == OS_FALSE) {
    193          #if OS_EVENT_NAME_EN > 0u
    194                           pevent->OSEventName = (INT8U *)"?";
    195          #endif
    196                           pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
    197                           pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
    198                           pevent->OSEventCnt  = 0u;
    199                           OSEventFreeList     = pevent;             /* Get next free event control block        */
    200                           OS_EXIT_CRITICAL();
    201                           *perr               = OS_ERR_NONE;
    202                           pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
    203                       } else {
    204                           OS_EXIT_CRITICAL();
    205                           *perr               = OS_ERR_TASK_WAITING;
    206                           pevent_return       = pevent;
    207                       }
    208                       break;
    209          
    210                  case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
    211                       while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
    212                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
    213                       }
    214          #if OS_EVENT_NAME_EN > 0u
    215                       pevent->OSEventName    = (INT8U *)"?";
    216          #endif
    217                       pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
    218                       pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
    219                       pevent->OSEventCnt     = 0u;
    220                       OSEventFreeList        = pevent;              /* Get next free event control block        */
    221                       OS_EXIT_CRITICAL();
    222                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
    223                           OS_Sched();                               /* Find highest priority task ready to run  */
    224                       }
    225                       *perr         = OS_ERR_NONE;
    226                       pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
    227                       break;
    228          
    229                  default:
    230                       OS_EXIT_CRITICAL();
    231                       *perr         = OS_ERR_INVALID_OPT;
    232                       pevent_return = pevent;
    233                       break;
    234              }
    235              return (pevent_return);
    236          }
    237          #endif
    238          
    239          /*$PAGE*/
    240          /*
    241          *********************************************************************************************************
    242          *                                      PEND ON MAILBOX FOR A MESSAGE
    243          *
    244          * Description: This function waits for a message to be sent to a mailbox
    245          *
    246          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    247          *
    248          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    249          *                            wait for a message to arrive at the mailbox up to the amount of time
    250          *                            specified by this argument.  If you specify 0, however, your task will wait
    251          *                            forever at the specified mailbox or, until a message arrives.
    252          *
    253          *              perr          is a pointer to where an error message will be deposited.  Possible error
    254          *                            messages are:
    255          *
    256          *                            OS_ERR_NONE         The call was successful and your task received a
    257          *                                                message.
    258          *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
    259          *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
    260          *                            OS_ERR_EVENT_TYPE   Invalid event type
    261          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    262          *                                                would lead to a suspension.
    263          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
    264          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
    265          *
    266          * Returns    : != (void *)0  is a pointer to the message received
    267          *              == (void *)0  if no message was received or,
    268          *                            if 'pevent' is a NULL pointer or,
    269          *                            if you didn't pass the proper pointer to the event control block.
    270          *********************************************************************************************************
    271          */
    272          /*$PAGE*/
    273          void  *OSMboxPend (OS_EVENT  *pevent, 
    274                             INT32U     timeout, 
    275                             INT8U     *perr)
    276          {
    277              void      *pmsg;
    278          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    279              OS_CPU_SR  cpu_sr = 0u;
    280          #endif
    281          
    282          
    283          
    284          #if OS_ARG_CHK_EN > 0u
    285              if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
    286                  return ((void *)0);
    287              }
    288              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    289                  *perr = OS_ERR_PEVENT_NULL;
    290                  return ((void *)0);
    291              }
    292          #endif
    293              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    294                  *perr = OS_ERR_EVENT_TYPE;
    295                  return ((void *)0);
    296              }
    297              if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
    298                  *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
    299                  return ((void *)0);
    300              }
    301              if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
    302                  *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
    303                  return ((void *)0);
    304              }
    305              OS_ENTER_CRITICAL();
    306              pmsg = pevent->OSEventPtr;
    307              if (pmsg != (void *)0) {                          /* See if there is already a message             */
    308                  pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
    309                  OS_EXIT_CRITICAL();
    310                  *perr = OS_ERR_NONE;
    311                  return (pmsg);                                /* Return the message received (or NULL)         */
    312              }
    313              OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
    314              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    315              OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
    316              OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    317              OS_EXIT_CRITICAL();
    318              OS_Sched();                                       /* Find next highest priority task ready to run  */
    319              OS_ENTER_CRITICAL();
    320              switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
    321                  case OS_STAT_PEND_OK:
    322                       pmsg =  OSTCBCur->OSTCBMsg;
    323                      *perr =  OS_ERR_NONE;
    324                       break;
    325          
    326                  case OS_STAT_PEND_ABORT:
    327                       pmsg = (void *)0;
    328                      *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
    329                       break;
    330          
    331                  case OS_STAT_PEND_TO:
    332                  default:
    333                       OS_EventTaskRemove(OSTCBCur, pevent);
    334                       pmsg = (void *)0;
    335                      *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
    336                       break;
    337              }
    338              OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
    339              OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
    340              OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
    341          #if (OS_EVENT_MULTI_EN > 0u)
    342              OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
    343          #endif
    344              OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
    345              OS_EXIT_CRITICAL();
    346              return (pmsg);                                    /* Return received message                       */
    347          }
    348          /*$PAGE*/
    349          /*
    350          *********************************************************************************************************
    351          *                                      ABORT WAITING ON A MESSAGE MAILBOX
    352          *
    353          * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function 
    354          *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
    355          *              the mailbox via OSMboxPost() or OSMboxPostOpt().
    356          *
    357          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
    358          *
    359          *              opt           determines the type of ABORT performed:
    360          *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
    361          *                                                     mailbox
    362          *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
    363          *                                                     mailbox
    364          *
    365          *              perr          is a pointer to where an error message will be deposited.  Possible error
    366          *                            messages are:
    367          *
    368          *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
    369          *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
    370          *                                                and informed of the aborted wait; check return value 
    371          *                                                for the number of tasks whose wait on the mailbox 
    372          *                                                was aborted.
    373          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
    374          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    375          *
    376          * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
    377          *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
    378          *********************************************************************************************************
    379          */
    380          
    381          #if OS_MBOX_PEND_ABORT_EN > 0u
    382          INT8U  OSMboxPendAbort (OS_EVENT  *pevent, 
    383                                  INT8U      opt, 
    384                                  INT8U     *perr)
    385          {
    386              INT8U      nbr_tasks;
    387          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    388              OS_CPU_SR  cpu_sr = 0u;
    389          #endif
    390          
    391          
    392          
    393          #if OS_ARG_CHK_EN > 0u
    394              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    395                  return (0u);
    396              }
    397              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    398                  *perr = OS_ERR_PEVENT_NULL;
    399                  return (0u);
    400              }
    401          #endif
    402              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
    403                  *perr = OS_ERR_EVENT_TYPE;
    404                  return (0u);
    405              }
    406              OS_ENTER_CRITICAL();
    407              if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
    408                  nbr_tasks = 0u;
    409                  switch (opt) {
    410                      case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
    411                           while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
    412                               (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
    413                               nbr_tasks++;
    414                           }
    415                           break;
    416                       
    417                      case OS_PEND_OPT_NONE:
    418                      default:                                       /* No,  ready HPT       waiting on mailbox  */
    419                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
    420                           nbr_tasks++;
    421                           break;
    422                  }
    423                  OS_EXIT_CRITICAL();
    424                  OS_Sched();                                        /* Find HPT ready to run                    */
    425                  *perr = OS_ERR_PEND_ABORT;
    426                  return (nbr_tasks);
    427              }
    428              OS_EXIT_CRITICAL();
    429              *perr = OS_ERR_NONE;
    430              return (0u);                                           /* No tasks waiting on mailbox              */
    431          }
    432          #endif
    433          
    434          /*$PAGE*/
    435          /*
    436          *********************************************************************************************************
    437          *                                       POST MESSAGE TO A MAILBOX
    438          *
    439          * Description: This function sends a message to a mailbox
    440          *
    441          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    442          *
    443          *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
    444          *
    445          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    446          *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
    447          *                                   message at a time and thus, the message MUST be consumed before you
    448          *                                   are allowed to send another one.
    449          *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
    450          *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
    451          *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
    452          *
    453          * Note(s)    : 1) HPT means Highest Priority Task
    454          *********************************************************************************************************
    455          */
    456          
    457          #if OS_MBOX_POST_EN > 0u
    458          INT8U  OSMboxPost (OS_EVENT  *pevent, 
    459                             void      *pmsg)
    460          {
    461          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    462              OS_CPU_SR  cpu_sr = 0u;
    463          #endif
    464          
    465          
    466          
    467          #if OS_ARG_CHK_EN > 0u
    468              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    469                  return (OS_ERR_PEVENT_NULL);
    470              }
    471              if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
    472                  return (OS_ERR_POST_NULL_PTR);
    473              }
    474          #endif
    475              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    476                  return (OS_ERR_EVENT_TYPE);
    477              }
    478              OS_ENTER_CRITICAL();
    479              if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
    480                                                                /* Ready HPT waiting on event                    */
    481                  (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
    482                  OS_EXIT_CRITICAL();
    483                  OS_Sched();                                   /* Find highest priority task ready to run       */
    484                  return (OS_ERR_NONE);
    485              }
    486              if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
    487                  OS_EXIT_CRITICAL();
    488                  return (OS_ERR_MBOX_FULL);
    489              }
    490              pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
    491              OS_EXIT_CRITICAL();
    492              return (OS_ERR_NONE);
    493          }
    494          #endif
    495          
    496          /*$PAGE*/
    497          /*
    498          *********************************************************************************************************
    499          *                                       POST MESSAGE TO A MAILBOX
    500          *
    501          * Description: This function sends a message to a mailbox
    502          *
    503          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    504          *
    505          *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
    506          *
    507          *              opt           determines the type of POST performed:
    508          *                            OS_POST_OPT_NONE         POST to a single waiting task
    509          *                                                     (Identical to OSMboxPost())
    510          *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
    511          *
    512          *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
    513          *
    514          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    515          *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
    516          *                                   message at a time and thus, the message MUST be consumed before you
    517          *                                   are allowed to send another one.
    518          *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
    519          *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
    520          *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
    521          *
    522          * Note(s)    : 1) HPT means Highest Priority Task
    523          *
    524          * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
    525          *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
    526          *********************************************************************************************************
    527          */
    528          
    529          #if OS_MBOX_POST_OPT_EN > 0u
    530          INT8U  OSMboxPostOpt (OS_EVENT  *pevent, 
    531                                void      *pmsg, 
    532                                INT8U      opt)
    533          {
    534          #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
    535              OS_CPU_SR  cpu_sr = 0u;
    536          #endif
    537          
    538          
    539          
    540          #if OS_ARG_CHK_EN > 0u
    541              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    542                  return (OS_ERR_PEVENT_NULL);
    543              }
    544              if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
    545                  return (OS_ERR_POST_NULL_PTR);
    546              }
    547          #endif
    548              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    549                  return (OS_ERR_EVENT_TYPE);
    550              }
    551              OS_ENTER_CRITICAL();
    552              if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
    553                  if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
    554                      while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
    555                          (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
    556                      }
    557                  } else {                                      /* No,  Post to HPT waiting on mbox              */
    558                      (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
    559                  }
    560                  OS_EXIT_CRITICAL();
    561                  if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
    562                      OS_Sched();                               /* Find HPT ready to run                         */
    563                  }
    564                  return (OS_ERR_NONE);
    565              }
    566              if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
    567                  OS_EXIT_CRITICAL();
    568                  return (OS_ERR_MBOX_FULL);
    569              }
    570              pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
    571              OS_EXIT_CRITICAL();
    572              return (OS_ERR_NONE);
    573          }
    574          #endif
    575          
    576          /*$PAGE*/
    577          /*
    578          *********************************************************************************************************
    579          *                                        QUERY A MESSAGE MAILBOX
    580          *
    581          * Description: This function obtains information about a message mailbox.
    582          *
    583          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    584          *
    585          *              p_mbox_data   is a pointer to a structure that will contain information about the message
    586          *                            mailbox.
    587          *
    588          * Returns    : OS_ERR_NONE         The call was successful and the message was sent
    589          *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
    590          *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
    591          *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
    592          *********************************************************************************************************
    593          */
    594          
    595          #if OS_MBOX_QUERY_EN > 0u
    596          INT8U  OSMboxQuery (OS_EVENT      *pevent, 
    597                              OS_MBOX_DATA  *p_mbox_data)
    598          {
    599              INT8U      i;
    600          #if OS_LOWEST_PRIO <= 63u
    601              INT8U     *psrc;
    602              INT8U     *pdest;
    603          #else
    604              INT16U    *psrc;
    605              INT16U    *pdest;
    606          #endif
    607          #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
    608              OS_CPU_SR  cpu_sr = 0u;
    609          #endif
    610          
    611          
    612          
    613          #if OS_ARG_CHK_EN > 0u
    614              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    615                  return (OS_ERR_PEVENT_NULL);
    616              }
    617              if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
    618                  return (OS_ERR_PDATA_NULL);
    619              }
    620          #endif
    621              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
    622                  return (OS_ERR_EVENT_TYPE);
    623              }
    624              OS_ENTER_CRITICAL();
    625              p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
    626              psrc                    = &pevent->OSEventTbl[0];
    627              pdest                   = &p_mbox_data->OSEventTbl[0];
    628              for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
    629                  *pdest++ = *psrc++;
    630              }
    631              p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
    632              OS_EXIT_CRITICAL();
    633              return (OS_ERR_NONE);
    634          }
    635          #endif                                                     /* OS_MBOX_QUERY_EN                         */
    636          #endif                                                     /* OS_MBOX_EN                               */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   OSMboxAccept
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
      16   OSMboxCreate
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_EventWaitListInit
      32   OSMboxDel
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> OS_EventTaskRdy
        32   -> OS_Sched
      24   OSMboxPend
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRemove
        24   -> OS_EventTaskWait
        24   -> OS_Sched
      24   OSMboxPendAbort
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      24   OSMboxPost
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      24   OSMboxPostOpt
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_EventTaskRdy
        24   -> OS_Sched
      32   OSMboxQuery
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "?">
       4  ??DataTable1
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
      92  OSMboxAccept
     156  OSMboxCreate
     460  OSMboxDel
     504  OSMboxPend
     260  OSMboxPendAbort
     184  OSMboxPost
     236  OSMboxPostOpt
     176  OSMboxQuery

 
     2 bytes in section .rodata
 2 088 bytes in section .text
 
 2 088 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none
