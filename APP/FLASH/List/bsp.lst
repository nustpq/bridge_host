###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        21/Jun/2016  16:45:15
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\BSP\bsp.c
#    Command line =  
#        "F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\BSP\bsp.c" -lcN "F:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb "F:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o "F:\SVN
#        Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "F:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "F:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "F:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "F:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\bsp.lst
#    Object file  =  
#        F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\bsp.o
#
###############################################################################

F:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\BSP\bsp.c
      1          /*
      2          *********************************************************************************************************
      3          *                               iSAM TEST BENCH AUDIO BRIDGE BOARD APP PACKAGE
      4          *
      5          *                            (c) Copyright 2013 - 2016; Fortemedia Inc.; Nanjing, China
      6          *
      7          *                   All rights reserved.  Protected by international copyright laws.
      8          *                   Knowledge of the source code may not be used to write a similar
      9          *                   product.  This file may only be used in accordance with a license
     10          *                   and should not be redistributed in any way.
     11          *********************************************************************************************************
     12          */
     13          /*
     14          *********************************************************************************************************
     15          *
     16          *                                       BOARD SUPPORT PACKAGE
     17          *
     18          *                                          Atmel AT91SAM7A3
     19          *                                               on the
     20          *                                      iSAM Audio Bridge Board
     21          *
     22          * Filename      : bsp.c
     23          * Version       : V1.0.0
     24          * IDE           : IAR for ARM 5.40
     25          * Programmer(s) : PQ
     26          *
     27          *********************************************************************************************************
     28          * Note(s)       :
     29          *********************************************************************************************************
     30          */
     31          
     32          
     33          /*
     34          *********************************************************************************************************
     35          *                                            INCLUDE FILES
     36          *********************************************************************************************************
     37          */
     38          
     39          #define   BSP_MODULE
     40          
     41          #include  <includes.h>
     42          
     43          
     44          /*
     45          *********************************      Version Declaration       ****************************************
     46          */
     47          const CPU_CHAR fw_version[]  = "[FW:H:V0.5]"; //fixed size string
     48          
     49          #ifdef  BOARD_TYPE_AB01
     50          const CPU_CHAR hw_version[]  = "[HW:V1.0]"; 
     51          const CPU_CHAR hw_model[]    = "[AB01]"; 
     52          #endif
     53          #ifdef BOARD_TYPE_AB02
     54          const CPU_CHAR hw_version[]  = "[HW:V1.0]"; 
     55          const CPU_CHAR hw_model[]    = "[AB02]"; 
     56          #endif
     57          #ifdef  BOARD_TYPE_AB03
     58          const CPU_CHAR hw_version[]  = "[HW:V1.0]"; 
     59          const CPU_CHAR hw_model[]    = "[AB03]"; 
     60          #endif
     61          
     62          
     63          
     64          
     65          OS_EVENT *Bsp_Ser_Tx_Sem_lock;  
     66          OS_EVENT *Bsp_Ser_Rx_Sem_lock;
     67          
     68          static  Pin PinBuzzer    =   BUZZER ;
     69          CPU_INT08U Debug_COM_Sel = 0 ; //debug uart use:    0: DBGUART, 1: UART1, >1: debug muted
     70          
     71          /*
     72          *********************************************************************************************************
     73          *                                            LOCAL DEFINES
     74          *********************************************************************************************************
     75          */
     76          
     77          #define  BSP_RAM_REMAP_TEST_BYTE             (*(CPU_INT08U  *)0x00000030L)
     78          
     79          #define  BSP_GPIOA_TWD                      DEF_BIT_00           /* TWI   (A): Serial EEPROM                                 */
     80          #define  BSP_GPIOA_TWCK                     DEF_BIT_01           /* TWI   (A): Serial EEPROM                                 */                                                                /* ---------------------- GPIOA Pins ---------------------- */
     81          #define  BSP_GPIOA_RXD0                     DEF_BIT_02           /* UART0 (A): COM PORT 0                                    */
     82          #define  BSP_GPIOA_TXD0                     DEF_BIT_03           /* UART0 (A): COM PORT 0                                    */                                 
     83          #define  BSP_GPIOA_UART0_SEL                DEF_BIT_04          /* UART0 (A): COM PORT 0                                    */
     84          #define  BSP_GPIOA_RXD1                     DEF_BIT_07          /* UART0 (A): Debug Port                                    */
     85          #define  BSP_GPIOA_TXD1                     DEF_BIT_08          /* UART0 (A): Debug Port                                    */
     86          #define  BSP_GPIOA_RXD2                     DEF_BIT_09          /* UART0 (A): Debug Port                                    */
     87          #define  BSP_GPIOA_TXD2                     DEF_BIT_10          /* UART0 (A): Debug Port     */
     88          #define  BSP_GPIOA_UART2_SEL                DEF_BIT_11          /* UART0 (A): COM PORT 0                                    */
     89          #define  BSP_GPIOA_SPI0_NPCS3               DEF_BIT_14          /* SPI0  (A): DataFlash Chip Select                         */
     90          #define  BSP_GPIOA_SPI0_MISO                DEF_BIT_15          /* SPI0  (A): SD/MMC/DataFlash Socket/DataFlash             */
     91          #define  BSP_GPIOA_SPI0_MOSI                DEF_BIT_16          /* SPI0  (A): SD/MMC/DataFlash Socket/DataFlash             */
     92          #define  BSP_GPIOA_SPI0_SPCK                DEF_BIT_17          /* SPI0  (A): SD/MMC/DataFlash Socket/DataFlash             */
     93          #define  BSP_GPIOA_DRXD                     DEF_BIT_30          /* DBGU  (A): Debug Port                                    */
     94          #define  BSP_GPIOA_DTXD                     DEF_BIT_31          /* DBGU  (A): Debug Port                                    */
     95          #define  BSP_GPIOA_BUZZER                   DEF_BIT_29
     96          
     97          ////////////////  ????
     98          #define  BSP_GPIOA_CAN_RXD                  DEF_BIT_19          /* CAN   (A): CAN                                           */
     99          #define  BSP_GPIOA_CAN_TXD                  DEF_BIT_20          /* CAN   (A): CAN                                           */
    100          #define  BSP_GPIOA_JOY_UP                   DEF_BIT_21          /* (GPIO)(A): Joystick Up                                   */
    101          #define  BSP_GPIOA_JOY_DOWN                 DEF_BIT_22          /* (GPIO)(A): Joystick Down                                 */
    102          #define  BSP_GPIOA_JOY_LEFT                 DEF_BIT_23          /* (GPIO)(A): Joystick Left                                 */
    103          #define  BSP_GPIOA_JOY_RIGHT                DEF_BIT_24          /* (GPIO)(A): Joystick Right                                */
    104          #define  BSP_GPIOA_JOY_PUSH                 DEF_BIT_25          /* (GPIO)(A): Joystick Push                                 */
    105          ////////////////
    106          
    107          #define  BSP_GPIOA_DBG                     (BSP_GPIOA_DRXD      |\
    108                                                      BSP_GPIOA_DTXD)
    109          
    110          #define  BSP_GPIOA_UART0                   (BSP_GPIOA_RXD0      |\
    111                                                      BSP_GPIOA_TXD0)
    112          
    113          #define  BSP_GPIOA_UART1                   (BSP_GPIOA_RXD1      |\
    114                                                      BSP_GPIOA_TXD1)
    115          
    116          #define  BSP_GPIOA_JOY                     (BSP_GPIOA_JOY_UP    | \
    117                                                      BSP_GPIOA_JOY_DOWN  | \
    118                                                      BSP_GPIOA_JOY_LEFT  | \
    119                                                      BSP_GPIOA_JOY_RIGHT | \
    120                                                      BSP_GPIOA_JOY_PUSH)
    121          
    122                                                                          /* ---------------------- GPIOB Pins ---------------------- */
    123          #define  BSP_GPIOA_LED1                     DEF_BIT_12          /* (GPIO)( ): LED 1                                         */
    124          #define  BSP_GPIOA_LED2                     DEF_BIT_13          /* (GPIO)( ): LED 2                                         */
    125          
    126          
    127          #define  BSP_GPIOA_LEDS                    (BSP_GPIOA_LED1      | \
    128                                                      BSP_GPIOA_LED2)
    129                                                                          /* --------------- TIMEOUT VALUES ------------------- */
    130          #define  BSP_PLL_MAX_TIMEOUT                    0xFFFF
    131          #define  BSP_MAIN_OSC_MAX_START_UP_VAL          0xFFFF
    132          #define  BSP_MAIN_OSC_MAINF_MAX_TIMEOUT_VAL     0xFFFF
    133          #define  BSP_MCLK_MAX_TIMEOUT                   0xFFFF
    134                                                                          /* ------------ PERIPHERALS CONSTRAINS  ------------- */
    135          #define  BSP_PLL_MAX_MUL                          2048          /* Maximum value for the PLL Multiplier               */
    136          #define  BSP_AIC_INT_PRIO_MAX                        7          /* Highest Interrupt level in the AIC                 */
    137          #define  BSP_PER_ID_MAX                             31          /* Number of peripherals.                             */
    138          
    139          
    140          /*
    141          *********************************************************************************************************
    142          *                                           LOCAL CONSTANTS
    143          *********************************************************************************************************
    144          */
    145          
    146          
    147          /*
    148          *********************************************************************************************************
    149          *                                          LOCAL DATA TYPES
    150          *********************************************************************************************************
    151          */
    152          
    153          
    154          /*
    155          *********************************************************************************************************
    156          *                                            LOCAL TABLES
    157          *********************************************************************************************************
    158          */
    159          
    160          
    161          /*
    162          *********************************************************************************************************
    163          *                                       LOCAL GLOBAL VARIABLES
    164          *********************************************************************************************************
    165          */
    166          
    167          
    168          /*
    169          *********************************************************************************************************
    170          *                                      LOCAL FUNCTION PROTOTYPES
    171          *********************************************************************************************************
    172          */
    173          
    174          static  void  BSP_DummyISR_Handler  (void);
    175          
    176          static  void  BSP_IntInit           (void);
    177          
    178          static  void  BSP_Tmr_TickInit      (void);
    179          
    180          static  void  BSP_ResetInit         (void);
    181          /*
    182          *********************************************************************************************************
    183          *                                     LOCAL CONFIGURATION ERRORS
    184          *********************************************************************************************************
    185          */
    186          
    187          
    188          /*
    189          *********************************************************************************************************
    190          *********************************************************************************************************
    191          **                                         GLOABL FUNCTIONS
    192          *********************************************************************************************************
    193          *********************************************************************************************************
    194          */
    195          
    196          /*
    197          *********************************************************************************************************
    198          *                                             BSP_Init()
    199          *
    200          * Description : Initialize the Board Support Package (BSP).
    201          *
    202          * Argument(s) : none.
    203          *
    204          * Return(s)   : none.
    205          *
    206          * Caller(s)   : Application
    207          *
    208          * Note(s)     : (1) This function SHOULD be called before any other BSP function is called.
    209          *********************************************************************************************************
    210          */
    211          
    212          void  BSP_Init (void)
    213          {
    214            
    215              AT91C_BASE_WDTC->WDTC_WDMR = AT91C_WDTC_WDDIS;       /* Disable the Watchdog Timer                               */
    216              
    217              BSP_IntInit();                                       /* Initialize the Interrupt Controller, must put here front */
    218           
    219              GPIO_Init();   
    220                 
    221              BSP_ResetInit();                                     /* Enable the hardware reset button  used interrupt         */
    222                   
    223              // Configure IIC    
    224              TWI_Init( TWCK ); //It seems that the TWI will auto desrease SCK if loading increase           
    225              
    226              //Configure SPI for codec10
    227              //SPI_Init( SPI_CLK ) ; 
    228              
    229              // Init Internal Flash
    230              FLASHD_Initialize( MCK );
    231              //flash_test();
    232              
    233              // Config USART
    234              UART_Init(PC_UART,     ISR_PC_UART,     115200 );    //To PC        
    235              UART_Init(RULER_UART,  ISR_Ruler_UART,  115200 );    //To Ruler 
    236              UART_Init(AUDIO_UART,  NULL,            115200 );    //To Audio  
    237                    
    238              //Config Timer
    239              Timer_Init();  
    240              
    241              //init noah CMD control varieties 
    242              //Init_Noah_Mem_Ctr();
    243              
    244              //Init ADCs
    245              //Init_ADC_Voltage() ; 
    246              //Init_ADC_Current() ;   
    247              
    248              BSP_Tmr_TickInit();                                         /* Initialize uC/OS-II's Tick Rate and DEBUG UART                          */
    249              
    250          
    251          }
    252          
    253          /*
    254          *********************************************************************************************************
    255          *                                            BSP_CPU_ClkFreq()
    256          *
    257          * Description : Get the processor clock frequency.
    258          *
    259          * Argument(s) : none.
    260          *
    261          * Return(s)   : The CPU clock frequency, in Hz.
    262          *
    263          * Caller(s)   : Application
    264          *
    265          * Note(s)     : none.
    266          *********************************************************************************************************
    267          */
    268          
    269          CPU_INT32U  BSP_CPU_ClkFreq (void)
    270          {
    271              CPU_INT32U  mclk_css;
    272              CPU_INT32U  mclk_div;
    273              CPU_INT32U  cpu_freq;
    274          
    275              
    276              mclk_css = (AT91C_BASE_PMC->PMC_MCKR     ) & 0x00000003;    /* Get the master clk source                          */
    277              mclk_div = (AT91C_BASE_PMC->PMC_MCKR >> 2) & 0x00000003;    /* Get the master clk preescaler                      */
    278              mclk_div = DEF_BIT(mclk_div);
    279              
    280              switch (mclk_css) {
    281          
    282                  case BSP_CLK_SRC_SLOW:                                 /* Slow clock                                         */
    283                       cpu_freq = BSP_SLOW_XTAL_FREQ;
    284                       break;
    285          
    286                  case BSP_CLK_SRC_MAIN:                                 /* Main clock                                         */
    287                       cpu_freq = BSP_MAIN_XTAL_FREQ;
    288                       break;
    289          
    290                  case BSP_CLK_SRC_PLL:                                  /* PLL clock                                          */
    291                       cpu_freq = BSP_PLL_GetFreq();
    292                       break;
    293          
    294                  case BSP_CLK_SRC_RESERVED:
    295                  default:
    296                       cpu_freq = 0;
    297                       break;             
    298              }
    299          
    300              cpu_freq = cpu_freq / mclk_div;
    301          
    302              return (cpu_freq);
    303          }
    304          
    305          /*
    306          *********************************************************************************************************
    307          *                                          BSP_CPU_Init()
    308          *
    309          * Description : Initializes all the CPU clk.
    310          *               (1) Enable the Main Oscillator.
    311          *               (2) Set the PLL at 192 Mhz:
    312          *                     PLL_CLK = (MAINclk * mult) / div  = 18432000 * (72 + 1) / 7
    313          *                                                       = 192219428.6 Mhz ; mult = 73, div = 7 (0.11 % err for 192 Mhz).
    314          *               (3) Set the MCLK/CPUClk/PCK frequency.
    315          *                   MCLK = PCLK / div                   = 192  / 4 = 48 Mhz.
    316          *
    317          * Argument(s) : none.
    318          *
    319          * Return(s)   : none.
    320          *
    321          * Caller(s)   : BSP_Init();
    322          *
    323          * Note(s)     : (1) From the AT91SAM7x datasheet 
    324          *                   (http://www.atmel.com/dyn/resources/prod_documents/doc6120.pdf)
    325          *                   The PLL has the following characteristics.
    326          *
    327          *                 ||------------------|---------------------------------|-------|-------|--------||
    328          *                 || Parameter        |   Condition                     |  MIN  |  MAX  |  Unit  ||
    329          *                 ||------------------|---------------------------------|-------|-------|--------||
    330          *                 || Output Frequency | If OUT field in CKGR_PLL is 00  |   80  |  160  |  Mhz   ||
    331          *                 ||------------------|---------------------------------|-------|-------|--------||
    332          *                 || Output Frequency | If OUT field in CKGR_PLL is 01  |   150 |  200  |  Mhz   ||
    333          *                 ||-----------------------------------------------------------------------------||
    334          *
    335          *********************************************************************************************************
    336          */
    337          
    338          void  BSP_CPU_Init (void)
    339          {
    340              AT91C_BASE_MC->MC_FMR      |= (1 << 8); 
    341              BSP_MainOscEn( 0xFF );                                        /* Enable Main Oscillator                            */
    342              
    343              // 18.432 * 73 / 7 =  192.2MHz   
    344              BSP_PLL_Cfg( 73,                                              /* PLL Multipler                                     */
    345                           7,                                               /* PLL Divider                                       */
    346                           1,                                               /* PLL Out parameter (see note #1)                   */ 
    347                           0xFF );                                          /* Set the PLL frequency                             */
    348          
    349              BSP_MclkCfg( BSP_CLK_SRC_PLL,
    350                           BSP_CLK_PRE4 );                                  /* MCK = 192M / 4 = 48MHz                            */
    351                           
    352          }
    353          
    354          
    355          
    356          
    357          /*
    358          *********************************************************************************************************
    359          *                                    void LowLevelInitPLL(void)  
    360          *                    In order to boost powerup speed, init PLL first in cstartup.s !!!!!
    361          *                                          by PQ
    362          *
    363          *********************************************************************************************************
    364          */
    365          // Startup time of main oscillator (in number of slow clock ticks).
    366          #define BOARD_OSCOUNT           (AT91C_CKGR_OSCOUNT & (0x40 << 8))
    367          // USB PLL divisor value to obtain a 48MHz clock.
    368          #define BOARD_USBDIV            AT91C_CKGR_USBDIV_1
    369          // PLL frequency range.
    370          #define BOARD_CKGR_PLL          AT91C_CKGR_OUT_0
    371          // PLL startup time (in number of slow clock ticks).
    372          #define BOARD_PLLCOUNT          (16 << 8)
    373          
    374          // PLL MUL value.
    375          #define BOARD_MUL               (AT91C_CKGR_MUL & (72 << 16))   //96M     = 18.432 * (72+1) / 14 = 96.1 
    376          //#define BOARD_MUL               (AT91C_CKGR_MUL & (83 << 16))  //110.592M = 18.432 * (83+1) / 14 = 110.592
    377          //#define BOARD_MUL               (AT91C_CKGR_MUL & (90 << 16))   //140M  = 18.432 * (90+1) / 12 = 139.77
    378          // PLL DIV value.
    379          #define BOARD_DIV               (AT91C_CKGR_DIV & 14)
    380          //#define BOARD_DIV               (AT91C_CKGR_DIV & 12)
    381          
    382          // Master clock prescaler value.
    383          #define BOARD_PRESCALER         AT91C_PMC_PRES_CLK_2
    384          
    385           
    386          void LowLevelInitPLL( void )
    387          {  
    388              // Set flash wait states in the EFC
    389              // 48MHz = 1 wait state
    390              AT91C_BASE_MC->MC_FMR = AT91C_MC_FWS_1FWS;
    391          
    392              // Initialize main oscillator
    393              AT91C_BASE_PMC->PMC_MOR = BOARD_OSCOUNT | AT91C_CKGR_MOSCEN;
    394              while (!(AT91C_BASE_PMC->PMC_SR & AT91C_PMC_MOSCS));
    395          
    396              // Initialize PLL at 96MHz (96.109) and USB clock to 48MHz
    397              AT91C_BASE_PMC->PMC_PLLR = BOARD_USBDIV | BOARD_CKGR_PLL | BOARD_PLLCOUNT
    398                                         | BOARD_MUL | BOARD_DIV;
    399              while (!(AT91C_BASE_PMC->PMC_SR & AT91C_PMC_LOCK));
    400                  
    401          
    402              // Wait for the master clock if it was already initialized
    403              while (!(AT91C_BASE_PMC->PMC_SR & AT91C_PMC_MCKRDY));
    404          
    405              // Switch to slow clock + prescaler
    406              AT91C_BASE_PMC->PMC_MCKR = BOARD_PRESCALER;
    407              while (!(AT91C_BASE_PMC->PMC_SR & AT91C_PMC_MCKRDY));
    408          
    409              // Switch to fast clock + prescaler
    410              AT91C_BASE_PMC->PMC_MCKR |= AT91C_PMC_CSS_PLL_CLK;
    411              while (!(AT91C_BASE_PMC->PMC_SR & AT91C_PMC_MCKRDY));    
    412          
    413          }
    414          
    415          
    416          /*
    417          *********************************************************************************************************
    418          *********************************************************************************************************
    419                                              INTERRUPT CONTROLLER FUNCTIONS
    420          *********************************************************************************************************
    421          *********************************************************************************************************
    422          */
    423          
    424          /*
    425          *********************************************************************************************************
    426          *                                          BSP_IntEn()
    427          *
    428          * Description : This function clears an interrupt
    429          *
    430          * Argument(s) : per_id        The interrupt id
    431          *                             BSP_PER_ID_AIC_FIQ
    432          *                             BSP_PER_ID_SYSC
    433          *                             BSP_PER_ID_PIOA
    434          *                             BSP_PER_ID_PIOB
    435          *                                     .
    436          *                                     .
    437          *                                     .
    438          *                             BSP_PER_ID_AIC
    439          *
    440          * Returns     : none.
    441          *
    442          * Caller(s)   : Application.
    443          *
    444          * Note(s)     : none.
    445          *********************************************************************************************************
    446          */
    447          
    448          void BSP_IntClr (CPU_INT08U  per_id)
    449          {
    450                                                                          /* -------------- ARGUMENTS CHECKING ---------------- */
    451              if (per_id > BSP_PER_ID_MAX) { 
    452                  return;
    453              }
    454          
    455              AT91C_BASE_AIC->AIC_ICCR = DEF_BIT(per_id);
    456          }
    457          
    458          /*
    459          *********************************************************************************************************
    460          *                                             BSP_IntDis()
    461          *
    462          * Description : This function disables an interrupt.
    463          *
    464          * Argument(s) : per_id        The interrupt id
    465          *                             BSP_PER_ID_AIC_FIQ
    466          *                             BSP_PER_ID_SYSC
    467          *                             BSP_PER_ID_PIOA
    468          *                             BSP_PER_ID_PIOB
    469          *                                     .
    470          *                                     .
    471          *                                     .
    472          *                             BSP_PER_ID_AIC
    473          *
    474          * Returns     : none.
    475          *
    476          * Caller(s)   : Application.
    477          *
    478          * Note(s)     : none.
    479          *********************************************************************************************************
    480          */
    481          
    482          void BSP_IntDis (CPU_INT08U  per_id)
    483          {
    484                                                                          /* -------------- ARGUMENTS CHECKING ---------------- */
    485              if (per_id > BSP_PER_ID_MAX) { 
    486                  return;
    487              }
    488          
    489              AT91C_BASE_AIC->AIC_IDCR = DEF_BIT(per_id); 
    490          }
    491          
    492          /*
    493          *********************************************************************************************************
    494          *                                             BSP_IntDisAll()
    495          *
    496          * Description : Disable ALL interrupts.
    497          *
    498          * Argument(s) : none.
    499          *
    500          * Return(s)   : none.
    501          *
    502          * Caller(s)   : Application
    503          *
    504          * Argument(s) : none.
    505          *********************************************************************************************************
    506          */
    507          
    508          void  BSP_IntDisAll (void)
    509          {
    510              AT91C_BASE_AIC->AIC_IDCR = 0xFFFFFFFF;                      /* Disable all interrupts                                 */
    511          }
    512          
    513          /*
    514          *********************************************************************************************************
    515          *                                          BSP_IntEn()
    516          *
    517          * Description : This function enables an interrupt.
    518          *
    519          * Argument(s) : per_id        The interrupt id
    520          *                             BSP_PER_ID_AIC_FIQ
    521          *                             BSP_PER_ID_SYSC
    522          *                             BSP_PER_ID_PIOA
    523          *                             BSP_PER_ID_PIOB
    524          *                                     .
    525          *                                     .
    526          *                                     .
    527          *                             BSP_PER_ID_AIC
    528          *
    529          * Returns     : none.
    530          *
    531          * Caller(s)   : Application.
    532          *
    533          * Note(s)     : none.
    534          *********************************************************************************************************
    535          */
    536          
    537          void BSP_IntEn (CPU_INT08U  per_id)
    538          {
    539                                                                          /* -------------- ARGUMENTS CHECKING ---------------- */
    540              if (per_id > BSP_PER_ID_MAX) { 
    541                  return;
    542              }
    543          
    544              AT91C_BASE_AIC->AIC_IECR = DEF_BIT(per_id);
    545          }
    546          
    547          
    548          /*
    549          *********************************************************************************************************
    550          *                                       BSP_IntInit()
    551          *
    552          * Description : (1) Initialize interrupts:
    553          *                    (a) Initialize exception vector table, performing a remap (if necessary).
    554          *                    (b) Initialize vectors in Advance Interrupt Controller (AIC) to dummy ISR.
    555          *
    556          * Argument(s) : none.
    557          *
    558          * Return(s)   : none.
    559          *
    560          * Caller(s)   : BSP_Init()
    561          *
    562          * Note(s)     : none.
    563          *********************************************************************************************************
    564          */
    565          
    566          static  void  BSP_IntInit (void)
    567          {
    568              CPU_INT16U  i; 
    569              
    570              BSP_RAM_REMAP_TEST_BYTE = 0xAA;                             /* Write a byte to RAM   */
    571              if (BSP_RAM_REMAP_TEST_BYTE != 0xAA) {                      /* Check if the write to RAM worked v                       */
    572                  AT91C_BASE_MC->MC_RCR =  1;                             /* If so, toggle REMAP register                             */
    573              }
    574          
    575              AT91C_BASE_AIC->AIC_ICCR  =  AT91C_BASE_AIC->AIC_ISR;       /* Clear the current interrupt (if any pending)             */
    576              AT91C_BASE_AIC->AIC_EOICR =  0x00000000;                    /* End-of-interrupt command                                 */
    577              
    578              for (i = 0; i < 32; i++) {                                  /* Assign dummy ISR                                         */
    579                   BSP_IntVectSet ((CPU_INT08U   )i,
    580                                   (CPU_INT08U   )0,
    581                                   (CPU_INT08U   )BSP_INT_SCR_TYPE_INT_HIGH_LEVEL_SENSITIVE,
    582                                   (CPU_FNCT_VOID)BSP_DummyISR_Handler);
    583                      
    584              }
    585          
    586              AT91C_BASE_AIC->AIC_SPU   = (CPU_INT32U)0;
    587              AT91C_BASE_AIC->AIC_DCR = DEF_BIT_00;
    588          }
    589          
    590          
    591          /*
    592          *********************************************************************************************************
    593          *                                       BSP_ResetInit()
    594          *
    595          * Description : (1) Initialize NRST interruption:
    596          *
    597          * Argument(s) : none.
    598          *
    599          * Return(s)   : none.
    600          *
    601          * Caller(s)   : BSP_Init()
    602          *
    603          * Note(s)     : none.
    604          *********************************************************************************************************
    605          */
    606          static  void  BSP_ResetInit (void)
    607          {   
    608            
    609             AT91C_BASE_RSTC->RSTC_RMR = (CPU_INT32U)(0xA5 << 24) | AT91C_RSTC_URSTIEN ;  //enable NRST interrupt    
    610             AT91C_BASE_RSTC->RSTC_RSR; // read RSR, clear previous data   
    611             
    612          }
    613          
    614          
    615          /*
    616          *********************************************************************************************************
    617          *                                          BSP_IntVectSet()
    618          *
    619          * Description : This function sets the specified interrupt source's ISR handler call back function.
    620          *
    621          * Argument(s) : per_id          The interrupt id
    622          *                               BSP_PER_ID_AIC_FIQ
    623          *                               BSP_PER_ID_SYSC
    624          *                               BSP_PER_ID_PIOA
    625          *                               BSP_PER_ID_PIOB
    626          *                                     .
    627          *                                     .
    628          *                                     .
    629          *                               BSP_PER_ID_AIC
    630          *
    631          *               int_prio        Interrupt priority level. 0(lowest) - 7 (highest).
    632          *
    633          *               int_src_type    Interrupt source type.
    634          *                               BSP_INT_SCR_TYPE_INT_HIGH_LEVEL_SENSITIVE
    635          *                               BSP_INT_SCR_TYPE_INT_POSITIVE_EDGE_TRIG
    636          *                               BSP_INT_SCR_TYPE_EXT_LOW_LEVEL_SENSITIVE
    637          *                               BSP_INT_SCR_TYPE_EXT_HIGH_LEVEL_SENSITIVE
    638          *                               BSP_INT_SCR_TYPE_EXT_NEGATIVE_EDGE_TRIG
    639          *                               BSP_INT_SCR_TYPE_EXT_POSITIVE_EDGE_TRIG
    640          *                                                
    641          *               int_isr         ISR handler function in the form of 'void ISR_Handler (void)'.
    642          *
    643          * Returns    : none
    644          *********************************************************************************************************
    645          */
    646          void  BSP_IntVectSet (CPU_INT08U     per_id,
    647                                CPU_INT08U     int_prio,
    648                                CPU_INT08U     int_src_type,
    649                                CPU_FNCT_VOID  int_isr_fnct)
    650          {
    651              CPU_INT08U  aic_scr_type;
    652                                
    653                                                                          /* ---------------- ARGUMENTS CHECKING -------------- */
    654              if (int_prio > BSP_AIC_INT_PRIO_MAX) {
    655                  return;
    656              }
    657              
    658              if (int_isr_fnct == (CPU_FNCT_VOID)0 ) {
    659                  return;
    660              }
    661           
    662              if (per_id > BSP_PER_ID_MAX) { 
    663                  return;
    664              }
    665          
    666                                                                          /* Set the interrupt vector with the ISR handler      */
    667              AT91C_BASE_AIC->AIC_SVR[per_id] = (CPU_INT32U)int_isr_fnct;
    668              
    669              switch (int_src_type) {
    670                  case BSP_INT_SCR_TYPE_INT_HIGH_LEVEL_SENSITIVE:
    671                  case BSP_INT_SCR_TYPE_EXT_LOW_LEVEL_SENSITIVE:
    672                       aic_scr_type = 0x00;
    673                       break;
    674              
    675                  case BSP_INT_SCR_TYPE_INT_POSITIVE_EDGE_TRIG:
    676                  case BSP_INT_SCR_TYPE_EXT_NEGATIVE_EDGE_TRIG:
    677                       aic_scr_type = 0x01;
    678                       break;
    679          
    680                  case BSP_INT_SCR_TYPE_EXT_HIGH_LEVEL_SENSITIVE:
    681                       aic_scr_type = 0x02;
    682                       break;
    683          
    684                  case BSP_INT_SCR_TYPE_EXT_POSITIVE_EDGE_TRIG:
    685                       aic_scr_type = 0x03;
    686                       break;
    687          
    688                  default:
    689                       aic_scr_type = 0x00;
    690                       break;             
    691              }
    692                                                                    
    693              AT91C_BASE_AIC->AIC_SMR[per_id] = (int_prio         )       /* Set Interrupt priority and type                    */
    694                                              | (aic_scr_type << 5);
    695          }
    696          
    697          /*
    698          *********************************************************************************************************
    699          *                                        BSP_DummyISR_Handler()
    700          *
    701          * Description : Handle invalid IRQs.
    702          *
    703          * Argument(s) : none.
    704          *
    705          * Return(s)   : none.
    706          *********************************************************************************************************
    707          */
    708          
    709          static  void  BSP_DummyISR_Handler (void)
    710          {
    711              CPU_INT32U  irq_id;
    712          
    713          
    714              AT91C_BASE_AIC->AIC_IVR  = 0;                               /* Debug variant of vector read                       */
    715              irq_id                   = AT91C_BASE_AIC->AIC_ISR & 0x1F;  /* Retrieve the ID of the interrupting source         */
    716              BSP_IntClr(irq_id);                                         /* Clear the current interrupt                        */
    717                                        
    718          }
    719          
    720          /*
    721          *********************************************************************************************************
    722          *********************************************************************************************************
    723          **                                         LED FUNCTIONS
    724          *********************************************************************************************************
    725          *********************************************************************************************************
    726          */
    727          
    728          
    729          
    730          
    731          
    732          
    733          
    734          /*
    735          *********************************************************************************************************
    736          *********************************************************************************************************
    737          **                                       MAIN OSCILLATOR FUNCTIONS
    738          *********************************************************************************************************
    739          *********************************************************************************************************
    740          */
    741          
    742          /*
    743          *********************************************************************************************************
    744          *                                           BSP_MainOscDis()
    745          *
    746          * Description : Disable the Main Oscillator.
    747          *
    748          * Argument(s) : none.
    749          *
    750          * Return(s)   : none.
    751          *                               
    752          * Caller(s)   : Application.
    753          *
    754          * Note(s)     : None.
    755          *********************************************************************************************************
    756          */
    757          
    758          void BSP_MainOscDis (void)
    759          {
    760              DEF_BIT_CLR(AT91C_BASE_PMC->PMC_MOR, DEF_BIT_00);
    761          }            
    762          
    763          
    764          /*
    765          *********************************************************************************************************
    766          *                                           BSP_MainOscEn()
    767          *
    768          * Description : Enable the Main Oscillator.
    769          *
    770          * Argument(s) : start_time    Specifies the number of slow clock cycles multiply by 8 
    771          *                             for the main oscillator start-up time.
    772          *
    773          * Return(s)   : DEF_TRUE      If the main oscillator is enabled and stabilized
    774          *               DEF_FALSE     If the main oscillator could not be stabilized during a period of time
    775          *                             specified by BSP_MAIN_OSC_MAX_START_UP_VAL
    776          * 
    777          * Caller(s)   : Application.
    778          *
    779          * Note(s)     : None.
    780          *********************************************************************************************************
    781          */
    782          
    783          CPU_BOOLEAN  BSP_MainOscEn (CPU_INT08U  start_time)
    784          {
    785              CPU_INT32U  timeout;
    786              
    787             
    788              AT91C_BASE_PMC->PMC_MOR = DEF_BIT_00
    789                                      | (start_time << 8);
    790          
    791              timeout                 = BSP_MAIN_OSC_MAX_START_UP_VAL;
    792              
    793              while ((timeout > 0) && 
    794                     (DEF_BIT_IS_CLR(AT91C_BASE_PMC->PMC_SR, DEF_BIT_00))) {
    795                  timeout--;       
    796              }
    797                     
    798              if (timeout == 0) {
    799                  return (DEF_TRUE);
    800              } else {
    801                  return (DEF_FALSE);
    802              }        
    803          }
    804                                  
    805          /*
    806          *********************************************************************************************************
    807          *                                        BSP_MainOscGetFreq()
    808          *
    809          * Description : Return the Frequency of the main oscillator.
    810          *
    811          * Argument(s) : none
    812          *               
    813          *
    814          * Return(s)   : The frequency of the Main Oscillator.
    815          *                               
    816          * Caller(s)   : Application.
    817          *
    818          * Note(s)     : (1) The Main Oscillator features a Main Clock frequency counter that provides the quartz frequency
    819          *                   connected to the Main Oscillator. Generally, this value is known by the system designer; however,
    820          *                   it is useful for the boot program to configure the device with the correct clock speed,
    821          *                   independently of the application.
    822          *
    823          *               (2) This functions should not be used  unless the current value of the RC oscillator frequency is know.
    824          *                   Since th RC oscillator characteristics may change (capacitancy value, etc) the value of BSP_SLOW_XTAL_FREQ needs 
    825          *                   to be changed.
    826          *********************************************************************************************************
    827          */
    828          
    829          CPU_INT32U  BSP_MainOscGetFreq (void)
    830          {
    831              CPU_INT32U  timeout;
    832              CPU_INT16U  main_clk_ctr;
    833              CPU_INT32U  freq;
    834              
    835              
    836              timeout = BSP_MAIN_OSC_MAINF_MAX_TIMEOUT_VAL;
    837              
    838              while ((timeout > 0) && 
    839                     (DEF_BIT_IS_CLR(AT91C_BASE_PMC->PMC_MCFR, DEF_BIT_16))) {
    840                  timeout--;       
    841              }
    842          
    843              if (timeout == 0) {
    844                  freq = 0;
    845              } else {
    846                  main_clk_ctr = (AT91C_BASE_PMC->PMC_MCFR & 0xFFFF);
    847                  freq         = (main_clk_ctr * BSP_SLOW_XTAL_FREQ) / 16;
    848              }    
    849              
    850              return (freq);
    851          }
    852          
    853          /*
    854          *********************************************************************************************************
    855          *********************************************************************************************************
    856          **                                          MASTER CLK FUNCTIONS
    857          *********************************************************************************************************
    858          *********************************************************************************************************
    859          */
    860          
    861          /*
    862          *********************************************************************************************************
    863          *                                            BSP_MclkGetFreq()
    864          *
    865          * Description : Get the master clock frequency (MCK).
    866          *
    867          * Argument(s) : none.
    868          *
    869          * Return(s)   : The master clock frequency, in Hz.
    870          *
    871          * Caller(s)   : Application.
    872          *
    873          * Note(s)     : none.
    874          *********************************************************************************************************
    875          */
    876          
    877          CPU_INT32U  BSP_MclkGetFreq (void)
    878          {
    879              CPU_INT32U  mclk_freq;
    880              CPU_INT08U  mclk_div;
    881              CPU_INT32U  mclk_src_freq;
    882              CPU_INT08U  mclk_src;
    883          
    884              
    885              mclk_src = (AT91C_BASE_PMC->PMC_MCKR & 0x03);
    886              
    887              switch (mclk_src) {
    888                  case BSP_CLK_SRC_SLOW:
    889                       mclk_src_freq = BSP_SLOW_XTAL_FREQ;
    890                       break;
    891              
    892                  case BSP_CLK_SRC_MAIN:
    893                       mclk_src_freq = BSP_MAIN_XTAL_FREQ; 
    894                       break;
    895          
    896                  case BSP_CLK_SRC_PLL:
    897                       mclk_src_freq = BSP_PLL_GetFreq(); 
    898                       break;
    899          
    900                  default:
    901                       mclk_src_freq = 0; 
    902                       break;
    903                       
    904              }
    905          
    906              mclk_div  = ((AT91C_BASE_PMC->PMC_MCKR >> 2) & 0x03);       /* Read the Master Clock preescaler                   */
    907              mclk_div  = DEF_BIT(mclk_div);
    908              mclk_freq = (mclk_src_freq / mclk_div);
    909          
    910              return (mclk_freq);
    911          }
    912          
    913          /*
    914          *********************************************************************************************************
    915          *                                            BSP_MclkCfg()
    916          *
    917          * Description : This function configure the Master clk and the Processor clk
    918          *
    919          * Argument(s) : clk_scr      Selects the Master clk source:
    920          *                            BSP_MCLK_SRC_SLOW      
    921          *                            BSP_MCLK_SRC_MAIN      
    922          *                            BSP_MCLK_SRC_PLL
    923          *   
    924          *
    925          *               cpu_clk_pre  The processor clk preescaler
    926          *                            BSP_CLK_PRE1   Selected clock
    927          *                            BSP_CLK_PRE2   Selected clock divided by  2
    928          *                            BSP_CLK_PRE4   Selected clock divided by  4
    929          *                            BSP_CLK_PRE8   Selected clock divided by  8
    930          *                            BSP_CLK_PRE16  Selected clock divided by 16
    931          *                            BSP_CLK_PRE32  Selected clock divided by 32
    932          *                            BSP_CLK_PRE64  Selected clock divided by 64
    933          *   
    934          * Return(s)   : DEF_TRUE      If the master clk is ready
    935          *               DEF_FALSE     If the main oscillator could not be set in BSP_MCLK_MAX_TIMEOUT cycles
    936          *                             or if a the paramater are incorrect
    937          *                             
    938          * 
    939          
    940          * Return(s)   : none. 
    941          *                               
    942          * Caller(s)   : Application.
    943          *
    944          * Note(s)     : None.
    945          *********************************************************************************************************
    946          */
    947          
    948          CPU_BOOLEAN  BSP_MclkCfg (CPU_INT08U  mclk_src,
    949                                    CPU_INT08U  cpu_clk_pre)
    950          
    951          {
    952              CPU_INT32U  timeout;
    953                                                                          /* --------------- ARGUMENTS CHECKING --------------- */
    954              if ((mclk_src != BSP_CLK_SRC_SLOW) &&
    955                  (mclk_src != BSP_CLK_SRC_MAIN) &&
    956                  (mclk_src != BSP_CLK_SRC_PLL)) {
    957                  return (DEF_FALSE);
    958              }
    959              
    960              if (cpu_clk_pre > BSP_CLK_PRE64) {
    961                  return (DEF_FALSE);
    962              }
    963           
    964              AT91C_BASE_PMC->PMC_MCKR = ((mclk_src    & 0x03) << 0)
    965                                       | ((cpu_clk_pre & 0x07) << 2);
    966              
    967             timeout = BSP_MCLK_MAX_TIMEOUT;
    968          
    969              while ((timeout > 0) && 
    970                    (DEF_BIT_IS_CLR(AT91C_BASE_PMC->PMC_SR, DEF_BIT_03))) {
    971                  timeout--;       
    972              }
    973                  
    974              if (timeout == 0) {
    975                  return (DEF_FALSE);
    976              } else {
    977                  return (DEF_TRUE);  
    978              }
    979          
    980          }
    981          
    982          
    983          
    984          /*
    985          *********************************************************************************************************
    986          *********************************************************************************************************
    987          **                                          PERIPHERAL CLK FUNCTIONS
    988          *********************************************************************************************************
    989          *********************************************************************************************************
    990          */
    991          
    992          
    993          /*
    994          *********************************************************************************************************
    995          *                                            BSP_PerClkDis()
    996          *
    997          * Description : Disable the corresponding peripheral clock
    998          *
    999          * Argument(s) : per_id        The peripheral id to be disabled (see note #1)
   1000          *                             BSP_PER_ID_PIOA
   1001          *                             BSP_PER_ID_PIOB
   1002          *                                     .
   1003          *                                     .
   1004          *                                     .
   1005          *                             BSP_PER_ID_AIC
   1006          *
   1007          * Return(s)   : none.
   1008          *
   1009          * Caller(s)   : Application.
   1010          *
   1011          * Note(s)     : (1). The peripheral clk id are defined in the bsp.h file.
   1012          *********************************************************************************************************
   1013          */
   1014          
   1015          void  BSP_PerClkDis (CPU_INT08U  per_id)
   1016          {
   1017                                                                          /* ----------------- ARGUMENTS CHECK ---------------- */
   1018              if ((per_id == BSP_PER_ID_AIC_FIQ) && 
   1019                  (per_id == BSP_PER_ID_SYSC   )) {
   1020                  return;
   1021              }
   1022              
   1023              if (per_id > BSP_PER_ID_MAX) {
   1024                  return;
   1025              }
   1026              
   1027              AT91C_BASE_PMC->PMC_PCDR = DEF_BIT(per_id);
   1028          }
   1029          
   1030          /*
   1031          *********************************************************************************************************
   1032          *                                            BSP_PerClkEn()
   1033          *
   1034          * Description : Enable the corresponding peripheral clock
   1035          *
   1036          * Argument(s) : per_id        The peripheral id to be enabled (see note #1)
   1037          *                             BSP_PER_ID_PIOA
   1038          *                             BSP_PER_ID_PIOB
   1039          *                                     .
   1040          *                                     .
   1041          *                                     .
   1042          *                             BSP_PER_ID_AIC
   1043          *
   1044          * Return(s)   : none.
   1045          *
   1046          * Caller(s)   : Application.
   1047          *
   1048          * Note(s)     : (1). The peripheral clk id are defined in the bsp.h file.
   1049          *********************************************************************************************************
   1050          */
   1051          
   1052          void  BSP_PerClkEn (CPU_INT08U per_id)
   1053          {
   1054                                                                          /* ----------------- ARGUMENTS CHECK ---------------- */
   1055              if ((per_id == BSP_PER_ID_AIC_FIQ) && 
   1056                  (per_id == BSP_PER_ID_SYSC   )) {
   1057                  return;
   1058              }
   1059              
   1060              if (per_id > BSP_PER_ID_MAX) {
   1061                  return;
   1062              }
   1063           
   1064              AT91C_BASE_PMC->PMC_PCER = DEF_BIT(per_id);
   1065          }
   1066          
   1067          /*
   1068          *********************************************************************************************************
   1069          *                                        BSP_PerClkGetStatus()
   1070          *
   1071          * Description : Get the status of the corresponding peripheral clock.
   1072          *
   1073          * Argument(s) : per_clk_id    The peripheral clock id to be enabled (see note #1)
   1074          *                             BSP_PER_CLK_ID_PIOA
   1075          *                             BSP_PER_CLK_ID_PIOB
   1076          *                                     .
   1077          *                                     .
   1078          *                                     .
   1079          *                             BSP_PER_ID_AIC
   1080          *
   1081          * Return(s)   : DEF_TRUE      If the specified clk is enabled 
   1082          *               DEF_FALSE     If the specidied clk is disabled.
   1083          * 
   1084          * Caller(s)   : Application.
   1085          *
   1086          * Note(s)     : None.
   1087          *********************************************************************************************************
   1088          */
   1089          
   1090          
   1091          CPU_BOOLEAN  BSP_PerClkGetStatus  (CPU_INT08U  per_id)
   1092          {
   1093              CPU_BOOLEAN status;
   1094             
   1095                                                                            /* ----------------- ARGUMENTS CHECK ---------------- */
   1096              if ((per_id == BSP_PER_ID_AIC_FIQ) && 
   1097                  (per_id == BSP_PER_ID_SYSC   )) {
   1098                  return (DEF_FALSE);
   1099              }
   1100              
   1101              if (per_id > BSP_PER_ID_MAX) {
   1102                  return (DEF_FALSE);
   1103              }
   1104           
   1105              status  = DEF_BIT_IS_SET(AT91C_BASE_PMC->PMC_PCSR, DEF_BIT(per_id));
   1106                  
   1107              return (status);
   1108          }
   1109          
   1110          /*
   1111          *********************************************************************************************************
   1112          *********************************************************************************************************
   1113          **                                   PROGRAMMABLE CLK FUNCTIONS
   1114          *********************************************************************************************************
   1115          *********************************************************************************************************
   1116          */
   1117          
   1118          /*
   1119          *********************************************************************************************************
   1120          *                                            BSP_PclkEn()
   1121          *
   1122          * Description : This function enables the Programmable clock x
   1123          *
   1124          * Argument(s) : pclk_id     The programmable clock id:
   1125          *                           BSP_PCLK_ID0
   1126          *                           BSP_PCLK_ID1
   1127          *                           BSP_PCLK_ID2
   1128          *
   1129          * Return(s)   : none.
   1130          *
   1131          * Caller(s)   : Application
   1132          *
   1133          * Note(s)     : none
   1134          *********************************************************************************************************
   1135          */
   1136          
   1137          void  BSP_PclkEn (CPU_INT08U pclk_id)
   1138          {    
   1139                                                                          /* --------------- ARGUMENTS CHECKING --------------- */
   1140              if (pclk_id > BSP_PCLK_ID2) { 
   1141                  return;
   1142              }
   1143              
   1144              AT91C_BASE_PMC->PMC_SCER =  DEF_BIT(pclk_id);
   1145          }
   1146          
   1147          /*
   1148          *********************************************************************************************************
   1149          *                                            BSP_PclkDis()
   1150          *
   1151          * Description : This function disables the Programmable clock x
   1152          *
   1153          * Argument(s) : pclk_id     The programmable clock id:
   1154          *                           BSP_PCLK_ID0
   1155          *                           BSP_PCLK_ID1
   1156          *                           BSP_PCLK_ID2
   1157          *
   1158          * Return(s)   : The master clock frequency, in Hz.
   1159          *
   1160          * Caller(s)   : Application
   1161          *
   1162          * Note(s)     : none.
   1163          *********************************************************************************************************
   1164          */
   1165          
   1166          void  BSP_PclkDis (CPU_INT08U pclk_id)
   1167          {
   1168                                                                          /* --------------- ARGUMENTS CHECKING --------------- */
   1169              if (pclk_id > BSP_PCLK_ID2) { 
   1170                  return;
   1171              }
   1172              
   1173              AT91C_BASE_PMC->PMC_SCDR = DEF_BIT(pclk_id);
   1174          }
   1175          
   1176          
   1177          /*
   1178          *********************************************************************************************************
   1179          *                                            BSP_PclkGetFreq()
   1180          *
   1181          * Description : This function gets the Programmable clk x frequency
   1182          *
   1183          * Argument(s) : pclk_id     The programmable clock id:
   1184          *                           BSP_PCLK00_ID
   1185          *                           BSP_PCLK01_ID
   1186          *                           BSP_PCLK02_ID
   1187          *
   1188          * Return(s)   : The programable clk frequency in Hz.
   1189          *
   1190          * Note(s)     : none.
   1191          *********************************************************************************************************
   1192          */
   1193          
   1194          CPU_INT32U  BSP_PclkGetFreq (CPU_INT08U  pclk_id)
   1195          {
   1196              CPU_INT08U  pclk_css;
   1197              CPU_INT32U  pclk_freq;
   1198              CPU_INT08U  pclk_pre;
   1199                        
   1200                                                                          /* --------------- ARGUMENTS CHECKING --------------- */
   1201              if (pclk_id > BSP_PCLK_ID2) { 
   1202                  return (0);
   1203              }
   1204          
   1205              pclk_css =  (AT91C_BASE_PMC->PMC_PCKR[pclk_id]        & 0x03);    
   1206              pclk_pre = ((AT91C_BASE_PMC->PMC_PCKR[pclk_id] >> 2)  & 0x07);    
   1207              pclk_pre = DEF_BIT(pclk_pre);
   1208              
   1209              switch (pclk_css) {
   1210          
   1211                  case BSP_CLK_SRC_SLOW: 
   1212                       pclk_freq = BSP_SLOW_XTAL_FREQ;
   1213                       break;
   1214          
   1215                  case BSP_CLK_SRC_MAIN: 
   1216                       pclk_freq = BSP_MainOscGetFreq();
   1217                       break;
   1218          
   1219                  case BSP_CLK_SRC_PLL:                           
   1220                       pclk_freq = BSP_PLL_GetFreq();
   1221                       break;
   1222                   
   1223                  case BSP_CLK_SRC_RESERVED: 
   1224                  default :
   1225                       pclk_freq = 0;
   1226              }            
   1227          
   1228              pclk_freq /= pclk_pre;
   1229          
   1230              return (pclk_freq);
   1231          }
   1232          
   1233          /*
   1234          *********************************************************************************************************
   1235          *                                            BSP_PclkCfg()
   1236          *
   1237          * Description : This function configure the programmable clk.
   1238          *
   1239          * Argument(s) : pclk_id      Programmable clk id:
   1240          *                            BSP_PCLK0_ID
   1241          *                            BSP_PCLK1_ID
   1242          *                            BSP_PCLK2_ID
   1243          
   1244          *
   1245          *               pclk_scr     Selects the programmable clk source:
   1246          *                            BSP_CLK_SRC_SLOW      
   1247          *                            BSP_CK_SRC_MAIN      
   1248          *                            BSP_CK_SRC_PLL
   1249          *
   1250          *               pclk_pre     The processor clk preescaler
   1251          *                            BSP_CLK_PRE1   Selected clock
   1252          *                            BSP_CLK_PRE2   Selected clock divided by  2
   1253          *                            BSP_CLK_PRE4   Selected clock divided by  4
   1254          *                            BSP_CLK_PRE8   Selected clock divided by  8
   1255          *                            BSP_CLK_PRE16  Selected clock divided by 16
   1256          *                            BSP_CLK_PRE32  Selected clock divided by 32
   1257          *                            BSP_CLK_PRE64  Selected clock divided by 64
   1258          *                                
   1259          * Return(s)   : none. 
   1260          *                               
   1261          * Caller(s)   : Application.
   1262          *
   1263          * Note(s)     : None.
   1264          *********************************************************************************************************
   1265          */
   1266          
   1267          void  BSP_PclkCfg (CPU_INT08U  pclk_id,                    
   1268                             CPU_INT08U  pclk_src,
   1269                             CPU_INT08U  pclk_pre)
   1270          {    
   1271                                                                          /* --------------- ARGUMENTS CHECKING --------------- */
   1272              if (pclk_id > BSP_PCLK_ID2) { 
   1273                  return;
   1274              }
   1275              
   1276              if ((pclk_src != BSP_CLK_SRC_SLOW) && 
   1277                  (pclk_src != BSP_CLK_SRC_MAIN) &&
   1278                  (pclk_src != BSP_CLK_SRC_PLL)) {
   1279                  return;                
   1280              }
   1281              
   1282              if (pclk_pre > BSP_CLK_PRE64) {
   1283                  return;
   1284              }
   1285              
   1286              AT91C_BASE_PMC->PMC_PCKR[pclk_id] = ((pclk_src & 0x03) << 0)
   1287                                                | ((pclk_pre & 0x07) << 2);
   1288          }
   1289          
   1290          /*
   1291          *********************************************************************************************************
   1292          *********************************************************************************************************
   1293          **                                             PLL FUNCTIONS
   1294          *********************************************************************************************************
   1295          *********************************************************************************************************
   1296          */
   1297          
   1298          /*
   1299          *********************************************************************************************************
   1300          *                                            BSP_PLL_GetFreq()
   1301          *
   1302          * Description : Enable  and configure the PLL
   1303          *
   1304          * Argument(s) : none.
   1305          *
   1306          * Return(s)   : DEF_TRUE      If the PLL is enabled and stabilized
   1307          *               DEF_FALSE     If the PLL could not be stabilized during a period of time
   1308          *                             specified by BSP_PLL_MAX_TIMEOUT
   1309          *                               
   1310          * Caller(s)   : Application.
   1311          *
   1312          * Note(s)     : None.
   1313          *********************************************************************************************************
   1314          */
   1315                      
   1316          CPU_INT32U  BSP_PLL_GetFreq (void)
   1317          {
   1318              CPU_INT08U  pll_div;
   1319              CPU_INT16U  pll_mul;
   1320              CPU_INT32U  freq;
   1321            
   1322                         
   1323              pll_div = ((AT91C_BASE_PMC->PMC_PLLR >>  0) & 0x0FF);
   1324              pll_mul = ((AT91C_BASE_PMC->PMC_PLLR >> 16) & 0x7FF);
   1325          
   1326              if (pll_div != 0) {
   1327                  freq = (BSP_MAIN_XTAL_FREQ * (pll_mul + 1)) / pll_div;    
   1328              }
   1329              
   1330              return (freq);        
   1331          }
   1332          
   1333          /*
   1334          *********************************************************************************************************
   1335          *                                               BSP_PLL_Set()
   1336          *
   1337          * Description : Enable  and configure the PLL
   1338          *
   1339          * Argument(s) : pll_div    The pll divider.            
   1340          *
   1341          *               pll_mul    The pll Multipler.   
   1342          *
   1343          *               pll_ctr    The number of slow clock cycles before the LOCKA bit ise set in PMC_SR.
   1344          *
   1345          *               pll_out    : PLL frequency optimization parameter (see note #1)
   1346          *
   1347          * Return(s)   : DEF_TRUE   If the PLL is enabled and stabilized
   1348          *               DEF_FALSE  If the PLL could not be stabilized during a period of time
   1349          *                          specified by BSP_PLL_MAX_TIMEOUT
   1350          *                               
   1351          * Caller(s)   : Application.
   1352          *
   1353          * Note(s)     : None.
   1354          *********************************************************************************************************
   1355          */
   1356                      
   1357          CPU_BOOLEAN  BSP_PLL_Cfg (CPU_INT16U  pll_mul,
   1358                                    CPU_INT08U  pll_div,
   1359                                    CPU_INT08U  pll_out,
   1360                                    CPU_INT08U  pll_ctr)
   1361          {
   1362              CPU_INT32U  timeout;
   1363              
   1364                                                                          /* ---------------- ARGUMENTS CHECKING -------------- */
   1365              if (pll_mul > BSP_PLL_MAX_MUL) {
   1366                  return (DEF_FALSE);
   1367              }
   1368              
   1369              if ((pll_out != 0x00) && 
   1370                  (pll_out != 0x01)) {
   1371                  return (DEF_FALSE);
   1372              }
   1373              
   1374              AT91C_BASE_PMC->PMC_PLLR  = ((pll_div       ) << 0 )
   1375                                        | ((pll_ctr & 0x3F) << 8 )
   1376                                        | ((pll_out & 0x03) << 14)
   1377                                        | ((pll_mul - 1   ) << 16);
   1378                                       
   1379              
   1380              timeout = BSP_PLL_MAX_TIMEOUT;
   1381          
   1382              while ((timeout > 0) &&     //wait until PLL is locked
   1383                    (DEF_BIT_IS_CLR(AT91C_BASE_PMC->PMC_SR, DEF_BIT_02))) {
   1384                  timeout--;       
   1385              }
   1386                  
   1387              if (timeout == 0) {
   1388                  return (DEF_FALSE);
   1389              } else {
   1390                  return (DEF_TRUE);  
   1391              }
   1392                           
   1393          }
   1394          
   1395          /*
   1396          *********************************************************************************************************
   1397          *                                          OS_CPU_ExceptHndlr()
   1398          *
   1399          * Description : Handle any exceptions.
   1400          *
   1401          * Argument(s) : except_id     ARM exception type:
   1402          *
   1403          *                                  OS_CPU_ARM_EXCEPT_RESET             0x00
   1404          *                                  OS_CPU_ARM_EXCEPT_UNDEF_INSTR       0x01
   1405          *                                  OS_CPU_ARM_EXCEPT_SWI               0x02
   1406          *                                  OS_CPU_ARM_EXCEPT_PREFETCH_ABORT    0x03
   1407          *                                  OS_CPU_ARM_EXCEPT_DATA_ABORT        0x04
   1408          *                                  OS_CPU_ARM_EXCEPT_ADDR_ABORT        0x05
   1409          *                                  OS_CPU_ARM_EXCEPT_IRQ               0x06
   1410          *                                  OS_CPU_ARM_EXCEPT_FIQ               0x07
   1411          *
   1412          * Return(s)   : none.
   1413          *
   1414          * Caller(s)   : OS_CPU_ARM_EXCEPT_HANDLER(), which is declared in os_cpu_a.s.
   1415          *
   1416          * Note(s)     : (1) Only OS_CPU_ARM_EXCEPT_FIQ and OS_CPU_ARM_EXCEPT_IRQ exceptions handler are implemented. 
   1417          *                   For the rest of the exception a infinite loop is implemented for debuging pruposes. This behavior
   1418          *                   should be replaced with another behavior (reboot, etc).
   1419          *********************************************************************************************************
   1420          */
   1421          
   1422          void  OS_CPU_ExceptHndlr (CPU_INT32U  except_id)
   1423          {
   1424              CPU_FNCT_VOID   pfnct;    
   1425              
   1426              switch (except_id) {
   1427                  case OS_CPU_ARM_EXCEPT_IRQ:    
   1428                       pfnct = (CPU_FNCT_VOID)AT91C_BASE_AIC->AIC_IVR;       /* Read the interrupt vector from the VIC          */
   1429               
   1430                       while (pfnct != (CPU_FNCT_VOID)0) {                   /* Make sure we don't have a NULL pointer          */
   1431                           (*pfnct)();                                       /* Execute the ISR for the interrupting device     */
   1432                           AT91C_BASE_AIC->AIC_EOICR = 0;                    /* End of handler                                  */
   1433                           pfnct = (CPU_FNCT_VOID)(AT91C_BASE_AIC->AIC_IVR); /* Read IRQ hanlder from the AIC                   */
   1434                       }
   1435          
   1436                       AT91C_BASE_AIC->AIC_EOICR = 0;                        /* End of handler                                  */
   1437                       break;
   1438          
   1439                  case OS_CPU_ARM_EXCEPT_FIQ:        
   1440                       pfnct = (CPU_FNCT_VOID)AT91C_BASE_AIC->AIC_FVR;       /* Read the interrupt vector from the VIC          */
   1441          
   1442                       while (pfnct != (CPU_FNCT_VOID)0) {                   /* Make sure we don't have a NULL pointer          */
   1443          
   1444                          (*pfnct)();                                        /* Execute the ISR for the interrupting device     */
   1445                          AT91C_BASE_AIC->AIC_EOICR = 0;                     /* End of handler                                  */
   1446                          pfnct = (CPU_FNCT_VOID)(AT91C_BASE_AIC->AIC_FVR);  /* Read FIQ handler from the AIC                   */
   1447                       }
   1448          
   1449                       AT91C_BASE_AIC->AIC_EOICR = 0;                        /* End of handler                                  */
   1450                       break;
   1451          
   1452                  case OS_CPU_ARM_EXCEPT_RESET:
   1453                       /* $$$$ Insert code to handle a Reset exception               */
   1454                  
   1455                  case OS_CPU_ARM_EXCEPT_UNDEF_INSTR:
   1456                      /* $$$$ Insert code to handle a Undefine Instruction exception */ 
   1457          
   1458                  case OS_CPU_ARM_EXCEPT_SWI:               
   1459                      /* $$$$ Insert code to handle a Software exception             */ 
   1460                  
   1461                  case OS_CPU_ARM_EXCEPT_PREFETCH_ABORT:
   1462                      /* $$$$ Insert code to handle a Prefetch Abort exception       */ 
   1463                  
   1464                  case OS_CPU_ARM_EXCEPT_DATA_ABORT:        
   1465                      /* $$$$ Insert code to handle a Data Abort exception           */ 
   1466                  
   1467                  case OS_CPU_ARM_EXCEPT_ADDR_ABORT:        
   1468                      /* $$$$ Insert code to handle a Address Abort exception        */ 
   1469                  default:        
   1470                      
   1471                      while (DEF_TRUE) {    /* Infinite loop on other exceptions. (see note #1)          */
   1472                          ;                                               
   1473                      }
   1474              }      
   1475          }
   1476          
   1477          
   1478          
   1479          /*
   1480          *********************************************************************************************************
   1481          *********************************************************************************************************
   1482          *                             uC/Probe PLUG-IN FOR uC/OS-II FUNCTIONS
   1483          *********************************************************************************************************
   1484          *********************************************************************************************************
   1485          */
   1486          
   1487          /*
   1488          *********************************************************************************************************
   1489          *                                       OSProbe_TmrInit()
   1490          *
   1491          * Description : Select & initialize a timer for use with the uC/Probe Plug-In for uC/OS-II.
   1492          *
   1493          * Argument(s) : none.
   1494          *
   1495          * Return(s)   : none.
   1496          *
   1497          * Caller(s)   : OSProbe_Init()
   1498          *
   1499          * Note(s)     : none.
   1500          *********************************************************************************************************
   1501          */
   1502          
   1503          #if (APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && (OS_PROBE_HOOKS_EN == 1)
   1504          void  OSProbe_TmrInit (void)
   1505          {
   1506          #if (OS_PROBE_TIMER_SEL == 0)
   1507              BSP_PerClkEn(BSP_PER_ID_TC0);                               /* Enable the peripheral clk                          */
   1508              AT91C_BASE_TCB0->TCB_TC0.TC_CCR  =  DEF_BIT_01;              /* TC0 timer disabled                                 */
   1509              AT91C_BASE_TCB0->TCB_TC0.TC_CMR &= ~(7 <<  0);               /* TIMER_CLOCK1 is input clk                          */
   1510              AT91C_BASE_TCB0->TCB_TC0.TC_CCR  =  DEF_BIT_00;              /* TC0 timer enabled                                  */
   1511              AT91C_BASE_TCB0->TCB_TC0.TC_CCR  =  DEF_BIT_02;              /* SWTRG to reset and start                           */
   1512          #endif
   1513          
   1514          #if (OS_PROBE_TIMER_SEL == 1)
   1515              BSP_PerClkEn(BSP_PER_ID_TC1);                               /* Enable the peripheral clk                          */
   1516              AT91C_BASE_TCB0->TCB_TC1.TC_CCR  =  DEF_BIT_01;              /* TC1 timer disabled                                 */
   1517              AT91C_BASE_TCB0->TCB_TC1.TC_CMR &= ~(7 <<  0);               /* TIMER_CLOCK1 is input clk                          */
   1518              AT91C_BASE_TCB0->TCB_TC1.TC_CCR  =  DEF_BIT_00;              /* TC1 timer enabled                                  */
   1519              AT91C_BASE_TCB0->TCB_TC1.TC_CCR  =  DEF_BIT_02;              /* SWTRG to reset and start                           */
   1520          #endif
   1521          
   1522          #if (OS_PROBE_TIMER_SEL == 2)
   1523              BSP_PerClkEn(BSP_PER_ID_TC2);                               /* Enable the peripheral clk                          */
   1524              AT91C_BASE_TCB0->TCB_TC2.TC_CCR  =  DEF_BIT_01;              /* TC2 timer disabled                                 */
   1525              AT91C_BASE_TCB0->TCB_TC2.TC_CMR &= ~(7 <<  0);               /* TIMER_CLOCK1 is input clk                          */
   1526              AT91C_BASE_TCB0->TCB_TC2.TC_CCR  =  DEF_BIT_00;              /* TC2 timer enabled                                  */
   1527              AT91C_BASE_TCB0->TCB_TC2.TC_CCR  =  DEF_BIT_02;              /* SWTRG to reset and start                           */
   1528          #endif
   1529          }
   1530          #endif
   1531          
   1532          
   1533          /*
   1534          *********************************************************************************************************
   1535          *                                        OSProbe_TmrRd()
   1536          *
   1537          * Description : Read the current counts of a 16-bit free running timer.
   1538          *
   1539          * Argument(s) : none.
   1540          *
   1541          * Return(s)   : The 16 bit counts (in a 32 bit variable) of the timer.
   1542          *********************************************************************************************************
   1543          */
   1544          
   1545          #if (APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && (OS_PROBE_HOOKS_EN == 1)
   1546          CPU_INT32U  OSProbe_TmrRd (void)
   1547          {
   1548              CPU_INT32U  cnts;
   1549          
   1550          
   1551          #if (OS_PROBE_TIMER_SEL == 0)
   1552              cnts = (CPU_INT32U)(AT91C_BASE_TCB0->TCB_TC0.TC_CV & 0x0000FFFF);    /* Read timer 0                                     */
   1553          #endif
   1554          
   1555          #if (OS_PROBE_TIMER_SEL == 1)
   1556              cnts = (CPU_INT32U)(AT91C_BASE_TCB0->TCB_TC1.TC_CV & 0x0000FFFF);    /* Read timer 1                                     */
   1557          #endif
   1558          
   1559          #if (OS_PROBE_TIMER_SEL == 2)
   1560              cnts = (CPU_INT32U)(AT91C_BASE_TCB0->TCB_TC2.TC_CV & 0x0000FFFF);    /* Read timer 2                                     */
   1561          #endif
   1562          
   1563              return (cnts);
   1564          }
   1565          #endif
   1566          
   1567          
   1568          /*
   1569          *********************************************************************************************************
   1570          *********************************************************************************************************
   1571          **                                     uC/OS-II TIMER FUNCTIONS
   1572          *********************************************************************************************************
   1573          *********************************************************************************************************
   1574          */
   1575          
   1576          /*
   1577          *********************************************************************************************************
   1578          *                                            BSP_Tmr_TickInit()
   1579          *
   1580          * Description : Initialize uC/OS-II's tick source; for the AT91SAM, the Periodic Interval Timer (PIT).
   1581          *
   1582          * Argument(s) : none.
   1583          *
   1584          * Return(s)   : none.
   1585          *
   1586          * Note(s)     : (1) PIT Interrupt frequency:
   1587          *
   1588          *                             MCLK        1
   1589          *                   Freq =    ---- * -----------
   1590          *                              16     (PIV + 1)
   1591          *
   1592          *
   1593          *                             MCLK      1
   1594          *                   PIV  =  ( ---- * ------ ) - 1
   1595          *                              16     Freq
   1596          *
   1597          *                   Where:
   1598          *
   1599          *                       MCLK = Master Clock
   1600          *                       Freq = Desired frequency (i.e. OS_TICKS_PER_SEC)
   1601          *********************************************************************************************************
   1602          */
   1603          
   1604          static  void  BSP_Tmr_TickInit (void)
   1605          {
   1606              CPU_INT32U  cnts;
   1607              CPU_INT32U  mclk_freq;
   1608          
   1609          
   1610              mclk_freq = BSP_MclkGetFreq();                              /* Determine the number of counts per tick.           */
   1611              cnts      = ((mclk_freq) / 16 / OS_TICKS_PER_SEC) - 1;
   1612          
   1613              
   1614              BSP_IntVectSet((CPU_INT08U   )BSP_PER_ID_SYSC,
   1615                             (CPU_INT08U   )0,
   1616                             (CPU_INT08U   )BSP_INT_SCR_TYPE_INT_HIGH_LEVEL_SENSITIVE,
   1617                             (CPU_FNCT_VOID)BSP_Sys_ISR_Handler);
   1618          
   1619              BSP_IntClr(BSP_PER_ID_SYSC);  
   1620              BSP_IntEn(BSP_PER_ID_SYSC);  
   1621                                                                          /* Enable the PIT with the correct compare value.      */
   1622              AT91C_BASE_PITC->PITC_PIMR = DEF_BIT_24                     /* Enable the periodic interval timer                  */ 
   1623                                         | DEF_BIT_25                     /* Enable the periodic interval timer interrupt        */ 
   1624                                         | cnts;                          /* Set the periodic interval value                     */
   1625          }
   1626          
   1627          
   1628          /*
   1629          *********************************************************************************************************
   1630          *                                       BSP_Tmr_TickISR_Handler()
   1631          *
   1632          * Description : Handle the PIT interrupt that is used to generate TICKs for uC/OS-II.
   1633          *
   1634          * Argument(s) : none.
   1635          *
   1636          * Return(s)   : none.
   1637          *
   1638          * Note(s)     : (1) The general SYS peripheral interrupt handler, Sys_ISR_Handler() issues the initial
   1639          *                   interrupt entrance command and clears the SYS interrupt in the AIC.
   1640          *********************************************************************************************************
   1641          */
   1642          
   1643          void  BSP_Tmr_TickISR_Handler (void)
   1644          {
   1645              CPU_INT32U  status;
   1646          
   1647          
   1648              status = AT91C_BASE_PITC->PITC_PIVR;
   1649              (void)status;                                               /* Prevent compiler warning about status set & not used.    */
   1650          
   1651              OSTimeTick();                                               /* Tell uC/OS-II about clock tick.                          */
   1652          }
   1653          
   1654          
   1655          /*
   1656          *********************************************************************************************************
   1657          *                                         BSP_Sys_ISR_Handler()
   1658          *
   1659          * Description : Handle SYS peripheral interrupts.
   1660          *
   1661          * Argument(s) : none.
   1662          *
   1663          * Note(s)     : (1) The interrupts from several devices are multiplexed for the SYS interrupt.  This
   1664          *                   handler currently handles the DBGU and PIT interrupts.
   1665          *
   1666          *               (2) AIC interrupts are cleared in this function; each handler called by this function
   1667          *                   need only clear its local source.
   1668          *********************************************************************************************************
   1669          */
   1670          volatile CPU_INT08U  Flag_Reset_Pin_Trigger = 0 ;
   1671          
   1672          void  BSP_Sys_ISR_Handler (void)
   1673          {
   1674            
   1675          #if ((APP_CFG_PROBE_COM_EN     == DEF_ENABLED) && \
   1676               (PROBE_RS232_CFG_COMM_SEL == PROBE_RS232_UART_DBG))
   1677              CPU_INT32U  dbgu_csr;
   1678              CPU_INT32U  dbgu_imr;
   1679          #endif
   1680          
   1681              AT91C_BASE_AIC->AIC_IVR = 0;          /* Write the IVR, as required in Protection Mode. */
   1682           
   1683              //check if PIT interruption assert
   1684              if ((AT91C_BASE_PITC->PITC_PISR & AT91C_PITC_PITS) ==  AT91C_PITC_PITS) {
   1685          
   1686                  BSP_Tmr_TickISR_Handler();
   1687              }
   1688              
   1689              //check if NRST interruption assert //PQ
   1690              if( AT91C_BASE_RSTC->RSTC_RSR & AT91C_RSTC_URSTS ) {       
   1691                  Flag_Reset_Pin_Trigger++ ; 
   1692                    
   1693              }   
   1694              
   1695               //check if DBGU interruption assert
   1696          #if ((APP_CFG_PROBE_COM_EN     == DEF_ENABLED) && \
   1697               (PROBE_RS232_CFG_COMM_SEL == PROBE_RS232_UART_DBG))
   1698              dbgu_csr = AT91C_BASE_DBGU->DBGU_CSR;
   1699              dbgu_imr = AT91C_BASE_DBGU->DBGU_IMR;
   1700          
   1701              if ((dbgu_csr & dbgu_imr) != 0) {
   1702                  ProbeRS232_RxTxISRHandler();
   1703              }
   1704          #endif    
   1705              
   1706          
   1707              BSP_IntClr(BSP_PER_ID_SYSC);
   1708          }
   1709          
   1710          
   1711          /*
   1712          *********************************************************************************************************
   1713          *********************************************************************************************************
   1714          **                                       Serial Port Communications
   1715          *********************************************************************************************************
   1716          *********************************************************************************************************
   1717          */
   1718          
   1719          /*
   1720          *********************************************************************************************************
   1721          *                                                   BSP_Ser_Init()
   1722          *
   1723          * Description : Initialize a serial port for communication.
   1724          *
   1725          * Argument(s) : baud_rate: Desire baud rate for serial communication.
   1726          *
   1727          * Return(s)   : none.
   1728          *********************************************************************************************************
   1729          */
   1730          
   1731          void  BSP_Ser_Init (CPU_INT32U baud_rate)
   1732          {
   1733              CPU_INT32U  pclk_freq;
   1734          
   1735          
   1736              pclk_freq                  = BSP_CPU_ClkFreq();             /* Get the UART input clock frequency                       */
   1737          
   1738          //#if (BSP_CFG_SER_COMM_SEL == BSP_SER_COMM_UART_DBG)  
   1739              if( Debug_COM_Sel == 0 ) {
   1740                
   1741              AT91C_BASE_PIOA->PIO_PDR  |= BSP_GPIOA_DBG;                 /* Set GPIOA pins 9 and 10 as DBGU UART pins                */
   1742              AT91C_BASE_PIOA->PIO_ASR  |= BSP_GPIOA_DBG;                 /* Select GPIOA attached peripheral (DBGU)                  */
   1743              
   1744              AT91C_BASE_PMC->PMC_PCDR   = (1 << AT91C_ID_SYS);
   1745               
   1746              AT91C_BASE_DBGU->DBGU_CR   =  AT91C_US_RSTRX 
   1747                                         |  AT91C_US_RSTTX ;             /*  Reset the receiver  and transmitter                      */
   1748                
   1749              AT91C_BASE_DBGU->DBGU_IDR  = AT91C_US_RXRDY                 /* Disable Rx interrupts                                    */
   1750                                         | AT91C_US_TXRDY;                /* Disable Tx interrupt                                     */   
   1751              
   1752              AT91C_BASE_DBGU->DBGU_CR   = AT91C_US_RXEN                  /* Enable the receiver                                      */
   1753                                         | AT91C_US_TXEN   ;              /* Enable the transmitter                                   */
   1754                                
   1755                
   1756              AT91C_BASE_DBGU->DBGU_MR   = AT91C_US_USMODE_NORMAL         /* Normal mode selected                                     */
   1757                                         | AT91C_US_PAR_NONE;             /* No parity bit selected                                   */
   1758          
   1759                                                                          /* Set the DBGU baud rate                                   */
   1760              AT91C_BASE_DBGU->DBGU_BRGR = (CPU_INT16U)((pclk_freq) / baud_rate / 16);
   1761          
   1762              AT91C_BASE_PMC->PMC_PCER   = (1 << AT91C_ID_SYS);           /* Enable the DBGU peripheral clock                         */
   1763          //#endif
   1764              } else {
   1765          //#if (BSP_CFG_SER_COMM_SEL == BSP_SER_COMM_UART_UART_01)    
   1766                                                                          /* Set GPIOA pins 0 & 1 as US0 pins                         */
   1767              AT91C_BASE_PIOA->PIO_PDR   = BSP_GPIOA_UART0;
   1768              AT91C_BASE_PIOA->PIO_ASR   = BSP_GPIOA_UART0;
   1769              
   1770              AT91C_BASE_US0->US_CR      = AT91C_US_RSTRX 
   1771                                         | AT91C_US_RSTTX ;               /* Reset the receiver  and transmitter                      */
   1772              
   1773                                                                          /* ---------------------- SETUP US0 ----------------------- */
   1774              AT91C_BASE_US0->US_IDR     = 0xFFFFFFFF;  //disbale all int
   1775              AT91C_BASE_US0->US_CR      = AT91C_US_RXEN  | AT91C_US_TXEN;  /* Enable the receiver  and transmitter                   */                           
   1776                                          
   1777              AT91C_BASE_US0->US_MR      = AT91C_US_USMODE_NORMAL         /* RS232C mode selected                                     */
   1778                                         | AT91C_US_CLKS_CLOCK            /* USART input CLK is MCK                                   */
   1779                                         | AT91C_US_CHRL_8_BITS           /* 8 bit data to be sent                                    */
   1780                                         | AT91C_US_PAR_NONE              /* No parity bit selected                                   */
   1781                                         | AT91C_US_NBSTOP_1_BIT;         /* 1 stop bit selected                                      */
   1782                                                                          /* Set the USART baud rate                                  */
   1783              AT91C_BASE_US0->US_BRGR    = (CPU_INT16U)((pclk_freq) / baud_rate / 16);
   1784            
   1785              AT91C_BASE_US0->US_PTCR    = AT91C_PDC_TXTDIS               //Disable previous PDC settings
   1786                                         | AT91C_PDC_RXTDIS;
   1787                                                                          /* ---------------- INITIALIZE AIC FOR US0 ---------------- */
   1788              AT91C_BASE_PMC->PMC_PCER   = (1 << AT91C_ID_US0);           /* Enable the US0 peripheral clock                          */
   1789          //#endif    
   1790              }
   1791              
   1792          }
   1793          
   1794          /*
   1795          *********************************************************************************************************
   1796          *                                                BSP_Ser_WrByte()
   1797          *
   1798          * Description : Writes a single byte to a serial port.
   1799          *
   1800          * Argument(s) : tx_byte     The character to output.
   1801          *
   1802          * Return(s)   : none.
   1803          *
   1804          * Note(s)     : (1) This functino blocks until room is available in the UART for the byte to be sent.
   1805          *********************************************************************************************************
   1806          */
   1807          
   1808          void BSP_Ser_WrByte(CPU_CHAR tx_byte)
   1809          {
   1810            
   1811              unsigned char   err;  
   1812              
   1813              OSSemPend( Bsp_Ser_Tx_Sem_lock, 0, &err );  
   1814              
   1815          //#if (BSP_CFG_SER_COMM_SEL == BSP_SER_COMM_UART_DBG) 
   1816              if( Debug_COM_Sel == 0 ) {   
   1817                
   1818                  while ((AT91C_BASE_DBGU->DBGU_CSR & AT91C_US_TXRDY) == 0);  /*  Wait for room in the transmit register.                 */
   1819                  AT91C_BASE_DBGU->DBGU_THR = tx_byte;
   1820          //#endif    
   1821                  
   1822              } else if( Debug_COM_Sel == 1 ){
   1823                
   1824          //#if (BSP_CFG_SER_COMM_SEL == BSP_SER_COMM_UART_01) 
   1825                  while ((AT91C_BASE_US0->US_CSR & AT91C_US_TXRDY) == 0);  /*  Wait for room in the transmit register.                 */
   1826                  AT91C_BASE_US0->US_THR    = tx_byte;
   1827              
   1828          //#endif    
   1829              }  else {
   1830              
   1831                  // DBG UART used as CHIP_UART connection now
   1832              }
   1833              
   1834              OSSemPost( Bsp_Ser_Tx_Sem_lock );
   1835          
   1836          }
   1837          
   1838          /*
   1839          *********************************************************************************************************
   1840          *                                                BSP_Ser_WrStr()
   1841          *
   1842          * Description : Write a character string to a serial port.
   1843          *
   1844          * Argument(s) : tx_str      A character string.
   1845          *
   1846          * Return(s)   : none.
   1847          *********************************************************************************************************
   1848          */
   1849          
   1850          void  BSP_Ser_WrStr (CPU_CHAR *tx_str)
   1851          {
   1852              while ((*tx_str) != 0) {
   1853          //        if (*tx_str == '\n') {
   1854          //            BSP_Ser_WrByte('\n');
   1855          //            BSP_Ser_WrByte('\r');
   1856          //            tx_str++;
   1857          //        } else {
   1858                      BSP_Ser_WrByte(*tx_str++);
   1859          //        }        
   1860              }
   1861          }
   1862          
   1863          /*
   1864          *********************************************************************************************************
   1865          *                                                BSP_Ser_RdByte()
   1866          *
   1867          * Description : Read a byte from a serial port and echo byte to port.
   1868          *
   1869          * Argument(s) : none.
   1870          *
   1871          * Return(s)   : A byte containing the value of the received charcater.
   1872          *
   1873          * Note(s)     : (1) This function blocks until a character appears at the port.
   1874          *********************************************************************************************************
   1875          */
   1876          
   1877          CPU_INT08U  BSP_Ser_RdByte (void)
   1878          {
   1879              CPU_INT08U      rx_byte;
   1880              unsigned char   err; 
   1881              
   1882              OSSemPend( Bsp_Ser_Rx_Sem_lock, 0, &err );  
   1883          
   1884               if( Debug_COM_Sel == 0 ) {   
   1885                 
   1886                  //#if (BSP_CFG_SER_COMM_SEL == BSP_SER_COMM_UART_DBG) 
   1887                  while ((AT91C_BASE_DBGU->DBGU_CSR & AT91C_US_RXRDY) == 0) {     /*  Wait for a byte to show up.                         */
   1888                      OSTimeDly(2);
   1889                  }
   1890                  rx_byte = (CPU_INT08U)(AT91C_BASE_DBGU->DBGU_RHR & 0x00FF);     /* Read the character.                                  */
   1891              //#endif  
   1892                  
   1893               } else if( Debug_COM_Sel == 1 ){
   1894             
   1895              //#if (BSP_CFG_SER_COMM_SEL == BSP_SER_COMM_UART_01) 
   1896                  while ((AT91C_BASE_US0->US_CSR & AT91C_US_RXRDY) == 0) {     /*  Wait for a byte to show up.                         */
   1897                      OSTimeDly(2);
   1898                  }
   1899                  rx_byte = (CPU_INT08U)(AT91C_BASE_US0->US_RHR & 0x00FF);     /* Read the character.                                  */
   1900              //#endif   
   1901                  
   1902               } else {
   1903                 
   1904                  // DBG UART used as CHIP_UART connection now
   1905               }
   1906               
   1907               OSSemPost( Bsp_Ser_Rx_Sem_lock );
   1908              
   1909              return (rx_byte);
   1910          }
   1911          
   1912          /*
   1913          *********************************************************************************************************
   1914          *                                                BSP_Ser_RdStr()
   1915          *
   1916          * Description : Read a string from a serial port.
   1917          *
   1918          * Argument(s) : rx_str      A pointer to a buffer at which the string can be stored.
   1919          *               len         The size of the string that will be read.
   1920          *
   1921          * Return(s)   : none.
   1922          *********************************************************************************************************
   1923          */
   1924          
   1925          void  BSP_Ser_RdStr (CPU_CHAR    *rx_str,
   1926                               CPU_INT32U   len)
   1927          {
   1928              CPU_CHAR  input;
   1929              CPU_CHAR  input_ix;
   1930          
   1931          
   1932              input_ix  = 0;
   1933              rx_str[0] = 0;
   1934          
   1935              while (DEF_TRUE)
   1936              {
   1937                  input = BSP_Ser_RdByte();
   1938          
   1939                  if ((input == '\r') ||
   1940                      (input == '\n')) {
   1941                      BSP_Ser_Printf("\n");
   1942                      rx_str[input_ix] = 0;
   1943                      break;
   1944                  }
   1945          
   1946                  if (input == '\b') {
   1947                      if (input_ix > 0) {
   1948                          BSP_Ser_Printf("\b \b");
   1949                          input_ix--;
   1950                          rx_str[input_ix] = 0;
   1951                      }
   1952                  }
   1953          
   1954                  if (ASCII_IS_PRINT(input)) {
   1955                      BSP_Ser_Printf("%c", input);
   1956                      rx_str[input_ix] = input;
   1957                      input_ix++;
   1958                      if (input_ix >= len) {
   1959                         input_ix = len;
   1960                      }
   1961                  }
   1962              }
   1963          }
   1964          
   1965          /*
   1966          *********************************************************************************************************
   1967          *                                                BSP_Ser_Printf()
   1968          *
   1969          * Description : Formatted outout to the serial port.
   1970          *
   1971          * Argument(s) : format      Format string follwing the C format convention.
   1972          *
   1973          * Return(s)   : none.
   1974          *********************************************************************************************************
   1975          */
   1976          
   1977          void  BSP_Ser_Printf (CPU_CHAR *format, ...)
   1978          {
   1979              static  CPU_CHAR  buffer[80 + 1];
   1980                      va_list   vArgs;
   1981          
   1982          
   1983              va_start(vArgs, format);
   1984              vsprintf((char *)buffer, (char const *)format, vArgs);
   1985              va_end(vArgs);
   1986          
   1987              BSP_Ser_WrStr((CPU_CHAR*) buffer);
   1988          }
   1989          
   1990          /*
   1991          *********************************************************************************************************
   1992          *********************************************************************************************************
   1993          **                                         USB CLK FUNCTIONS
   1994          *********************************************************************************************************
   1995          *********************************************************************************************************
   1996          */
   1997          
   1998          /*
   1999          *********************************************************************************************************
   2000          *                                            BSP_USBclkEn()
   2001          *
   2002          * Description : This functions enables the 48 Mhz clock of the USB Device port 
   2003          *
   2004          * Argument(s) : none.
   2005          *
   2006          * Return(s)   : none.
   2007          *
   2008          * Caller(s)   : Application.
   2009          
   2010          * Note(s)     : None
   2011          *********************************************************************************************************
   2012          */
   2013          
   2014          void  BSP_USBclkEn (void) 
   2015          {
   2016              AT91C_BASE_PMC->PMC_SCER = DEF_BIT_07;
   2017          }
   2018          
   2019          /*
   2020          *********************************************************************************************************
   2021          *                                            BSP_USBclkDis()
   2022          *
   2023          * Description : This functions disables the 48 Mhz clock of the USB Device port 
   2024          *
   2025          * Argument(s) : none.
   2026          *
   2027          * Return(s)   : none.
   2028          *
   2029          * Caller(s)   : Application.
   2030          
   2031          * Note(s)     : None
   2032          *********************************************************************************************************
   2033          */
   2034          
   2035          void  BSP_USBclkDis (void) 
   2036          {
   2037              AT91C_BASE_PMC->PMC_SCDR = DEF_BIT_07;
   2038          }
   2039          
   2040          /*
   2041          *********************************************************************************************************
   2042          *                                         BSP_USBclkGetFreq()
   2043          *
   2044          * Description : Get the USB clk frequency
   2045          *
   2046          * Argument(s) : none.
   2047          *
   2048          * Return(s)   : The USB clk frequency in Hz.
   2049          *
   2050          * Caller(s)   : Application.
   2051          
   2052          * Note(s)     : None
   2053          *********************************************************************************************************
   2054          */
   2055          
   2056          CPU_INT32U  BSP_USBclkGetFreq (void) 
   2057          {
   2058              CPU_INT32U  pll_freq;
   2059              CPU_INT08U  div;    
   2060          
   2061          
   2062              pll_freq  = BSP_PLL_GetFreq();             
   2063              div       = (AT91C_BASE_PMC->PMC_PLLR >> 8);
   2064              div       = DEF_BIT(div);
   2065          
   2066              pll_freq /= div;
   2067              
   2068              return (pll_freq);
   2069          }
   2070          
   2071          /*
   2072          *********************************************************************************************************
   2073          *                                         BSP_USBclkCfg()
   2074          *
   2075          * Description : Configure the USB Clk
   2076          *
   2077          * Argument(s) : div       The USB clk divider
   2078          *
   2079          * Return(s)   : none.
   2080          *
   2081          * Caller(s)   : none.
   2082          *
   2083          * Note(s)     : none.
   2084          *********************************************************************************************************
   2085          */
   2086          
   2087          void  BSP_USBclkCfg (CPU_INT08U div) 
   2088          {
   2089                                                                          /* -------------- ARGUMENTS CHECKING ---------------- */
   2090              if (div > BSP_USB_CLK_DIV4) {
   2091                  return;    
   2092              }
   2093              
   2094              DEF_BIT_CLR(AT91C_BASE_PMC->PMC_PLLR, (DEF_BIT_28 | DEF_BIT_29));
   2095              DEF_BIT_SET(AT91C_BASE_PMC->PMC_PLLR, (div << 28));
   2096          
   2097          }
   2098          
   2099          
   2100          /*
   2101          *********************************************************************************************************
   2102          *                                         Beep()
   2103          *
   2104          * Description : Beep Buzzer
   2105          *
   2106          * Argument(s) : beep times.
   2107          *
   2108          * Return(s)   : none.
   2109          *
   2110          * Caller(s)   : App_TaskJoy()
   2111          *
   2112          * Note(s)     : none.
   2113          *********************************************************************************************************
   2114          */
   2115          void Beep( INT32U beep_cycles)
   2116          {
   2117            
   2118             INT32U i ;
   2119             
   2120             for(i = 0; i< beep_cycles; i++)  {
   2121              
   2122                  PIO_Clear(&PinBuzzer); //beep on
   2123                  LED_Clear(LED_DS1); 
   2124                  LED_Set(LED_DS2);
   2125                  OSTimeDly(250);           
   2126                  PIO_Set(&PinBuzzer); //beep off
   2127                  LED_Clear(LED_DS2); 
   2128                  LED_Set(LED_DS1);
   2129                  OSTimeDly(250); //delay_ms(250);  
   2130              
   2131              }
   2132             
   2133          }
   2134          
   2135          
   2136          /*
   2137          *********************************************************************************************************
   2138          *                                         get_os_state()
   2139          *
   2140          * Description : get_os_state
   2141          *
   2142          * Argument(s) : none.
   2143          *
   2144          * Return(s)   : none.
   2145          *
   2146          * Caller(s)   : none.
   2147          *
   2148          * Note(s)     : none.
   2149          *********************************************************************************************************
   2150          */
   2151          
   2152          const CPU_INT08S os_stat_desp[][6] = {"Sem  ","MBox ","Q    ","Suspd","Mutex","Flag ","  *  ","Multi","Ready"} ;
   2153          
   2154          CPU_INT08S* get_os_state( INT8U os_state ) 
   2155          {
   2156            
   2157            CPU_INT08U i = 0 ;
   2158          
   2159            for(i=0;i<8;i++) {
   2160              if(os_state == (1<<i) ) {     
   2161                return  (CPU_INT08S*)os_stat_desp[i];      
   2162              }
   2163            }
   2164            
   2165            return  (CPU_INT08S*)os_stat_desp[i];  
   2166            
   2167          }
   2168          
   2169          
   2170          /*
   2171          *********************************************************************************************************
   2172          *                                         Get_Task_Info()
   2173          *
   2174          * Description : Print task related information
   2175          *
   2176          * Argument(s) : none.
   2177          *
   2178          * Return(s)   : none.
   2179          *
   2180          * Caller(s)   : none.
   2181          *
   2182          * Note(s)     : none.
   2183          *********************************************************************************************************
   2184          */
   2185          
   2186          void  Get_Task_Info (void)
   2187          {
   2188              OS_TCB    *ptcb;
   2189              CPU_INT08U index = 1 ;
   2190              
   2191              if (OSRunning == OS_TRUE) {
   2192               
   2193                  APP_TRACE_INFO(("------------------------------------------------------   DEBUG INFORMATION   -------------------------------------------------------\r\n"));
   2194                  APP_TRACE_INFO(("|-------------------------   T  A  S  K   --------------------------------------|----------------   S  T  A  C  K   ---------------|\r\n"));
   2195                  APP_TRACE_INFO(("| ID  |    Name    | Priority | CtxSwCtr | State | Delay |      Waitting On     |  Point@ | Cur. | Max. | Size | Starts@ | Ends@   |\r\n"));
   2196                  ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
   2197                  while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */          
   2198                      //APP_TRACE_INFO(( "|%4d ",ptcb->OSTCBId ));  //same as ptcb->OSTCBPrio
   2199                      APP_TRACE_INFO(( "|%2d ",index++ ));
   2200                      APP_TRACE_INFO(( "%13.13s",ptcb->OSTCBTaskName ));
   2201                      APP_TRACE_INFO(( "      %2d ",ptcb->OSTCBPrio ));
   2202                      APP_TRACE_INFO(( "  %10d ",ptcb->OSTCBCtxSwCtr ));            
   2203                      APP_TRACE_INFO(( "   %s  ",get_os_state( ptcb->OSTCBStat )  ));
   2204                      APP_TRACE_INFO(( " %5d ",ptcb->OSTCBDly ));
   2205                      APP_TRACE_INFO(( " %22.22s ", (INT32U)(ptcb->OSTCBEventPtr) == 0 ?  (INT8U *)" " : ptcb->OSTCBEventPtr->OSEventName ));  
   2206                        
   2207                      APP_TRACE_INFO(( " %08X ",ptcb->OSTCBStkPtr ));
   2208                      APP_TRACE_INFO(( " %4d ",(ptcb->OSTCBStkBase - ptcb->OSTCBStkPtr)*4 ));
   2209                      APP_TRACE_INFO(( " %5d ",ptcb->OSTCBStkUsed ));
   2210                      APP_TRACE_INFO(( " %5d ",ptcb->OSTCBStkSize * 4 ));
   2211                      APP_TRACE_INFO(( " %08X ",ptcb->OSTCBStkBase ));
   2212                      APP_TRACE_INFO(( " %08X ",ptcb->OSTCBStkBottom ));           
   2213                      APP_TRACE_INFO(( " |\r\n" ));     
   2214                      ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */          
   2215                  }
   2216                  APP_TRACE_INFO(("------------------------------------------------------------------------------------------------------------------------------------\r\n"));  
   2217                   
   2218              }
   2219          }
   2220          
   2221          /*
   2222          *********************************************************************************************************
   2223          *                                         Get_Run_Time()
   2224          *
   2225          * Description : Print run time information
   2226          *
   2227          * Argument(s) : none.
   2228          *
   2229          * Return(s)   : none.
   2230          *
   2231          * Caller(s)   : none.
   2232          *
   2233          * Note(s)     : none.
   2234          *********************************************************************************************************
   2235          */
   2236          
   2237          void Get_Run_Time( void )
   2238          {
   2239            
   2240              INT32U time   ;
   2241              INT8U  sec ;
   2242              INT8U  min ;
   2243              INT8U  hour ;
   2244              INT8U  day ;
   2245            
   2246              time = OSTime / 1000L ;
   2247              sec  = time % 60 ;
   2248              min  = time / 60 %60 ;
   2249              hour = time / 3600 % 24 ;
   2250              day  = time / 3600 / 24 ;
   2251              
   2252              APP_TRACE_INFO(("OS Running Time  =  %02d days : %02d hours : %02d min : %02d sec\r\n", day,hour,min, sec )); 
   2253             
   2254              
   2255          }
   2256          
   2257          
   2258          /*
   2259          *********************************************************************************************************
   2260          *                                         Time_Stamp()
   2261          *
   2262          * Description : Print run time stamp
   2263          *
   2264          * Argument(s) : none.
   2265          *
   2266          * Return(s)   : none.
   2267          *
   2268          * Caller(s)   : none.
   2269          *
   2270          * Note(s)     : none.
   2271          *********************************************************************************************************
   2272          */
   2273          void Time_Stamp( void )
   2274          {  
   2275              
   2276              INT32U time   ;
   2277              INT8U  sec ;
   2278              INT8U  min ;
   2279              INT8U  hour ;
   2280              INT16U  msec ;
   2281              
   2282              time = OSTime ;
   2283              msec = time % 1000L ;
   2284              time = time / 1000L ;
   2285              sec  = time % 60 ;
   2286              min  = time / 60 %60 ;
   2287              hour = time / 3600 % 24 ;
   2288              
   2289              APP_TRACE_INFO(("\r\n[%d:%02d:%02d.%03d] ", hour,min, sec, msec )); 
   2290           
   2291          }
   2292          
   2293          /*
   2294          *********************************************************************************************************
   2295          *                                         Head_Info()
   2296          *
   2297          * Description : Print Head information
   2298          *
   2299          * Argument(s) : none.
   2300          *
   2301          * Return(s)   : none.
   2302          *
   2303          * Caller(s)   : App_TaskUserIF()
   2304          *
   2305          * Note(s)     : none.
   2306          *********************************************************************************************************
   2307          */
   2308          void Head_Info ( void )
   2309          { 
   2310              FLASH_INFO flash_info;
   2311              Read_Flash_State(&flash_info);
   2312              APP_TRACE_INFO(("\r\n\r\n")); 
   2313              APP_TRACE_INFO(("-----------------------------------------------------------\r\n"));
   2314              APP_TRACE_INFO(("----                    Fortemedia                    -----\r\n"));
   2315              APP_TRACE_INFO(("----         iSAM Test Bench Audio Bridge Board       -----\r\n"));
   2316              APP_TRACE_INFO(("----   %20s-%s             -----\r\n", hw_model, fw_version));
   2317              APP_TRACE_INFO(("----   Compile date:  %12s, %8s, by PQ   -----\r\n", __DATE__, __TIME__));
   2318              APP_TRACE_INFO(("-----------------------------------------------------------\r\n"));
   2319              APP_TRACE_INFO(("\r\n"));                
   2320              //APP_TRACE_INFO(("------------------------------------------------------------------------------------------------------------------------------------\r\n"));  
   2321              APP_TRACE_INFO(("Micrium uC/OS-II on the Atmel AT91SAM7A3. Version : V%d.%d \r\n",(OSVersion()/ 100),(OSVersion() % 100)  ));
   2322              APP_TRACE_INFO(("CPU Usage = %d%%, CPU Speed = %3d MHz, Tick_Per_Second = %6d ticks/sec  \r\n", OSCPUUsage,  (BSP_CPU_ClkFreq() / 1000000L),OS_TICKS_PER_SEC ));
   2323              APP_TRACE_INFO(("#Ticks = %8d, #CtxSw = %8d \r\n", OSTime, OSCtxSwCtr )); 
   2324              Get_Run_Time();
   2325              APP_TRACE_INFO(("\r\n"));  
   2326              APP_TRACE_INFO(("-------------------------------------------------   GLOBAL VARIABLES STATUS   ------------------------------------------------------\r\n")); 
   2327              APP_TRACE_INFO(("MEM_Part_MsgUART :         %2d / %2d   of the memory partiation used\r\n", pMEM_Part_MsgUART->OSMemNBlks - pMEM_Part_MsgUART->OSMemNFree,  pMEM_Part_MsgUART->OSMemNBlks)); 
   2328              APP_TRACE_INFO(("Tx_ReSend_Happens:         %7d   times happened\r\n", Tx_ReSend_Happens ));
   2329              APP_TRACE_INFO(("Tx_ReSend_Happens_Ruler:   %7d   times happened\r\n", Tx_ReSend_Happens_Ruler ));
   2330              APP_TRACE_INFO(("TWI_Sem_lock:              %7d   ( default 1 )\r\n", TWI_Sem_lock->OSEventCnt ));   
   2331              APP_TRACE_INFO(("TWI_Sem_done:              %7d   ( default 0 )\r\n", TWI_Sem_done->OSEventCnt ));
   2332              APP_TRACE_INFO(("UART_MUX_Sem_lock:         %7d   ( default 1 )\r\n", UART_MUX_Sem_lock->OSEventCnt ));
   2333              APP_TRACE_INFO(("Done_Sem_RulerUART:        %7d   ( default 0 )\r\n", Done_Sem_RulerUART->OSEventCnt ));
   2334              APP_TRACE_INFO(("Global_Ruler_State[3..0]:        [%d - %d - %d - %d]\r\n", Global_Ruler_State[3],Global_Ruler_State[2],Global_Ruler_State[1],Global_Ruler_State[0] ));
   2335              APP_TRACE_INFO(("Global_Ruler_Type[3..0] :        [%X - %X - %X - %X]\r\n", Global_Ruler_Type[3],Global_Ruler_Type[2],Global_Ruler_Type[1],Global_Ruler_Type[0] ));
   2336              APP_TRACE_INFO(("Global_Mic_Mask[3..0][] :        [%X - %X - %X - %X]\r\n", Global_Mic_Mask[3],Global_Mic_Mask[2],Global_Mic_Mask[1],Global_Mic_Mask[0] ));
   2337              APP_TRACE_INFO(("Flash Write Cycle:       State_Page = %d cycles,  FW_Bin_Page = %d cycles\r\n", flash_info.s_w_counter,flash_info.f_w_counter ));
   2338              APP_TRACE_INFO(("Ruler FW Bin File:       \"%s\" (%d Bytes), [0x%0X, %s]\r\n", (flash_info.f_w_state == FW_DOWNLAD_STATE_FINISHED ? flash_info.bin_name : " -- "), flash_info.bin_size, flash_info.f_w_state,(flash_info.f_w_state == FW_DOWNLAD_STATE_FINISHED ? "OK" : "Error")));
   2339              APP_TRACE_INFO(("Test Counter:            test_counter1, 2, 3, 4  =  %4d,%4d,%4d,%4d\r\n",  test_counter1, test_counter2,test_counter3, test_counter4));
   2340              APP_TRACE_INFO(("Test Counter:  UART_WriteStart Failed :  %4d  times\r\n",   test_counter5));
   2341              APP_TRACE_INFO(("\r\n"));
   2342              Get_Task_Info ();
   2343              //APP_TRACE_INFO(("\r\n")); 
   2344          
   2345          }
   2346          
   2347          
   2348          
   2349          /*
   2350          *********************************************************************************************************
   2351          *                                         PDM_Pattern_Gen()
   2352          *
   2353          * Description : Debug_Send_PDM_Pattern_ for CP2240
   2354          *
   2355          * Argument(s) : none.
   2356          *
   2357          * Return(s)   : none.
   2358          *
   2359          * Caller(s)   : App_TaskUserIF()
   2360          *
   2361          * Note(s)     : none.
   2362          *********************************************************************************************************
   2363          */
   2364           
   2365          //#define PDM_DAT         0   //PA26
   2366          //#define PDM_CLK         1   //PA27
   2367          //#define PATTERN_DATA    0xD4
   2368          //#define IDLE_DATA       0xCC
   2369          //#define PATTERN_WIDTH   1 // 1bytes
   2370          //#define REPEAT_TIMES    150
   2371          //
   2372          //
   2373          //
   2374          //void __ramfunc PDM_Out( unsigned int data, unsigned int times )
   2375          //{
   2376          //   
   2377          //    unsigned int i, j ; 
   2378          //    
   2379          //    Pin PinsPDM[]   = {GPIO_PA26, GPIO_PA27}; //faster
   2380          //    
   2381          //    PinsPDM[PDM_DAT].pio->PIO_OER = PinsPDM[PDM_DAT].mask; //set pin as output
   2382          //    PinsPDM[PDM_CLK].pio->PIO_OER = PinsPDM[PDM_CLK].mask;
   2383          //    PinsPDM[PDM_DAT].pio->PIO_PPUER = PinsPDM[PDM_DAT].mask; //set pull up 
   2384          //    PinsPDM[PDM_CLK].pio->PIO_PPUER = PinsPDM[PDM_CLK].mask;
   2385          //
   2386          //    
   2387          //    PinsPDM[PDM_DAT].pio->PIO_CODR = PinsPDM[PDM_DAT].mask;
   2388          //    PinsPDM[PDM_CLK].pio->PIO_CODR = PinsPDM[PDM_CLK].mask;
   2389          //    
   2390          //    for( i = 0; i < times; i++ ) {
   2391          //    
   2392          //        for( j = 0; j < (8*PATTERN_WIDTH) ; j++)  {
   2393          //              
   2394          //              PinsPDM[PDM_CLK].pio->PIO_CODR = PinsPDM[PDM_CLK].mask;
   2395          //              if( (data<<j)&0x80 ) {              
   2396          //                 PinsPDM[PDM_DAT].pio->PIO_SODR = PinsPDM[PDM_DAT].mask;
   2397          //              } else {                 
   2398          //                 PinsPDM[PDM_DAT].pio->PIO_CODR = PinsPDM[PDM_DAT].mask;
   2399          //              }      
   2400          //              PinsPDM[PDM_CLK].pio->PIO_SODR = PinsPDM[PDM_CLK].mask;
   2401          //          
   2402          //               __asm ("NOP");
   2403          //               __asm ("NOP");
   2404          //               __asm ("NOP");
   2405          //               __asm ("NOP");
   2406          //               __asm ("NOP");
   2407          //               __asm ("NOP");
   2408          //             
   2409          //        }
   2410          //  
   2411          //    }
   2412          //    
   2413          //   PinsPDM[PDM_DAT].pio->PIO_ODR = PinsPDM[PDM_DAT].mask; //set pin  as input
   2414          //   PinsPDM[PDM_CLK].pio->PIO_ODR = PinsPDM[PDM_CLK].mask;
   2415          //   PinsPDM[PDM_DAT].pio->PIO_PPUDR = PinsPDM[PDM_DAT].mask; //disable pull up 
   2416          //   PinsPDM[PDM_CLK].pio->PIO_PPUDR = PinsPDM[PDM_CLK].mask;
   2417          //   
   2418          //}
   2419          //
   2420          //
   2421          //void   PDM_Pattern_Gen( INT8U type )
   2422          //{
   2423          //       
   2424          //#if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
   2425          //    OS_CPU_SR  cpu_sr = 0u;
   2426          //#endif
   2427          //    
   2428          //  
   2429          //    OS_ENTER_CRITICAL();
   2430          //    
   2431          //    if( type == 0 ) {
   2432          //        PDM_Out(PATTERN_DATA, REPEAT_TIMES);
   2433          //    } else {
   2434          //        PDM_Out(IDLE_DATA, 0xFFFFFFFF );
   2435          //    }
   2436          //  
   2437          //    OS_EXIT_CRITICAL();
   2438          //  
   2439          //}

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   BSP_CPU_ClkFreq
        16   -> BSP_PLL_GetFreq
        16   -> __aeabi_uidiv
       8   BSP_CPU_Init
         8   -> BSP_MainOscEn
         8   -> BSP_MclkCfg
         8   -> BSP_PLL_Cfg
       8   BSP_DummyISR_Handler
         8   -> BSP_IntClr
       8   BSP_Init
         8   -> BSP_IntInit
         8   -> BSP_ResetInit
         8   -> BSP_Tmr_TickInit
         8   -> FLASHD_Initialize
         8   -> GPIO_Init
         8   -> TWI_Init
         8   -> Timer_Init
         8   -> UART_Init
       0   BSP_IntClr
       0   BSP_IntDis
       0   BSP_IntDisAll
       0   BSP_IntEn
       8   BSP_IntInit
         8   -> BSP_IntVectSet
       8   BSP_IntVectSet
       0   BSP_MainOscDis
       0   BSP_MainOscEn
      16   BSP_MainOscGetFreq
        16   -> __aeabi_idiv
       0   BSP_MclkCfg
      24   BSP_MclkGetFreq
        24   -> BSP_PLL_GetFreq
        24   -> __aeabi_uidiv
       8   BSP_PLL_Cfg
      16   BSP_PLL_GetFreq
        16   -> __aeabi_idiv
       0   BSP_PclkCfg
       0   BSP_PclkDis
       0   BSP_PclkEn
      24   BSP_PclkGetFreq
        24   -> BSP_MainOscGetFreq
        24   -> BSP_PLL_GetFreq
        24   -> __aeabi_uidiv
       0   BSP_PerClkDis
       0   BSP_PerClkEn
       0   BSP_PerClkGetStatus
       0   BSP_ResetInit
      16   BSP_Ser_Init
        16   -> BSP_CPU_ClkFreq
        16   -> __aeabi_uidiv
      24   BSP_Ser_Printf
        24   -> BSP_Ser_WrStr
        24   -> vsprintf
      16   BSP_Ser_RdByte
        16   -> OSSemPend
        16   -> OSSemPost
        16   -> OSTimeDly
      24   BSP_Ser_RdStr
        24   -> BSP_Ser_Printf
        24   -> BSP_Ser_RdByte
      16   BSP_Ser_WrByte
        16   -> OSSemPend
        16   -> OSSemPost
       8   BSP_Ser_WrStr
         8   -> BSP_Ser_WrByte
       8   BSP_Sys_ISR_Handler
         8   -> BSP_IntClr
         8   -> BSP_Tmr_TickISR_Handler
       8   BSP_Tmr_TickISR_Handler
         8   -> OSTimeTick
      16   BSP_Tmr_TickInit
        16   -> BSP_IntClr
        16   -> BSP_IntEn
        16   -> BSP_IntVectSet
        16   -> BSP_MclkGetFreq
        16   -> __aeabi_uidiv
       0   BSP_USBclkCfg
       0   BSP_USBclkDis
       0   BSP_USBclkEn
      16   BSP_USBclkGetFreq
        16   -> BSP_PLL_GetFreq
        16   -> __aeabi_uidiv
      16   Beep
        16   -> LED_Clear
        16   -> LED_Set
        16   -> OSTimeDly
        16   -> PIO_Clear
        16   -> PIO_Set
      32   Get_Run_Time
        32   -> BSP_Ser_Printf
        32   -> __aeabi_uidiv
        32   -> __aeabi_uidivmod
      16   Get_Task_Info
        16   -> BSP_Ser_Printf
        16   -> get_os_state
      64   Head_Info
        64   -> BSP_CPU_ClkFreq
        64   -> BSP_Ser_Printf
        64   -> Get_Run_Time
        64   -> Get_Task_Info
        64   -> OSVersion
        64   -> Read_Flash_State
        64   -> __aeabi_idiv
        64   -> __aeabi_idivmod
        64   -> __aeabi_uidiv
       0   LowLevelInitPLL
      16   OS_CPU_ExceptHndlr
        16   -- Indirect call
      32   Time_Stamp
        32   -> BSP_Ser_Printf
        32   -> __aeabi_uidiv
        32   -> __aeabi_uidivmod
       0   get_os_state


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "      %2d ">
       8  ?<Constant "   %s  ">
       8  ?<Constant "  %10d ">
       2  ?<Constant " ">
       8  ?<Constant " %08X ">
      12  ?<Constant " %22.22s ">
       8  ?<Constant " %4d ">
       8  ?<Constant " %5d ">
       8  ?<Constant " -- ">
       8  ?<Constant " |\r\n">
      32  ?<Constant "#Ticks = %8d, #CtxSw ...">
       8  ?<Constant "%13.13s">
       4  ?<Constant "%c">
      64  ?<Constant "----                 ...">
      64  ?<Constant "----         iSAM Tes...">
      36  ?<Constant "----   %20s-%s       ...">
      52  ?<Constant "----   Compile date: ...">
     136  ?<Constant "---------------------...">
     136  ?<Constant "---------------------...">_1
      64  ?<Constant "---------------------...">_2
     136  ?<Constant "---------------------...">_3
      12  ?<Constant "16:45:15">
      76  ?<Constant "CPU Usage = %d%%, CPU...">
      52  ?<Constant "Done_Sem_RulerUART:  ...">
       8  ?<Constant "Error">
      76  ?<Constant "Flash Write Cycle:   ...">
      56  ?<Constant "Global_Mic_Mask[3..0]...">
      56  ?<Constant "Global_Ruler_State[3....">
      56  ?<Constant "Global_Ruler_Type[3.....">
      12  ?<Constant "Jun 21 2016">
      72  ?<Constant "MEM_Part_MsgUART :   ...">
      64  ?<Constant "Micrium uC/OS-II on t...">
       4  ?<Constant "OK">
      68  ?<Constant "OS Running Time  =  %...">
      56  ?<Constant "Ruler FW Bin File:   ...">
      52  ?<Constant "TWI_Sem_done:        ...">
      52  ?<Constant "TWI_Sem_lock:        ...">
      72  ?<Constant "Test Counter:        ...">
      56  ?<Constant "Test Counter:  UART_W...">
      52  ?<Constant "Tx_ReSend_Happens:   ...">
      52  ?<Constant "Tx_ReSend_Happens_Rul...">
      52  ?<Constant "UART_MUX_Sem_lock:   ...">
       4  ?<Constant "\b \b">
       2  ?<Constant "\n">
       4  ?<Constant "\r\n">
      24  ?<Constant "\r\n[%d:%02d:%02d.%03d] ">
       8  ?<Constant "\r\n\r\n">
     136  ?<Constant "| ID  |    Name    | ...">
       8  ?<Constant "|%2d ">
     136  ?<Constant "|--------------------...">
       4  ??DataTable10
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_22
       4  ??DataTable13_23
       4  ??DataTable13_24
       4  ??DataTable13_25
       4  ??DataTable13_26
       4  ??DataTable13_27
       4  ??DataTable13_28
       4  ??DataTable13_29
       4  ??DataTable13_3
       4  ??DataTable13_30
       4  ??DataTable13_31
       4  ??DataTable13_32
       4  ??DataTable13_33
       4  ??DataTable13_34
       4  ??DataTable13_35
       4  ??DataTable13_36
       4  ??DataTable13_37
       4  ??DataTable13_38
       4  ??DataTable13_39
       4  ??DataTable13_4
       4  ??DataTable13_40
       4  ??DataTable13_41
       4  ??DataTable13_42
       4  ??DataTable13_43
       4  ??DataTable13_44
       4  ??DataTable13_45
       4  ??DataTable13_46
       4  ??DataTable13_47
       4  ??DataTable13_48
       4  ??DataTable13_49
       4  ??DataTable13_5
       4  ??DataTable13_50
       4  ??DataTable13_51
       4  ??DataTable13_52
       4  ??DataTable13_53
       4  ??DataTable13_54
       4  ??DataTable13_55
       4  ??DataTable13_56
       4  ??DataTable13_57
       4  ??DataTable13_58
       4  ??DataTable13_59
       4  ??DataTable13_6
       4  ??DataTable13_60
       4  ??DataTable13_61
       4  ??DataTable13_62
       4  ??DataTable13_63
       4  ??DataTable13_64
       4  ??DataTable13_65
       4  ??DataTable13_66
       4  ??DataTable13_67
       4  ??DataTable13_68
       4  ??DataTable13_69
       4  ??DataTable13_7
       4  ??DataTable13_70
       4  ??DataTable13_71
       4  ??DataTable13_72
       4  ??DataTable13_73
       4  ??DataTable13_74
       4  ??DataTable13_75
       4  ??DataTable13_76
       4  ??DataTable13_77
       4  ??DataTable13_78
       4  ??DataTable13_79
       4  ??DataTable13_8
       4  ??DataTable13_80
       4  ??DataTable13_81
       4  ??DataTable13_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable6
       4  ??DataTable9
       4  ??DataTable9_1
     164  BSP_CPU_ClkFreq
      72  BSP_CPU_Init
      60  BSP_DummyISR_Handler
     132  BSP_Init
      40  BSP_IntClr
      40  BSP_IntDis
      20  BSP_IntDisAll
      40  BSP_IntEn
     188  BSP_IntInit
     196  BSP_IntVectSet
      32  BSP_MainOscDis
     104  BSP_MainOscEn
     128  BSP_MainOscGetFreq
     196  BSP_MclkCfg
     172  BSP_MclkGetFreq
     232  BSP_PLL_Cfg
     120  BSP_PLL_GetFreq
     128  BSP_PclkCfg
      40  BSP_PclkDis
      40  BSP_PclkEn
     204  BSP_PclkGetFreq
      72  BSP_PerClkDis
      72  BSP_PerClkEn
     124  BSP_PerClkGetStatus
      36  BSP_ResetInit
     384  BSP_Ser_Init
      56  BSP_Ser_Printf
     180  BSP_Ser_RdByte
     276  BSP_Ser_RdStr
     160  BSP_Ser_WrByte
      44  BSP_Ser_WrStr
     100  BSP_Sys_ISR_Handler
      32  BSP_Tmr_TickISR_Handler
      92  BSP_Tmr_TickInit
      84  BSP_USBclkCfg
      20  BSP_USBclkDis
      20  BSP_USBclkEn
      72  BSP_USBclkGetFreq
     104  Beep
       4  Bsp_Ser_Rx_Sem_lock
       4  Bsp_Ser_Tx_Sem_lock
       1  Debug_COM_Sel
       1  Flag_Reset_Pin_Trigger
     168  Get_Run_Time
     320  Get_Task_Info
     752  Head_Info
     196  LowLevelInitPLL
     220  OS_CPU_ExceptHndlr
      12  PinBuzzer
     172  Time_Stamp
      84  buffer
      12  fw_version
     100  get_os_state
       8  hw_model
      12  hw_version
      56  os_stat_desp

 
    94 bytes in section .bss
    12 bytes in section .data
 2 280 bytes in section .rodata
 6 560 bytes in section .text
 
 6 560 bytes of CODE  memory
 2 280 bytes of CONST memory
   106 bytes of DATA  memory

Errors: none
Warnings: 4
