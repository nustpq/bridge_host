###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Dec/2014  15:00:44
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\task_user_if.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\task_user_if.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\FLASH\List\task_user_if.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\FLASH\Obj\task_user_if.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\task_user_if.c
      1          /*
      2          *********************************************************************************************************
      3          *                               iSAM TEST BENCH AUDIO BRIDGE BOARD APP PACKAGE
      4          *
      5          *                            (c) Copyright 2013 - 2016; Fortemedia Inc.; Nanjing, China
      6          *
      7          *                   All rights reserved.  Protected by international copyright laws.
      8          *                   Knowledge of the source code may not be used to write a similar
      9          *                   product.  This file may only be used in accordance with a license
     10          *                   and should not be redistributed in any way.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                           TASK PACKAGE
     18          *
     19          *                                          Atmel AT91SAM7A3
     20          *                                               on the
     21          *                                      iSAM Audio Bridge Board
     22          *
     23          * Filename      : task_user_if.c
     24          * Version       : V1.0.0
     25          * Programmer(s) : PQ
     26          *********************************************************************************************************
     27          * Note(s)       :
     28          *********************************************************************************************************
     29          */
     30          
     31          
     32          #include <includes.h>
     33          
     34          
     35          OS_EVENT  *App_UserIF_Mbox; 
     36          
     37          
     38          /*
     39          *********************************************************************************************************
     40          *                                         App_TaskUserIF()
     41          *
     42          * Description : Do related process after state change of the reset button, switches and ruler port connection. 
     43          *               Wait for messages from 'App_TaskJoy()' if state change happened.
     44          *
     45          * Argument(s) : p_arg       Argument passed to 'App_TaskUserIF()' by 'OSTaskCreate()'.
     46          *
     47          * Return(s)   : none.
     48          *
     49          * Note(s)     : (1) The first line of code is used to prevent a compiler warning because 'p_arg' is not
     50          *                   used.  The compiler should not generate any code for this statement.
     51          *********************************************************************************************************
     52          */
     53          
     54          static bool port_enable = true;
     55          
     56          void  App_TaskUserIF (void *p_arg)
     57          {
     58            
     59              CPU_INT32U  *msg;
     60              CPU_INT08U   err;
     61              CPU_INT32U   key_state; 
     62              CPU_INT08U   ruler_id;
     63          
     64              (void)p_arg;    
     65              
     66              OSTimeDly(500); //wait for other tasks be ready , and time for power stable for ruler  
     67              Head_Info(); //Send header 
     68              Ruler_Power_Switch(1);
     69              Init_Global_Var();    
     70              AB_POST();
     71              
     72          #ifndef BOARD_TYPE_AB01  
     73              APP_TRACE_INFO_T(("WARNING: NOT AB01, NO MCU CRT UART SWITCH\r\n"));
     74          #endif
     75             
     76              while ( DEF_TRUE ) {                                          /* Task body, always written as an infinite loop.           */   
     77                         
     78                  msg = (CPU_INT32U *)(OSMboxPend(App_UserIF_Mbox, 0, &err)); //pending, no timeout       
     79                  if (msg != NULL) {          
     80                      key_state = *msg ;
     81                      APP_TRACE_INFO(("\r\n"));             
     82                      switch( key_state & MSG_TYPE_MASK ) {                
     83                          case MSG_TYPE_RESET : //reset send msg                
     84                              //PDM_Pattern_Gen(0); //gen cp2240 pattern
     85                              Head_Info();                                   
     86                          break;
     87                              
     88                          case MSG_TYPE_SWITCH ://Switch                
     89                              APP_TRACE_INFO_T(("Switch status updated:  SW[1..0] = [%d, %d]\r\n",\
     90                                               (key_state>>0)&(0x01),(key_state>>1)&(0x01) )); 
     91                              /**********************************************************************/
     92                              //To do something to do with Switch selection...                    
     93                              // Switch 'SW0' used to control DEBUG port:
     94                              //         0: ON :  UART1 used as debug port
     95                              //         1: OFF:  DBG UART used as debug port
     96                              if( (key_state>>(8 + 1)) & 0x01) {  //check if SW0 switch status changed  
     97                                  OSTaskDel( APP_CFG_TASK_SHELL_PRIO ); 
     98                                  OSSemSet (Bsp_Ser_Tx_Sem_lock, 1,  &err) ;
     99                                  OSSemSet (Bsp_Ser_Rx_Sem_lock, 1,  &err) ;
    100                                  Task_ReCreate_Shell();  
    101                                  if( ((key_state>>1)& 0x01 ) == 0 ) { //debug to UART1  
    102                                      Debug_COM_Sel = 1 ;
    103                                      BSP_Ser_Init(115200);  
    104                                  } else {                             //debug to DBG_UART                      
    105                                      Debug_COM_Sel = 0 ;               
    106                                      UART_Init(PC_UART, ISR_PC_UART, 115200 );    //To PC  ? Sem recreat issue
    107                                  }
    108                              } 
    109          //                    // Switch 'SW1' used to control Buzzer mute:
    110          //                    //         0: ON :  Buzzer muted
    111          //                    //         1: OFF:  Buzzer unmuted
    112          //                    if( (key_state>>(8 + 0)) & 0x01) {  //check if SW1 switch status changed                         
    113          //                        if( ((key_state>>0)& 0x01 ) == 0 ) { 
    114          //                            BUZZER_MUTE =  1;   //mute buzzer                         
    115          //                        } else {                                                 
    116          //                            BUZZER_MUTE =  0;   //unmute buzzer
    117          //                        }
    118          //                    } 
    119                                // Switch 'SW1' used to control CODEC LOUT PGA Gain:
    120                                //         0: ON :  24dB attenuated signal for Phone MIC input
    121                                //         1: OFF:  Normal signal for ACQUA
    122                                if( (key_state>>(8 + 0)) & 0x01) {  //check if SW1 switch status changed                         
    123                                    if( ((key_state>>0)& 0x01 ) == 0 ) {                                
    124                                        err = CODEC_LOUT_Small_Gain_En( true ) ;  //enable 24dB attenuated signal for Phone Mic                                               
    125                                    } else {                                                 
    126                                        err = CODEC_LOUT_Small_Gain_En( false ) ; //normal signal, no attenuation                              
    127                                    }
    128                                    if( OS_ERR_NONE != err ) {
    129                                        APP_TRACE_INFO_T(("ERR: Set CODEC_LOUT_Small_Gain_En err! [%d]\r\n",err));
    130                                    }
    131                                } 
    132                          break;
    133                          
    134                          case MSG_TYPE_PORT_DET :   
    135                              if( port_enable == false ) { 
    136                                  //APP_TRACE_INFO(("Ruler port disabled !\r\n"));
    137                                  break; 
    138                              }
    139                              APP_TRACE_INFO_T(("Ruler port status changed:  Port[3..0] = [%1d%1d%1d%1d] ",\
    140                                              (key_state>>0)&(0x01),(key_state>>1)&(0x01),(key_state>>2)&(0x01),(key_state>>3)&(0x01) )); 
    141                              
    142                              for( ruler_id = 0 ; ruler_id < 4 ; ruler_id++ ) {   
    143                                  if( (key_state>>( 8 + 3 - ruler_id)) & 0x01) {  //check if Ruler Port[0] switch status changed                            
    144                                      if( ( (key_state>>(3 - ruler_id)) & 0x01 ) == 0 ) { // ruler attached, setup ruler                              
    145                                          //LED_Set( LED_P0 + ruler_id );
    146                                          APP_TRACE_INFO_T(("Ruler[%d] Attached.\r\n", ruler_id ));                            
    147                                          Global_Ruler_State[ruler_id] = RULER_STATE_ATTACHED; 
    148                                          err = Init_Ruler( ruler_id ); 
    149                                          if( OS_ERR_NONE != err ) {
    150                                              //LED_Clear( LED_P0 + ruler_id );
    151                                              continue;
    152                                          }                         
    153                                          err = Setup_Ruler( ruler_id ); 
    154                                          if( OS_ERR_NONE != err ) {
    155                                              //LED_Clear( LED_P0 + ruler_id );
    156                                              continue;
    157                                          }
    158          ////                                err = Ruler_Setup_Sync(  ruler_id );
    159          ////                                if( OS_ERR_NONE != err ) {
    160          ////                                    //LED_Clear( LED_P0 + ruler_id );
    161          ////                                    continue;
    162          ////                                }                                
    163                                          err = Get_Ruler_Type( ruler_id ); 
    164                                          if( OS_ERR_NONE != err ) {
    165                                              //LED_Clear( LED_P0 + ruler_id );
    166                                              continue;
    167                                          }
    168                                          err = Get_Ruler_Version( ruler_id ); 
    169                                          if( OS_ERR_NONE != err ) {
    170                                              //LED_Clear( LED_P0 + ruler_id );
    171                                              continue;
    172                                          }                                  
    173                                          err = Ruler_POST( ruler_id ); 
    174                                          if( OS_ERR_NONE != err ) {
    175                                              //LED_Clear( LED_P0 + ruler_id );
    176                                              continue;
    177                                          }                     
    178                                          Global_Ruler_State[ruler_id] = RULER_STATE_CONFIGURED ;                              
    179          //                                mic_mask = Global_Mic_Mask[ruler_id];
    180          //                                err = Update_Mic_Mask( ruler_id, mic_mask );
    181          //                                if( OS_ERR_NONE != err ) {                              
    182          //                                    continue;
    183          //                                }   
    184          //                                if( mic_mask ) {
    185          //                                    Global_Ruler_State[ruler_id]= RULER_STATE_SELECTED;                                   
    186          //                                } 
    187                                          //OSTimeDly(500);
    188                                          //simple_test_use();//test for Dr.Yang and use USBApp0815.exe
    189                                                                                     
    190                                      } else { // ruler detached
    191                                          //LED_Clear( LED_P0 + ruler_id );
    192                                          APP_TRACE_INFO_T(("Ruler[%d] Detached.\r\n", ruler_id )); 
    193                                          Global_Ruler_State[ruler_id] = RULER_STATE_DETACHED ;
    194                                          Global_Ruler_Type[ruler_id]  = 0 ;
    195                                          Global_Mic_Mask[ruler_id]    = 0 ; 
    196                                      } 
    197                          
    198          
    199                                  }                              
    200                          }                    
    201                          break;  
    202                      }  
    203                      Buzzer_OnOff(1); //buzzer on   
    204                      OSTimeDly(10);  
    205                      Buzzer_OnOff(0); //buzzer off
    206                      OSTimeDly(30);
    207                      Buzzer_OnOff(1); //buzzer on   
    208                      OSTimeDly(10);  
    209                      Buzzer_OnOff(0); //buzzer off 
    210                  }
    211              }
    212          }
    213          
    214          
    215          /*******************************************************************************
    216          Control ruler port detection response
    217          in case of update FW requirement
    218          *******************************************************************************/
    219          void Port_Detect_Enable( unsigned char on_off )
    220          {
    221              
    222              if( on_off == 0 ) {
    223                  port_enable = false;
    224              
    225              } else {
    226                  port_enable = true;
    227              
    228              }
    229              
    230          }
    231          
    232          
    233              

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   App_TaskUserIF
        32   -> AB_POST
        32   -> BSP_Ser_Init
        32   -> BSP_Ser_Printf
        32   -> Buzzer_OnOff
        32   -> CODEC_LOUT_Small_Gain_En
        32   -> Get_Ruler_Type
        32   -> Get_Ruler_Version
        32   -> Head_Info
        32   -> Init_Global_Var
        32   -> Init_Ruler
        32   -> OSMboxPend
        32   -> OSSemSet
        32   -> OSTaskDel
        32   -> OSTimeDly
        32   -> Ruler_POST
        32   -> Ruler_Power_Switch
        32   -> Setup_Ruler
        32   -> Task_ReCreate_Shell
        32   -> Time_Stamp
        32   -> UART_Init
       0   Port_Detect_Enable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      48  ?<Constant "ERR: Set CODEC_LOUT_S...">
      60  ?<Constant "Ruler port status cha...">
      24  ?<Constant "Ruler[%d] Attached.\r\n">
      24  ?<Constant "Ruler[%d] Detached.\r\n">
      48  ?<Constant "Switch status updated...">
      44  ?<Constant "WARNING: NOT AB01, NO...">
       4  ?<Constant "\r\n">
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_12
       4  ??DataTable1_13
       4  ??DataTable1_14
       4  ??DataTable1_15
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
     852  App_TaskUserIF
       4  App_UserIF_Mbox
      48  Port_Detect_Enable
       1  port_enable

 
   4 bytes in section .bss
   1 byte  in section .data
 252 bytes in section .rodata
 964 bytes in section .text
 
 964 bytes of CODE  memory
 252 bytes of CONST memory
   5 bytes of DATA  memory

Errors: none
Warnings: none
