###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        22/May/2014  14:14:58
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\uart.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\uart.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\uart.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\uart.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\uart.c
      1          /*
      2          *********************************************************************************************************
      3          *                               iSAM TEST BENCH AUDIO BRIDGE BOARD APP PACKAGE
      4          *
      5          *                            (c) Copyright 2013 - 2016; Fortemedia Inc.; Nanjing, China
      6          *
      7          *                   All rights reserved.  Protected by international copyright laws.
      8          *                   Knowledge of the source code may not be used to write a similar
      9          *                   product.  This file may only be used in accordance with a license
     10          *                   and should not be redistributed in any way.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                           DRIVER PACKAGE
     18          *
     19          *                                          Atmel AT91SAM7A3
     20          *                                               on the
     21          *                                      iSAM Audio Bridge Board
     22          *
     23          * Filename      : uart.c
     24          * Version       : V1.0.0
     25          * Programmer(s) : PQ
     26          *********************************************************************************************************
     27          * Note(s)       :
     28          *********************************************************************************************************
     29          */
     30          
     31          #include <bsp.h>
     32          #include <string.h>
     33          #include <pio.h>
     34          #include <taskcomm.h>
     35          #include "uart.h"
     36          
     37          
     38          
     39          OS_EVENT *DBGU_Tx_Sem_lock;  
     40          OS_EVENT *DBGU_Rx_Sem_lock;
     41          
     42          /*
     43          *********************************************************************************************************
     44                                            UART Related Buffer Defines 
     45          *********************************************************************************************************
     46          */
     47          
     48          #if ( UART0_EN > 0 )
     49          CPU_INT32U UART0_Send_Buf[UART0_SEND_QUEUE_LENGTH/sizeof(CPU_INT32U)];
     50          CPU_INT32U UART0_Rece_Buf[UART0_RECE_QUEUE_LENGTH/sizeof(CPU_INT32U)];
     51          CPU_INT08U UART0_Send_Buf_PDC[UART_PDC_LENGTH];
     52          CPU_INT08U UART0_Rece_Buf_PDC[UART_PDC_LENGTH];
     53          #endif
     54          
     55          #if ( UART1_EN > 0 )
     56          CPU_INT32U UART1_Send_Buf[UART1_SEND_QUEUE_LENGTH/sizeof(CPU_INT32U)];
     57          CPU_INT32U UART1_Rece_Buf[UART1_RECE_QUEUE_LENGTH/sizeof(CPU_INT32U)];
     58          CPU_INT08U UART1_Send_Buf_PDC[UART_PDC_LENGTH];
     59          CPU_INT08U UART1_Rece_Buf_PDC[UART_PDC_LENGTH];
     60          #endif
     61          
     62          #if ( UART2_EN > 0 )
     63          CPU_INT32U UART2_Send_Buf[UART2_SEND_QUEUE_LENGTH/sizeof(CPU_INT32U)];
     64          CPU_INT32U UART2_Rece_Buf[UART2_RECE_QUEUE_LENGTH/sizeof(CPU_INT32U)];
     65          CPU_INT08U UART2_Send_Buf_PDC[UART_PDC_LENGTH];
     66          CPU_INT08U UART2_Rece_Buf_PDC[UART_PDC_LENGTH];
     67          #endif
     68          
     69          
     70          
     71          static  OS_EVENT *USART_Sem[3];
     72          
     73          
     74          
     75          static const AT91PS_USART  pUARTREG[] =
     76          {
     77               AT91C_BASE_US0,    // USART0 REGS base addr
     78               AT91C_BASE_US1,    // USART1 REGS base addr
     79               AT91C_BASE_US2     // USART2 REGS base addr
     80          
     81          };
     82          static const Pin UART_PINS[] =
     83          {
     84                PINS_USART0,
     85                PINS_USART1,
     86                PINS_USART2  
     87          };
     88          static const CPU_INT08U UART_PID[]=
     89          {  
     90                AT91C_ID_US0,
     91                AT91C_ID_US1,
     92                AT91C_ID_US2
     93          };
     94          
     95          
     96          
     97          CPU_INT32U * const pUART_Send_Buf[]=
     98          {  
     99                (CPU_INT32U *)UART0_Send_Buf,
    100                (CPU_INT32U *)UART1_Send_Buf,
    101                (CPU_INT32U *)UART2_Send_Buf
    102          };
    103          
    104          CPU_INT32U * const pUART_Rece_Buf[]=
    105          {  
    106                (CPU_INT32U *)UART0_Rece_Buf,
    107                (CPU_INT32U *)UART1_Rece_Buf,
    108                (CPU_INT32U *)UART2_Rece_Buf
    109          };
    110          
    111          CPU_INT08U * const pUART_Send_Buf_PDC[]=
    112          {  
    113                (CPU_INT08U *)UART0_Send_Buf_PDC,
    114                (CPU_INT08U *)UART1_Send_Buf_PDC,
    115                (CPU_INT08U *)UART2_Send_Buf_PDC
    116          };
    117          
    118          CPU_INT08U * const pUART_Rece_Buf_PDC[]=
    119          {  
    120                (CPU_INT08U *)UART0_Rece_Buf_PDC,
    121                (CPU_INT08U *)UART1_Rece_Buf_PDC,
    122                (CPU_INT08U *)UART2_Rece_Buf_PDC
    123          };
    124          
    125          
    126          static const CPU_INT32U UART_Send_Buf_Size[]=
    127          {  
    128                sizeof(UART0_Send_Buf),
    129                sizeof(UART1_Send_Buf),
    130                sizeof(UART2_Send_Buf)
    131          };
    132          
    133          static const CPU_INT32U UART_Rece_Buf_Size[]=
    134          {  
    135                sizeof(UART0_Rece_Buf),
    136                sizeof(UART1_Rece_Buf),
    137                sizeof(UART2_Rece_Buf)
    138          };
    139          
    140          
    141          
    142          /*
    143          *********************************************************************************************************
    144          *                                    UART_Init()
    145          *
    146          * Description : Initialize UART related setting and int isr    .
    147          *
    148          * Argument(s) : uart_index : 0 ~ 3  
    149          *               isr_handler : uart int isr
    150          *               baud: uart baud rate speed
    151          *             
    152          * Return(s)   : error: =0 is no orror
    153          *
    154          * Note(s)     : 
    155          *
    156          *********************************************************************************************************
    157          */
    158          CPU_INT08U UART_Init( CPU_INT08U uart_index,void (*isr_handler)( void ),CPU_INT32U baud )
    159          {
    160            
    161              CPU_INT08U error ;     
    162              error    =  0    ;        
    163               
    164              if( uart_index < 3 ) { //for USART0  USART1  USART2  
    165                
    166                  PIO_Configure( &UART_PINS[uart_index], PIO_LISTSIZE(UART_PINS[uart_index]) );
    167                  
    168                  USART_Configure(   pUARTREG[uart_index], USART_MODE_ASYNCHRONOUS, baud,  MCK  ); 
    169                   
    170                  AT91C_BASE_PMC->PMC_PCER      = 1 << UART_PID[uart_index];
    171                  pUARTREG[uart_index]->US_IDR  = 0xFFFFFFFF;           
    172                  pUARTREG[uart_index]->US_CR   = AT91C_US_STTTO;
    173                  pUARTREG[uart_index]->US_RTOR = UART_TIMEOUT_BIT;   
    174                  pUARTREG[uart_index]->US_TCR  = 0;
    175                  pUARTREG[uart_index]->US_RCR  = 0;
    176                  
    177                  if ( isr_handler == NULL ) {
    178                    OSSemDel ( USART_Sem[uart_index], OS_DEL_ALWAYS,  &error ) ;          
    179                    USART_Sem[uart_index] = OSSemCreate(1); 
    180                    
    181                  } else {  //if ISR used          
    182                      pUARTREG[uart_index]->US_RPR  = (unsigned int)pUART_Rece_Buf_PDC[uart_index];
    183                      pUARTREG[uart_index]->US_RCR  = UART_PDC_LENGTH;
    184                      pUARTREG[uart_index]->US_PTCR = AT91C_PDC_RXTEN;        
    185                       
    186                      BSP_IntVectSet((CPU_INT08U   )UART_PID[uart_index],
    187                                     (CPU_INT08U   )AT91C_AIC_PRIOR_LOWEST,
    188                                     (CPU_INT08U   )BSP_INT_SCR_TYPE_INT_HIGH_LEVEL_SENSITIVE,
    189                                     (CPU_FNCT_VOID)isr_handler);        
    190                      BSP_IntClr(UART_PID[uart_index]);  
    191                      BSP_IntEn(UART_PID[uart_index]);                            
    192                      pUARTREG[uart_index]->US_IER = AT91C_US_ENDRX | AT91C_US_TIMEOUT;       
    193                     
    194                  }	        
    195                  USART_SetTransmitterEnabled( pUARTREG[uart_index], 1 );         
    196                  USART_SetReceiverEnabled(    pUARTREG[uart_index], 1 );	
    197                  
    198                  ////////////////////////////////////////////////////////////////////////    
    199                  if (Queue_Create((void *)pUART_Send_Buf[uart_index], UART_Send_Buf_Size[uart_index] ) == QUEUE_FAIL) {
    200                        error++;
    201                        
    202                  }
    203                  if (Queue_Create((void *)pUART_Rece_Buf[uart_index], UART_Rece_Buf_Size[uart_index] ) == QUEUE_FAIL)  {
    204                        error++;
    205                  }
    206                   
    207              } else {// for DBG_USART
    208               
    209                  DBGU_Configure( baud, MCK);         
    210                  OSSemSet (DBGU_Rx_Sem_lock, 1,  &error) ;
    211                  OSSemSet (DBGU_Tx_Sem_lock, 1,  &error) ;
    212              }
    213                
    214              return error ;
    215              
    216          } 
    217          
    218          
    219          
    220          /*
    221          *********************************************************************************************************
    222          *                                    UART_WriteStart()
    223          *
    224          * Description : Copy data from queue pUART_Send_Buf to pUART_Send_Buf_PDC and start UART PDC, if PDC is 
    225          *               not working and there is some data in the queue.
    226          *
    227          * Argument(s) : uart_index : 0 ~ 3  
    228          *             
    229          * Return(s)   : error: =0 is no orror
    230          *                      =1 is no data in queue
    231          *
    232          * Note(s)     : Just check queue and start PDC sending
    233          *
    234          *********************************************************************************************************
    235          */
    236          CPU_INT08U UART_WriteStart( CPU_INT08U uart_index )
    237          {
    238              CPU_INT16U byte_send ;
    239              CPU_INT08U error;
    240              
    241          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register   */
    242              OS_CPU_SR  cpu_sr = 0u;
    243          #endif
    244              
    245              error = 0;
    246              
    247              OS_ENTER_CRITICAL();      
    248              
    249              if ((pUARTREG[uart_index]->US_TCR == 0) && (pUARTREG[uart_index]->US_TNCR == 0)) {
    250                
    251                  if( Queue_ReadBuf(  pUART_Send_Buf_PDC[uart_index], 
    252                                      pUART_Send_Buf[uart_index], 
    253                                      UART_PDC_LENGTH, 
    254                                      &byte_send) == QUEUE_OK ) {  
    255                                      
    256                      pUARTREG[uart_index]->US_TPR      =  (unsigned int) pUART_Send_Buf_PDC[uart_index];
    257                      pUARTREG[uart_index]->US_TCR      =  byte_send;                  
    258                      pUARTREG[uart_index]->US_PTCR     =  AT91C_PDC_TXTEN ; //start PDC
    259                      pUARTREG[uart_index]->US_IER      =  AT91C_US_ENDTX  ; //enable PDC tx INT
    260                      
    261                  } else {
    262                      error = 1;  
    263                      test_counter5++;            
    264                  } 
    265              }
    266              
    267              OS_EXIT_CRITICAL();
    268              
    269              return error;
    270          }
    271          
    272          
    273          /*
    274          *********************************************************************************************************
    275          *                                    UART_Write()
    276          *
    277          * Description : Add data to queue. and copy data from queue pUART_Send_Buf to pUART_Send_Buf_PDC and 
    278          *               start UART PDC, if PDC is not working and there is some data in the queue.
    279          *
    280          * Argument(s) : uart_index : 0 ~ 3  
    281          *               data : byte need to be added to uart send queue  
    282          *  
    283          * Return(s)   : error: =0 is no orror
    284          *                      =1 is no data in queue
    285          *                      =2 is no data in queue
    286          *
    287          * Note(s)     : 
    288          *
    289          *********************************************************************************************************
    290          */
    291          CPU_INT08U UART_Write(CPU_INT08U uart_index,  CPU_INT08U data )
    292          {
    293              CPU_INT16U byte_send;
    294              CPU_INT08U error;
    295              
    296          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register           */
    297              OS_CPU_SR  cpu_sr = 0u;
    298          #endif
    299              
    300              error = 0;
    301              
    302              OS_ENTER_CRITICAL();
    303              
    304              if( Queue_Write((void *)pUART_Send_Buf[uart_index], data) != QUEUE_OK ) {  /* 数据入队 */
    305                  error = 1 ; //?
    306              }      
    307              
    308              if ((pUARTREG[uart_index]->US_TCR == 0) && (pUARTREG[uart_index]->US_TNCR == 0)) {      
    309                  if( Queue_ReadBuf(  pUART_Send_Buf_PDC[uart_index], 
    310                                      pUART_Send_Buf[uart_index], 
    311                                      UART_PDC_LENGTH, 
    312                                      &byte_send) == QUEUE_OK ) {       
    313                      pUARTREG[uart_index]->US_TPR      =  (unsigned int) pUART_Send_Buf_PDC[uart_index];
    314                      pUARTREG[uart_index]->US_TCR      =  byte_send;                  
    315                      pUARTREG[uart_index]->US_PTCR     =  AT91C_PDC_TXTEN ; //start PDC
    316                      pUARTREG[uart_index]->US_IER      =  AT91C_US_ENDTX  ; //enable PDC tx INT
    317                      
    318                  } else {
    319                      error = 2;  //??
    320                      
    321                  }         
    322                
    323              }
    324              OS_EXIT_CRITICAL();
    325              
    326              return error;
    327          }
    328          
    329          
    330          /*
    331          *********************************************************************************************************
    332          *                                    UART_Read()
    333          *
    334          * Description : read data from uart receive queue
    335          *
    336          * Argument(s) : uart_index : 0 ~ 3  
    337          *               *pdata : the read date will be in the location this pointer point to  
    338          *  
    339          * Return(s)   : error: =0 is no orror
    340          *                      =1 is no data is read
    341          *
    342          * Note(s)     : 
    343          *
    344          *********************************************************************************************************
    345          */
    346          CPU_INT08U UART_Read( CPU_INT08U uart_index, QUEUE_DATA_TYPE *pdata )
    347          {
    348              CPU_INT08U error;
    349               
    350              error = 0 ;   
    351              
    352              if ( Queue_Read( pdata, (void *)pUART_Rece_Buf[uart_index]) != QUEUE_OK )  {
    353                  error = 1;
    354                  
    355              }    
    356              
    357              return error;
    358          } 
    359          
    360          
    361          /*
    362          *********************************************************************************************************
    363          *                                    ISR_PC_UART()
    364          *
    365          * Description : PC uart (uart0) interruption service subroutine
    366          *
    367          * Argument(s) : no
    368          *  
    369          * Return(s)   : no
    370          *
    371          * Note(s)     : 
    372          *
    373          *********************************************************************************************************
    374          */
    375          void ISR_PC_UART( void )
    376          {
    377              CPU_INT32U status; 
    378              CPU_INT16U byte_send;
    379              
    380          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register           */
    381              OS_CPU_SR  cpu_sr = 0u;
    382          #endif   
    383           
    384              byte_send = 0;
    385              
    386              OS_ENTER_CRITICAL();
    387              
    388              AT91C_BASE_AIC->AIC_IVR = 0;     /* Write the IVR, as required in Protection Mode */
    389              status = pUARTREG[PC_UART]->US_CSR;  
    390              
    391              if ( status & AT91C_US_ENDTX  )   {  //Transmit INT         
    392                  if( Queue_ReadBuf(  pUART_Send_Buf_PDC[PC_UART],
    393                                      pUART_Send_Buf[PC_UART], 
    394                                      UART_PDC_LENGTH, 
    395                                      &byte_send) == QUEUE_OK ) {  //move data from PDC buf to queue
    396                      pUARTREG[PC_UART]->US_TPR = (CPU_INT32U) pUART_Send_Buf_PDC[PC_UART];
    397                      pUARTREG[PC_UART]->US_TCR = byte_send;       
    398                      pUARTREG[PC_UART]->US_PTCR = AT91C_PDC_TXTEN; //start PDC
    399                              
    400                  } else {
    401                      pUARTREG[PC_UART]->US_IDR      =  AT91C_US_ENDTX  ; //disable PDC tx INT
    402                      //pUARTREG[PC_UART]->US_PTCR  =   AT91C_PDC_TXTDIS; //stop PDC
    403                  }
    404                  
    405              }
    406              
    407              if (status & AT91C_US_ENDRX  )   {  // receive INT
    408                  Queue_WriteBuf( pUART_Rece_Buf_PDC[PC_UART],  
    409                                  pUART_Rece_Buf[PC_UART], 
    410                                  UART_PDC_LENGTH );//move data from queue to PDC buf
    411                  pUARTREG[PC_UART]->US_RPR  = (CPU_INT32U) pUART_Rece_Buf_PDC[PC_UART];
    412                  pUARTREG[PC_UART]->US_RCR  = UART_PDC_LENGTH;
    413                  pUARTREG[PC_UART]->US_PTCR = AT91C_PDC_RXTEN;
    414                  
    415              }
    416              
    417              if (status & AT91C_US_TIMEOUT)   {  //receive timeout
    418                  Queue_WriteBuf( pUART_Rece_Buf_PDC[PC_UART], 
    419                                  pUART_Rece_Buf[PC_UART], 
    420                                  (UART_PDC_LENGTH - pUARTREG[PC_UART]->US_RCR) );  //move data from queue to PDC buf        
    421                  pUARTREG[PC_UART]->US_RPR  = (CPU_INT32U) pUART_Rece_Buf_PDC[PC_UART];
    422                  pUARTREG[PC_UART]->US_RCR  = UART_PDC_LENGTH;
    423                  pUARTREG[PC_UART]->US_PTCR = AT91C_PDC_RXTEN;
    424                  
    425                  pUARTREG[PC_UART]->US_CR   = AT91C_US_STTTO; //restart timeout counter
    426                  pUARTREG[PC_UART]->US_RTOR = UART_TIMEOUT_BIT;
    427                
    428              }
    429          
    430              OS_EXIT_CRITICAL();
    431              
    432              BSP_IntClr( UART_PID[PC_UART] );
    433              
    434          }
    435          
    436          
    437          
    438          
    439          /*
    440          *********************************************************************************************************
    441          *                                    ISR_Ruler_UART()
    442          *
    443          * Description : Ruler uart (uart1) interruption service subroutine
    444          *
    445          * Argument(s) : no
    446          *  
    447          * Return(s)   : no
    448          *
    449          * Note(s)     : 
    450          *
    451          *********************************************************************************************************
    452          */
    453          void ISR_Ruler_UART( void )
    454          {
    455              CPU_INT32U status; 
    456              CPU_INT16U byte_send;
    457              
    458          #if OS_CRITICAL_METHOD == 3u   /* Allocate storage for CPU status register           */
    459              OS_CPU_SR  cpu_sr = 0u;
    460          #endif   
    461           
    462              byte_send = 0;
    463              
    464              OS_ENTER_CRITICAL();
    465              
    466              AT91C_BASE_AIC->AIC_IVR = 0;  //?????   /* Write the IVR, as required in Protection Mode */
    467              status = pUARTREG[RULER_UART]->US_CSR;  
    468              
    469              if ( status & AT91C_US_ENDTX  )   {  //Transmit INT         
    470                  if( Queue_ReadBuf(  pUART_Send_Buf_PDC[RULER_UART],
    471                                      pUART_Send_Buf[RULER_UART], 
    472                                      UART_PDC_LENGTH, 
    473                                      &byte_send) == QUEUE_OK ) {  //move data from PDC buf to queue
    474                      pUARTREG[RULER_UART]->US_TPR = (CPU_INT32U) pUART_Send_Buf_PDC[RULER_UART];
    475                      pUARTREG[RULER_UART]->US_TCR = byte_send;       
    476                      pUARTREG[RULER_UART]->US_PTCR = AT91C_PDC_TXTEN; //start PDC
    477                              
    478                  } else {
    479                      pUARTREG[RULER_UART]->US_IDR      =  AT91C_US_ENDTX  ; //disable PDC tx INT
    480                      //pUARTREG[RULER_UART]->US_PTCR  =   AT91C_PDC_TXTDIS; //stop PDC
    481                  }
    482                  
    483              }
    484              
    485              if (status & AT91C_US_ENDRX  )   {  // receive INT
    486                  Queue_WriteBuf( pUART_Rece_Buf_PDC[RULER_UART],  
    487                                  pUART_Rece_Buf[RULER_UART], 
    488                                  UART_PDC_LENGTH );//move data from queue to PDC buf
    489                  pUARTREG[RULER_UART]->US_RPR  = (CPU_INT32U) pUART_Rece_Buf_PDC[RULER_UART];
    490                  pUARTREG[RULER_UART]->US_RCR  = UART_PDC_LENGTH;
    491                  pUARTREG[RULER_UART]->US_PTCR = AT91C_PDC_RXTEN;
    492                  
    493              }
    494              
    495              if (status & AT91C_US_TIMEOUT)   {  //receive timeout
    496                  Queue_WriteBuf( pUART_Rece_Buf_PDC[RULER_UART], 
    497                                  pUART_Rece_Buf[RULER_UART], 
    498                                  (UART_PDC_LENGTH - pUARTREG[RULER_UART]->US_RCR) );  //move data from queue to PDC buf        
    499                  pUARTREG[RULER_UART]->US_RPR  = (CPU_INT32U) pUART_Rece_Buf_PDC[RULER_UART];
    500                  pUARTREG[RULER_UART]->US_RCR  = UART_PDC_LENGTH;
    501                  pUARTREG[RULER_UART]->US_PTCR = AT91C_PDC_RXTEN;
    502                  
    503                  pUARTREG[RULER_UART]->US_CR   = AT91C_US_STTTO; //restart timeout counter
    504                  pUARTREG[RULER_UART]->US_RTOR = UART_TIMEOUT_BIT;
    505                
    506              }
    507          
    508              OS_EXIT_CRITICAL();
    509              
    510              BSP_IntClr( UART_PID[RULER_UART] );
    511              
    512          }
    513          
    514          
    515          /*
    516          *********************************************************************************************************
    517          *                                    USART_Configure()
    518          *
    519          * Description : USART configuration
    520          *
    521          * Argument(s) : 
    522                      /// \param usart  Pointer to the USART peripheral to configure.
    523                      /// \param mode  Desired value for the USART mode register (see the datasheet).
    524                      /// \param baudrate  Baudrate at which the USART should operate (in Hz).
    525                      /// \param masterClock  Frequency of the system master clock (in Hz).
    526          * Return(s)   : no
    527          *
    528          * Note(s)     : 
    529          *
    530          *********************************************************************************************************
    531          */
    532          void USART_Configure(   AT91S_USART *usart,
    533                                  CPU_INT32U mode,
    534                                  CPU_INT32U baudrate,
    535                                  CPU_INT32U masterClock )
    536          {
    537              // Reset and disable receiver & transmitter
    538              usart->US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX
    539                             | AT91C_US_RXDIS | AT91C_US_TXDIS;
    540              // Configure mode
    541              usart->US_MR = mode;
    542          
    543              // Configure baudrate, asynchronous mode, no oversampling   
    544              
    545              if (    ((mode & AT91C_US_SYNC) == 0)&&
    546                      ((mode & AT91C_US_OVER) == 0)   ) {    
    547                  usart->US_BRGR = (masterClock / baudrate) / 16;
    548              }
    549              // TODO other modes
    550              
    551          }
    552          
    553          
    554          /*
    555          *********************************************************************************************************
    556          *                                    USART_SetTransmitterEnabled()
    557          *
    558          * Description : Enables or disables the transmitter of an USART peripheral.
    559          *
    560          * Argument(s) : 
    561                          /// \param usart  Pointer to an USART peripheral
    562                          /// \param enabled  If true, the transmitter is enabled; otherwise it is disabled.
    563          * Return(s)   : no
    564          *
    565          * Note(s)     : 
    566          *
    567          *********************************************************************************************************
    568          */
    569          void USART_SetTransmitterEnabled( AT91S_USART *usart, CPU_INT08U enabled )
    570          {
    571              if (enabled) {
    572                  usart->US_CR = AT91C_US_TXEN;
    573                  
    574              }   else {
    575                  usart->US_CR = AT91C_US_TXDIS;
    576                  
    577              }
    578              
    579          }
    580          
    581          
    582          
    583          /*
    584          *********************************************************************************************************
    585          *                                    USART_SetReceiverEnabled()
    586          *
    587          * Description : Enables or disables the receiver of an USART peripheral.
    588          *
    589          * Argument(s) : 
    590                          /// \param usart  Pointer to an USART peripheral
    591                          /// \param enabled  If true, the receiver is enabled; otherwise it is disabled.
    592          * Return(s)   : no
    593          *
    594          * Note(s)     : 
    595          *
    596          *********************************************************************************************************
    597          */
    598          void USART_SetReceiverEnabled( AT91S_USART *usart,  CPU_INT08U enabled )
    599          {
    600              if (enabled) {
    601                  usart->US_CR = AT91C_US_RXEN;
    602                  
    603              } else {
    604                  usart->US_CR = AT91C_US_RXDIS;
    605                  
    606              }
    607          }
    608          
    609          
    610          
    611          
    612          //------------------------------------------------------------------------------
    613          /// Sends the contents of a data buffer through the specified USART peripheral.
    614          /// This function returns immediately (1 if the buffer has been queued, 0
    615          /// otherwise); poll the ENDTX and TXBUFE bits of the USART status register
    616          /// to check for the transfer completion.
    617          /// \param usart  Pointer to an USART peripheral.
    618          /// \param buffer  Pointer to the data buffer to send.
    619          /// \param size  Size of the data buffer (in bytes).
    620          //------------------------------------------------------------------------------
    621          static unsigned char USART_WriteBuffer(     AT91S_USART *usart,
    622                                                      void *buffer,
    623                                                      unsigned int size)
    624          {
    625              // Check if the first PDC bank is free
    626              if ((usart->US_TCR == 0) && (usart->US_TNCR == 0)) {
    627                  usart->US_TPR = (unsigned int) buffer;
    628                  usart->US_TCR = size;
    629                  usart->US_PTCR = AT91C_PDC_TXTEN; //start PDC
    630                  return 1;
    631              }
    632              // Check if the second PDC bank is free
    633              else if (usart->US_TNCR == 0) {
    634                  usart->US_TNPR = (unsigned int) buffer;
    635                  usart->US_TNCR = size;
    636                  return 1;
    637              }
    638              else {
    639                  return 0;
    640              }
    641          }
    642          
    643          //------------------------------------------------------------------------------
    644          /// Reads data from an USART peripheral, filling the provided buffer until it
    645          /// becomes full. This function returns immediately with 1 if the buffer has
    646          /// been queued for transmission; otherwise 0.
    647          /// \param usart  Pointer to an USART peripheral.
    648          /// \param buffer  Pointer to the buffer where the received data will be stored.
    649          /// \param size  Size of the data buffer (in bytes).
    650          //------------------------------------------------------------------------------
    651          static unsigned char USART_ReadBuffer(      AT91S_USART *usart,
    652                                                      void *buffer,
    653                                                      unsigned int size)
    654          {
    655              // Check if the first PDC bank is free
    656              if ((usart->US_RCR == 0) && (usart->US_RNCR == 0)) {
    657                  usart->US_RPR = (unsigned int) buffer;
    658                  usart->US_RCR = size;
    659                  usart->US_PTCR = AT91C_PDC_RXTEN;
    660                  return 1;
    661              }
    662              // Check if the second PDC bank is free
    663              else if (usart->US_RNCR == 0) {
    664                  usart->US_RNPR = (unsigned int) buffer;
    665                  usart->US_RNCR = size;
    666                  return 1;
    667              }
    668              else {
    669                  return 0;
    670              }
    671              
    672          }
    673          
    674          
    675          
    676          CPU_INT08U USART_Read_Timeout( CPU_INT08U uart_index, void *buffer, CPU_INT32U size, CPU_INT32U timeout_ms )
    677          { 
    678            
    679              CPU_INT32U counter ;
    680              CPU_INT08U err ;
    681              
    682              counter    = timeout_ms; //wait    for resp   
    683              err        = 0 ;
    684              OSSemPend( USART_Sem[uart_index], 0, &err );
    685          
    686              pUARTREG[uart_index]->US_RCR = 0;
    687              pUARTREG[uart_index]->US_RNCR= 0;
    688              pUARTREG[uart_index]->US_CR  = AT91C_US_STTTO; //Restart timeout 
    689              
    690              while( USART_ReadBuffer(pUARTREG[uart_index],buffer,size) == 0 ){//wait until PDC is free     
    691                  OSTimeDly(1);  /////////?????? 
    692                 
    693              }        
    694              
    695              while ( (pUARTREG[uart_index]->US_CSR & AT91C_US_TIMEOUT) == 0 ) { //wait for data is received       
    696                  OSTimeDly(1);      
    697                  if( --counter == 0) {    ////wait 100ms no data 
    698                      err = UART_RD_TIMEOUT_ERR; //time out
    699                      break;
    700                  }     
    701                         
    702              }
    703              
    704              pUARTREG[uart_index]->US_PTCR = AT91C_PDC_RXTDIS; //disable PDC receive
    705           
    706              OSSemPost( USART_Sem[uart_index]);
    707              
    708              return err ;
    709          
    710          }
    711            
    712          
    713          void USART_SendByte( CPU_INT08U uart_index, CPU_INT08U data )
    714          {
    715          
    716              CPU_INT08U err ;   
    717              
    718              OSSemPend( USART_Sem[uart_index], 0, &err );
    719              
    720              while ( (pUARTREG[uart_index]->US_CSR & AT91C_US_TXEMPTY) == 0 ) {       
    721                 OSTimeDly(1);
    722                 
    723              };  
    724            
    725              pUARTREG[uart_index]->US_THR = data;
    726              
    727              OSSemPost( USART_Sem[uart_index]);
    728           
    729          }
    730          
    731          
    732          
    733          CPU_INT08U USART_SendBuf( CPU_INT08U uart_index, CPU_INT08U * pBuf,  CPU_INT32U size)
    734          {      
    735            
    736              CPU_INT08U err ;
    737              
    738              OSSemPend( USART_Sem[uart_index], 0, &err );    
    739              //memcpy(pUART_Send_Buf[uart_index], pBuf, size); //in case of 
    740              //err = USART_WriteBuffer( pUARTREG[uart_index], pUART_Send_Buf[uart_index], size ); 
    741              err = USART_WriteBuffer( pUARTREG[uart_index], pBuf, size ); 
    742              OSSemPost( USART_Sem[uart_index]);
    743              err = (err == 0) ? 1 : 0 ;
    744              
    745              return err;
    746              
    747          }
    748          
    749          
    750          CPU_INT08U USART_SendBuf_Status( CPU_INT08U uart_index)
    751          {      
    752            
    753              CPU_INT08U err ;    
    754          
    755              if( (pUARTREG[uart_index]->US_PTCR == 0) && (pUARTREG[uart_index]->US_TNCR == 0 )) {
    756                  err = 0 ;
    757                  
    758              } else {        
    759                  err = 1;
    760                  
    761              }
    762              
    763              return err;
    764              
    765          }
    766          
    767          
    768          void USART_SendStr( CPU_INT08U uart_index, CPU_INT08U * pStr )
    769          {       
    770              CPU_INT08U err ;
    771              
    772              OSSemPend( USART_Sem[uart_index], 0, &err );
    773              
    774              memcpy(pUART_Send_Buf[uart_index], pStr, strlen((char const *)pStr)); //in case of 
    775               
    776              USART_WriteBuffer( pUARTREG[uart_index], pUART_Send_Buf[uart_index], strlen((char const *)pStr) ); 
    777              
    778              OSSemPost( USART_Sem[uart_index]);
    779              
    780          }
    781          
    782          
    783          
    784          ////////////////////////////////////////////////////////////////////////////////
    785          
    786          
    787          void DBGU_Configure( CPU_INT32U baud_rate, CPU_INT32U mclk ) 
    788          {    
    789                
    790              AT91C_BASE_PIOA->PIO_PDR  |= (DEF_BIT_30|DEF_BIT_31);                 /* Set GPIOA pins 9 and 10 as DBGU UART pins                */
    791              AT91C_BASE_PIOA->PIO_ASR  |= (DEF_BIT_30|DEF_BIT_31);                 /* Select GPIOA attached peripheral (DBGU)                  */
    792          
    793               
    794              AT91C_BASE_DBGU->DBGU_CR   =  AT91C_US_RSTRX 
    795                                         |  AT91C_US_RSTTX ;             /*  Reset the receiver  and transmitter                      */
    796              
    797              AT91C_BASE_DBGU->DBGU_IDR  = AT91C_US_RXRDY                 /* Disable Rx interrupts                                    */
    798                                         | AT91C_US_TXRDY;                /* Disable Tx interrupt                                     */
    799          
    800              AT91C_BASE_DBGU->DBGU_CR   = AT91C_US_RXEN                  /* Enable the receiver                                      */
    801                                         | AT91C_US_TXEN ;                /* Enable the transmitter                                   */
    802                                        
    803              
    804              AT91C_BASE_DBGU->DBGU_MR   = AT91C_US_USMODE_NORMAL         /* Normal mode selected                                     */
    805                                         | AT91C_US_PAR_NONE;             /* No parity bit selected                                   */
    806          
    807                                                                          /* Set the DBGU baud rate                                   */
    808              AT91C_BASE_DBGU->DBGU_BRGR = (CPU_INT16U)( MCK / baud_rate / 16);
    809          
    810              AT91C_BASE_PMC->PMC_PCER   = (1 << AT91C_ID_SYS);           /* Enable the DBGU peripheral clock                         */ 
    811              
    812              
    813              
    814          }
    815          
    816          
    817          
    818          void DBGU_Write_Byte(CPU_CHAR tx_byte)
    819          {
    820            
    821              CPU_INT08U   err;  
    822              
    823              OSSemPend( DBGU_Tx_Sem_lock, 0, &err );   
    824          
    825              while ((AT91C_BASE_DBGU->DBGU_CSR & AT91C_US_TXRDY) == 0); /*  Wait for room in the transmit register.                 */
    826            
    827              AT91C_BASE_DBGU->DBGU_THR = tx_byte;
    828          
    829              OSSemPost( DBGU_Tx_Sem_lock );
    830          
    831          }
    832          
    833          
    834          
    835          CPU_INT08U  DBGU_Read_Byte ( CPU_INT08U *pdata, CPU_INT32U timeout_ms )
    836          {
    837              
    838              CPU_INT08U  err; 
    839              err   = 0 ;
    840              
    841              OSSemPend( DBGU_Rx_Sem_lock, 0, &err );  
    842              
    843              while ((AT91C_BASE_DBGU->DBGU_CSR & AT91C_US_RXRDY) == 0) {     /*  Wait for a byte to show up.                         */
    844                  OSTimeDly(1);
    845                  if(timeout_ms-- == 0 ) {
    846                    err = 1 ; //timeout error
    847                    break;
    848                  }
    849              }
    850              *pdata = (CPU_INT08U)(AT91C_BASE_DBGU->DBGU_RHR & 0x00FF);     /* Read the character.                                  */
    851          
    852              OSSemPost( DBGU_Rx_Sem_lock );
    853              
    854              return err;
    855          }
    856          
    857          
    858          //used to clear previous data in 
    859          void DBGU_Read_NULL_RHR( void  )
    860          {    
    861             (CPU_INT08U)(AT91C_BASE_DBGU->DBGU_RHR & 0x00FF);     /* Read the character.                                  */
    862          
    863          }
    864          
    865          
    866          
    867          void DBGU_Write_Buffer( CPU_INT08U * pBuf,  CPU_INT32U size )
    868          {
    869            
    870              CPU_INT08U   err;  
    871              CPU_INT32U   i ;
    872              
    873              OSSemPend( DBGU_Tx_Sem_lock, 0, &err ); 
    874              
    875              for (i = 0; i < size; i++ ){
    876                
    877                while ((AT91C_BASE_DBGU->DBGU_CSR & AT91C_US_TXRDY) == 0); /*  Wait for room in the transmit register.      */  
    878                AT91C_BASE_DBGU->DBGU_THR = *( pBuf + i );
    879              }
    880              
    881              OSSemPost( DBGU_Tx_Sem_lock );
    882          
    883          }
    884          
    885          CPU_INT08U  DBGU_Read_Buff ( CPU_INT08U *pdata, CPU_INT32U size, CPU_INT32U timeout_ms )
    886          {
    887              CPU_INT32U   i ;
    888              CPU_INT08U  err; 
    889              err   = 0 ;
    890              
    891              OSSemPend( DBGU_Rx_Sem_lock, 0, &err );  
    892              
    893              for (i = 0; i < size ; i ++ ) {      
    894                  while ((AT91C_BASE_DBGU->DBGU_CSR & AT91C_US_RXRDY) == 0) {     /*  Wait for a byte to show up.                         */
    895                      OSTimeDly(1);
    896                      if(timeout_ms-- == 0 ) {
    897                            err = 1 ; //timeout error
    898                            OSSemPost( DBGU_Rx_Sem_lock );
    899                            return err;
    900                      }
    901                  }
    902                  *(pdata+i) = (CPU_INT08U)(AT91C_BASE_DBGU->DBGU_RHR & 0x00FF);     /* Read the character.                                  */
    903              
    904              }
    905              
    906              OSSemPost( DBGU_Rx_Sem_lock );
    907              
    908              return err;
    909          }
    910          
    911          
    912          
    913          CPU_INT08U USART_Start_Ruler_Bootloader( void )
    914          {
    915             
    916              unsigned char Buf[9];
    917              AT91S_USART *usart = pUARTREG[RULER_UART];
    918             
    919              usart->US_PTCR = AT91C_PDC_TXTDIS; //stop PDC
    920              if ( (usart->US_TCR != 0) || (usart->US_TNCR != 0) ) {
    921                  return 1; //err
    922              }    
    923              memset(Buf,'d',sizeof(Buf)); 
    924              
    925              usart->US_TPR = (unsigned int) Buf;
    926              usart->US_TCR = sizeof(Buf);      
    927                  
    928              Ruler_Power_Switch(0);     
    929              OSTimeDly(50);
    930              Ruler_Power_Switch(1);   
    931              OSTimeDly(200);
    932              usart->US_PTCR = AT91C_PDC_TXTEN; //start PDC
    933              OSTimeDly(800);
    934              if( USART_Read_Timeout( RULER_UART, Buf, 3, 5000 ) == 0 ) {
    935                  if(Buf[0] == 'c' || Buf[0] == 'C' ) {
    936                      return 0;
    937                  }
    938              }
    939              return 2;
    940              
    941          }
    942          
    943          
    944          ////////////////////////////////////////////////////////////////////////////////
    945          
    946          
    947          
    948          void  memcpy_simple(CPU_INT08U * pDst, CPU_INT08U * pSrc, CPU_INT32U size) //without safty check !
    949          {
    950          	for(;size > 0; size--){
    951          		*pDst++ = *pSrc++;
    952          	}
    953              
    954          }
    955          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   DBGU_Configure
        12   -> __aeabi_uidiv
      24   DBGU_Read_Buff
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> OSTimeDly
      16   DBGU_Read_Byte
        16   -> OSSemPend
        16   -> OSSemPost
        16   -> OSTimeDly
       0   DBGU_Read_NULL_RHR
      24   DBGU_Write_Buffer
        24   -> OSSemPend
        24   -> OSSemPost
      16   DBGU_Write_Byte
        16   -> OSSemPend
        16   -> OSSemPost
      16   ISR_PC_UART
        16   -> BSP_IntClr
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> Queue_ReadBuf
        16   -> Queue_WriteBuf
      16   ISR_Ruler_UART
        16   -> BSP_IntClr
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> Queue_ReadBuf
        16   -> Queue_WriteBuf
      24   UART_Init
        24   -> BSP_IntClr
        24   -> BSP_IntEn
        24   -> BSP_IntVectSet
        24   -> DBGU_Configure
        24   -> OSSemCreate
        24   -> OSSemDel
        24   -> OSSemSet
        24   -> PIO_Configure
        24   -> Queue_Create
        24   -> USART_Configure
        24   -> USART_SetReceiverEnabled
        24   -> USART_SetTransmitterEnabled
      16   UART_Read
        16   -> Queue_Read
      24   UART_Write
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> Queue_ReadBuf
        24   -> Queue_Write
      24   UART_WriteStart
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> Queue_ReadBuf
      20   USART_Configure
        20   -> __aeabi_uidiv
       0   USART_ReadBuffer
      32   USART_Read_Timeout
        32   -> OSSemPend
        32   -> OSSemPost
        32   -> OSTimeDly
        32   -> USART_ReadBuffer
      24   USART_SendBuf
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> USART_WriteBuffer
       0   USART_SendBuf_Status
      16   USART_SendByte
        16   -> OSSemPend
        16   -> OSSemPost
        16   -> OSTimeDly
      16   USART_SendStr
        16   -> OSSemPend
        16   -> OSSemPost
        16   -> USART_WriteBuffer
        16   -> memcpy
        16   -> strlen
       0   USART_SetReceiverEnabled
       0   USART_SetTransmitterEnabled
      24   USART_Start_Ruler_Bootloader
        24   -> OSTimeDly
        24   -> Ruler_Power_Switch
        24   -> USART_Read_Timeout
        24   -> memset
       0   USART_WriteBuffer
       0   memcpy_simple


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
     196  DBGU_Configure
     180  DBGU_Read_Buff
     132  DBGU_Read_Byte
      16  DBGU_Read_NULL_RHR
       4  DBGU_Rx_Sem_lock
       4  DBGU_Tx_Sem_lock
     116  DBGU_Write_Buffer
      92  DBGU_Write_Byte
     420  ISR_PC_UART
     420  ISR_Ruler_UART
     512  UART0_Rece_Buf
      32  UART0_Rece_Buf_PDC
     512  UART0_Send_Buf
      32  UART0_Send_Buf_PDC
     512  UART1_Rece_Buf
      32  UART1_Rece_Buf_PDC
     512  UART1_Send_Buf
      32  UART1_Send_Buf_PDC
      64  UART2_Rece_Buf
      32  UART2_Rece_Buf_PDC
      64  UART2_Send_Buf
      32  UART2_Send_Buf_PDC
     816  UART_Init
       4  UART_PID
      36  UART_PINS
      80  UART_Read
      12  UART_Rece_Buf_Size
      12  UART_Send_Buf_Size
     368  UART_Write
     340  UART_WriteStart
      76  USART_Configure
      88  USART_ReadBuffer
     328  USART_Read_Timeout
      12  USART_Sem
     152  USART_SendBuf
      96  USART_SendBuf_Status
     152  USART_SendByte
     172  USART_SendStr
      40  USART_SetReceiverEnabled
      40  USART_SetTransmitterEnabled
     216  USART_Start_Ruler_Bootloader
      88  USART_WriteBuffer
      36  memcpy_simple
      12  pUARTREG
      12  pUART_Rece_Buf
      12  pUART_Rece_Buf_PDC
      12  pUART_Send_Buf
      12  pUART_Send_Buf_PDC

 
 2 388 bytes in section .bss
   124 bytes in section .rodata
 4 716 bytes in section .text
 
 4 716 bytes of CODE  memory
   124 bytes of CONST memory
 2 388 bytes of DATA  memory

Errors: none
Warnings: none
