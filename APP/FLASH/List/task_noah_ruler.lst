###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Aug/2014  09:37:04
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\task_noah_ruler.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\task_noah_ruler.c"
#        -lcN "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\"
#        -lb "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\FLASH\List\task_noah_ruler.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\FLASH\Obj\task_noah_ruler.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\task_noah_ruler.c
      1          /*
      2          *********************************************************************************************************
      3          *                               iSAM TEST BENCH AUDIO BRIDGE BOARD APP PACKAGE
      4          *
      5          *                            (c) Copyright 2013 - 2016; Fortemedia Inc.; Nanjing, China
      6          *
      7          *                   All rights reserved.  Protected by international copyright laws.
      8          *                   Knowledge of the source code may not be used to write a similar
      9          *                   product.  This file may only be used in accordance with a license
     10          *                   and should not be redistributed in any way.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                           TASK PACKAGE
     18          *
     19          *                                          Atmel AT91SAM7A3
     20          *                                               on the
     21          *                                      iSAM Audio Bridge Board
     22          *
     23          * Filename      : task_noah_ruler.c
     24          * Version       : V1.0.0
     25          * Programmer(s) : PQ
     26          *********************************************************************************************************
     27          * Note(s)       :
     28          *********************************************************************************************************
     29          */
     30          
     31          #include <includes.h>
     32          
     33          
     34          //OS_EVENT  *App_Noah_Ruler_Mbox ; //???
     35          OS_EVENT  *UART_MUX_Sem_lock ;
     36          
     37          OS_EVENT  *ACK_Sem_RulerUART ;
     38          OS_EVENT  *Done_Sem_RulerUART ;
     39          
     40          #if 1 
     41          unsigned int test_counter1 = 0 ;
     42          unsigned int test_counter2 = 0 ;
     43          unsigned int test_counter3 = 0 ;
     44          unsigned int test_counter4 = 0 ;
     45          unsigned int test_counter5 = 0 ;
     46          #endif
     47          
     48          /*
     49          *********************************************************************************************************
     50          *                                    App_TaskNoah_Ruler()
     51          *
     52          * Description : Process Comminucation between Ruler module and Audio Bridge.
     53          *               Noah protocol layer related data parsing and processing.
     54          *               This task wait for message event from App_TaskUART_Rx(). Check if the Noah layer data is 
     55          *               valid in the message.  
     56          *
     57          * Argument(s) : p_arg   Argument passed to 'App_TaskNoah_Ruler()' by 'OSTaskCreate()'.
     58          *
     59          * Return(s)   : none.
     60          *
     61          * Note(s)     : (1) The first line of code is used to prevent a compiler warning because 'p_arg' is not
     62          *                   used.  The compiler should not generate any code for this statement.
     63          *********************************************************************************************************
     64          */
     65          void App_TaskNoah_Ruler( void *p_arg )
     66          { 
     67              (void)p_arg;
     68              
     69              NOAH_CMD   *pPcCmd ;    
     70              CPU_INT08U *pCmdBuf ;
     71              CPU_INT08U  rxID ; 
     72              CPU_INT08U  PcCmdRxID_Ruler[4];
     73              CPU_INT08U  sum ;  
     74              CPU_INT08U  SessionDone;
     75              CPU_INT08U  err ;
     76              CPU_INT08U *pTaskMsgIN ;  
     77              CPU_INT08U *pMsg ;  
     78              
     79              pTaskMsgIN  = NULL;
     80              pMsg        = NULL;
     81              SessionDone = 0 ;    
     82             
     83                
     84              while( DEF_TRUE ) {          
     85                       
     86                  pTaskMsgIN  = (INT8U *)OSQPend( EVENT_MsgQ_RulerUART2Noah, 0, &err ); 
     87                  
     88                  if( pTaskMsgIN != NULL && OS_ERR_NONE == err )   {
     89                     
     90                      pCmdBuf = pTaskMsgIN; // char point to the data buffer
     91                      pPcCmd  = (NOAH_CMD *)pCmdBuf ; //change to NOAH_CMD type
     92                      rxID    = GET_FRAME_ID( pPcCmd->head ) ; //get frame ID, index       
     93                      sum     = pPcCmd->checkSum; //get check sum data  
     94                      
     95                      LED_Toggle(LED_DS2);           
     96                      APP_TRACE_DBG(("\r\n<<"));
     97                      switch( GET_FRAME_TYPE( pPcCmd->head ) ) {// GET_FRAME_TYPE(pPcCmd->head)  get frame type 
     98                          
     99                          case FRAM_TYPE_DATA :  
    100                              
    101                              if( (sum == 0) || ( sum == CheckSum(0,pCmdBuf, pPcCmd->DataLen + 2)) ) {   
    102          //                        APP_TRACE_INFO(("R[%d]:[0x%2x>0x%2x][",Global_Ruler_Index,PcCmdRxID_Ruler[Global_Ruler_Index],rxID));
    103          //                        for(unsigned int i = 0; i<pPcCmd->DataLen; i++){   
    104          //                            APP_TRACE_INFO((" %2X", *(unsigned char*)(pPcCmd->Data+i) )); 
    105          //                        }
    106          //                        APP_TRACE_INFO((" ]\r\n")); 
    107                                  pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, SET_FRAME_HEAD(rxID,FRAM_TYPE_ACK), NULL, 0, 0, NULL, 0 ) ;  // ACK                                               
    108                                  if( (CPU_INT08U)(PcCmdRxID_Ruler[Global_Ruler_Index]+0x40) == rxID ) { // chweck if frameID repeat  
    109                                      PcCmdRxID_Ruler[Global_Ruler_Index] = rxID ; //save this frameID 
    110                                   
    111                                      err = Noah_CMD_Parse_Ruler( pPcCmd, &SessionDone); // jump to CMD parse 
    112                                      if( (err != OS_ERR_NONE) || (SessionDone == 1) ) {
    113                                          SessionDone = 0;
    114                                          Ruler_CMD_Result = err ;
    115                                          OSTimeDly(2); //wait enough time for ACK to be sent
    116                                          APP_TRACE_DBG((" Res[0x%2x]", Ruler_CMD_Result));
    117                                          OSSemPost( Done_Sem_RulerUART );                                     
    118                                      }
    119                    
    120                                  } else {                      
    121                                      APP_TRACE_DBG(("PcCmdRxID_Ruler[%d] Err: expect 0x%X, get 0x%X",Global_Ruler_Index,PcCmdRxID_Ruler[Global_Ruler_Index]+0x40,rxID)); 
    122                                  }
    123                                  
    124                              } else {                
    125                                  pcSendDateToBuf( EVENT_MsgQ_Noah2RulerUART, SET_FRAME_HEAD(rxID,FRAM_TYPE_NAK), NULL, 0, 0, NULL, 0 ) ;  // NAK   
    126                              
    127                              }                 
    128                          break ;                
    129                    
    130                              
    131                          case FRAM_TYPE_ESTA :
    132                            
    133                              PcCmdRxID_Ruler[Global_Ruler_Index] = 0xC0 ; // ? why 0x40: make sure there can be many same setup frame
    134                              PcCmdTxID_Ruler[Global_Ruler_Index] = 0x00 ; //  
    135                              
    136                              OSSemPost( ACK_Sem_RulerUART ); 
    137                              OSSemPost( Done_Sem_RulerUART ); //end the resend pending--                     
    138                              OSTimeDly(5); //wait for the TX buffer is empty 
    139                              
    140                              //Reset all UART CMD related buffer and release mem 
    141                              do{  //reset mem used by  EVENT_MsgQ_RulerUART2Noah                    
    142                                  pMsg   = (INT8U *)OSQAccept( EVENT_MsgQ_Noah2RulerUART, &err );
    143                                  OSMemPut( pMEM_Part_MsgUART, pMsg ); 
    144                              } while ( pMsg != NULL && OS_ERR_NONE == err ) ; 
    145                              
    146                              do{  //reset mem used by  EVENT_MsgQ_RulerUART2Noah                  
    147                                  pMsg   = (INT8U *)OSQAccept( EVENT_MsgQ_RulerUART2Noah, &err );
    148                                  OSMemPut( pMEM_Part_MsgUART, pMsg ); 
    149                              } while ( pMsg != NULL && OS_ERR_NONE == err ) ; 
    150                                 
    151                              Queue_Flush( pUART_Send_Buf[RULER_UART] ); //clear uart send&rec data queue
    152                              Queue_Flush( pUART_Rece_Buf[RULER_UART] );                      
    153                   
    154                              SessionDone = 0;  //init  
    155                              OSSemSet( ACK_Sem_RulerUART, 0, &err ); // clear the sem
    156                              OSSemSet( Done_Sem_RulerUART, 0, &err );
    157                              test_counter4++;
    158                              APP_TRACE_DBG(("EST/ESTA"));   
    159                          break ;         
    160                                  
    161                          case FRAM_TYPE_ACK :
    162                            
    163                              if( rxID == PcCmdTxID_Ruler[Global_Ruler_Index] ) {                       
    164                                  OSSemPost( ACK_Sem_RulerUART );                        
    165                                  test_counter2++;
    166                              } else {
    167                                  APP_TRACE_INFO(("\r\nACK: got %X, expect %X\r\n",rxID,PcCmdTxID_Ruler[Global_Ruler_Index] )); 
    168                              }
    169                              APP_TRACE_DBG(("ACK")); 
    170                              test_counter3++;       
    171                          break ;
    172                          
    173                          case FRAM_TYPE_NAK :
    174                              // dismiss NAK, there will be a resend if no ACK got
    175                              // OSSemPost( Done_Sem_RulerUART );
    176                              test_counter1++;
    177                              APP_TRACE_DBG(("NAK")); 
    178                          break;
    179                          
    180                                   
    181                          default :    
    182                          break ;              
    183                      } 
    184                      
    185                      //release mem
    186                      OSMemPut( pMEM_Part_MsgUART, pTaskMsgIN );  
    187                     
    188                  }         
    189                  
    190                  ////OSTimeDly(2);   //use OSQPend(), no delay needed!!! 
    191                  
    192              }        
    193              
    194              
    195          }
    196          
    197          
    198          
    199              

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   App_TaskNoah_Ruler
        56   -> BSP_Ser_Printf
        56   -> CheckSum
        56   -> LED_Toggle
        56   -> Noah_CMD_Parse_Ruler
        56   -> OSMemPut
        56   -> OSQAccept
        56   -> OSQPend
        56   -> OSSemPost
        56   -> OSSemSet
        56   -> OSTimeDly
        56   -> Queue_Flush
        56   -> pcSendDateToBuf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      28  ?<Constant "\r\nACK: got %X, expect...">
       4  ACK_Sem_RulerUART
     972  App_TaskNoah_Ruler
       4  Done_Sem_RulerUART
       4  UART_MUX_Sem_lock
       4  test_counter1
       4  test_counter2
       4  test_counter3
       4  test_counter4
       4  test_counter5

 
  32 bytes in section .bss
  28 bytes in section .rodata
 972 bytes in section .text
 
 972 bytes of CODE  memory
  28 bytes of CONST memory
  32 bytes of DATA  memory

Errors: none
Warnings: none
