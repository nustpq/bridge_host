###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        13/Jun/2014  16:27:40
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\led.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\led.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\led.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\led.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\led.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "led.h"
     35          //#include <pio.h>
     36          #include <bsp.h>
     37          //------------------------------------------------------------------------------
     38          //         Local Variables
     39          //------------------------------------------------------------------------------
     40          
     41          #ifdef PINS_LEDS
     42          static const Pin pinsLeds[]         = {PINS_LEDS};
     43          static const unsigned int numLeds   = PIO_LISTSIZE(pinsLeds);
     44          #endif
     45          
     46          static const Pin pinsBuzzer[]         = {BUZZER};
     47          
     48          
     49          //------------------------------------------------------------------------------
     50          //         Global Functions
     51          //------------------------------------------------------------------------------
     52          
     53          //------------------------------------------------------------------------------
     54          /// Configures the pin associated with the given LED number. If the LED does
     55          /// not exist on the board, the function does nothing.
     56          /// \param led  Number of the LED to configure.
     57          /// \return 1 if the LED exists and has been configured; otherwise 0.
     58          //------------------------------------------------------------------------------
     59          unsigned char LED_Configure(unsigned int led)
     60          {
     61          #ifdef PINS_LEDS
     62              // Check that LED exists
     63              if (led >= numLeds) {
     64          
     65                  return 0;
     66              }
     67          
     68              // Configure LED
     69              return (PIO_Configure(&pinsLeds[led], 1));
     70          #else
     71              return 0;
     72          #endif
     73          }
     74          
     75          //------------------------------------------------------------------------------
     76          /// Turns the given LED on if it exists; otherwise does nothing.
     77          /// \param led  Number of the LED to turn on.
     78          /// \return 1 if the LED has been turned on; 0 otherwise.
     79          //------------------------------------------------------------------------------
     80          unsigned char LED_Set(unsigned int led)
     81          {
     82          #ifdef PINS_LEDS
     83              // Check if LED exists
     84              if (led >= numLeds) {
     85          
     86                  return 0;
     87              }
     88          
     89              // Turn LED on
     90              if (pinsLeds[led].type == PIO_OUTPUT_0) {
     91          
     92                  PIO_Set(&pinsLeds[led]);
     93              }
     94              else {
     95          
     96                  PIO_Clear(&pinsLeds[led]);
     97              }
     98          
     99              return 1;
    100          #else
    101              return 0;
    102          #endif
    103          }
    104          
    105          //------------------------------------------------------------------------------
    106          /// Turns a LED off.
    107          /// \param led  Number of the LED to turn off.
    108          /// \param 1 if the LED has been turned off; 0 otherwise.
    109          //------------------------------------------------------------------------------
    110          unsigned char LED_Clear(unsigned int led)
    111          {
    112          #ifdef PINS_LEDS
    113              // Check if LED exists
    114              if (led >= numLeds) {
    115          
    116                  return 0;
    117              }
    118          
    119              // Turn LED off
    120              if (pinsLeds[led].type == PIO_OUTPUT_0) {
    121          
    122                  PIO_Clear(&pinsLeds[led]);
    123              }
    124              else {
    125          
    126                  PIO_Set(&pinsLeds[led]);
    127              }
    128          
    129              return 1;
    130          #else
    131              return 0;
    132          #endif
    133          }
    134          
    135          //------------------------------------------------------------------------------
    136          /// Toggles the current state of a LED.
    137          /// \param led  Number of the LED to toggle.
    138          /// \return 1 if the LED has been toggled; otherwise 0.
    139          //------------------------------------------------------------------------------
    140          unsigned char LED_Toggle(unsigned int led)
    141          {
    142          #ifdef PINS_LEDS
    143              // Check if LED exists
    144              if (led >= numLeds) {
    145          
    146                  return 0;
    147              }
    148          
    149              // Toggle LED
    150              if (PIO_GetOutputDataStatus(&pinsLeds[led])) {
    151          
    152                  PIO_Clear(&pinsLeds[led]);
    153              }
    154              else {
    155          
    156                  PIO_Set(&pinsLeds[led]);
    157              }
    158          
    159              return 1;
    160          #else
    161              return 0;
    162          #endif
    163          }
    164          
    165          
    166          
    167          //------------------------------------------------------------------------------
    168          ///        
    169          //------------------------------------------------------------------------------
    170          void ChannelSet(unsigned char hs,unsigned char sel)
    171          { /*
    172            	if(hs)
    173          	{
    174          	  	PIO_Clear(&pinsLeds[3]);
    175          	}
    176          	else
    177          	{
    178          	  	PIO_Set(&pinsLeds[3]);
    179          	}
    180          	if(sel < 4)
    181          	{
    182          	 	PIO_Set(&pinsLeds[0]); 
    183          		PIO_Set(&pinsLeds[1]);  
    184          		PIO_Set(&pinsLeds[2]);
    185          		PIO_Set(&pinsLeds[4]);
    186          		if(sel > 2) 
    187          		{
    188          			PIO_Clear(&pinsLeds[sel+1]);
    189          		}
    190          		else
    191          		{
    192          		  	PIO_Clear(&pinsLeds[sel]);
    193          		}
    194          	}
    195            */
    196          }
    197          //------------------------------------------------------------------------------
    198          //
    199          //------------------------------------------------------------------------------
    200          int IOInit(void)
    201          {  /*
    202            	unsigned int x;	
    203          	for(x = 0;x < numLeds;x++)
    204          	{
    205          	  	LED_Configure(x);
    206          	}
    207          	//PIO_Configure(pinsKeys, PIO_LISTSIZE(pinsKeys)); 
    208          	
    209             */
    210            	return 0;
    211          }
    212          //------------------------------------------------------------------------------
    213          //
    214          //------------------------------------------------------------------------------
    215          int IOGetKey(int x)
    216          {
    217             /*
    218            	unsigned int tt;
    219          	static int lastKey = -1,keyCnt = 0;
    220          	
    221            	tt = (AT91C_BASE_PIOB->PIO_PDSR& (0x1F << 3)) >> 3;
    222          	tt = ~tt;
    223          	if(keyCnt++ > x)
    224          	{
    225          	  	keyCnt = 0;
    226          		if(tt &0x1)//KEY 0
    227          		{
    228          		  	return 0;
    229          		}
    230          		else if(tt &0x2)//KEY 1
    231          		{
    232          		  	return 1;
    233          		}
    234          		else if(tt &0x4)//KEY 3
    235          		{
    236          		  	return 3;
    237          		}
    238          		else if(tt &0x8)//KEY 2
    239          		{
    240          		  	return 2;
    241          		}
    242          		else if(tt &0x10)//KEY 4
    243          		{
    244          		  	return 4;
    245          		}
    246          	}
    247            */
    248          	return -1;
    249          }
    250          
    251          
    252          
    253          //------------------------------------------------------------------------------
    254          ///
    255          ///
    256          ///
    257          //------------------------------------------------------------------------------
    258          volatile unsigned char BUZZER_MUTE = 0 ;
    259          
    260          void Buzzer_OnOff( unsigned char onoff )
    261          {
    262            
    263              if( BUZZER_MUTE != 0 ) {
    264                  return;
    265              }
    266              
    267              if( onoff == 1 ) {
    268                  PIO_Clear( &pinsBuzzer[0] ); //buzzer 
    269                  
    270              } else {
    271                  PIO_Set( &pinsBuzzer[0] ); //buzzer 
    272                  
    273              }
    274              
    275              
    276          }
    277          
    278          void Buzzer_Toggle( void )
    279          {
    280             
    281              if( BUZZER_MUTE != 0 ) {
    282                  return;
    283              }
    284              // Toggle Buzz
    285              if (PIO_GetOutputDataStatus(&pinsBuzzer[0])) {
    286          
    287                  PIO_Clear(&pinsBuzzer[0]);
    288              }
    289              else {
    290          
    291                  PIO_Set(&pinsBuzzer[0]);
    292              }
    293              
    294              
    295          }
    296          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Buzzer_OnOff
         8   -> PIO_Clear
         8   -> PIO_Set
       8   Buzzer_Toggle
         8   -> PIO_Clear
         8   -> PIO_GetOutputDataStatus
         8   -> PIO_Set
       0   ChannelSet
       0   IOGetKey
       0   IOInit
       8   LED_Clear
         8   -> PIO_Clear
         8   -> PIO_Set
       8   LED_Configure
         8   -> PIO_Configure
       8   LED_Set
         8   -> PIO_Clear
         8   -> PIO_Set
       8   LED_Toggle
         8   -> PIO_Clear
         8   -> PIO_GetOutputDataStatus
         8   -> PIO_Set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       1  BUZZER_MUTE
      68  Buzzer_OnOff
      64  Buzzer_Toggle
       4  ChannelSet
      12  IOGetKey
       8  IOInit
     104  LED_Clear
      60  LED_Configure
     104  LED_Set
     104  LED_Toggle
       4  numLeds
      12  pinsBuzzer
      72  pinsLeds

 
   1 byte  in section .bss
  88 bytes in section .rodata
 544 bytes in section .text
 
 544 bytes of CODE  memory
  88 bytes of CONST memory
   1 byte  of DATA  memory

Errors: none
Warnings: none
