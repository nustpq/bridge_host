###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        21/Jul/2014  19:24:37
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\uC-Probe\Target\Communication\Generic\Source\probe_com.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\uC-Probe\Target\Communication\Generic\Source\probe_com.c"
#        -lcN "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\"
#        -lb "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\FLASH\List\probe_com.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\probe_com.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\uC-Probe\Target\Communication\Generic\Source\probe_com.c
      1          /*
      2          *********************************************************************************************************
      3          *                                       uC/Probe Communication
      4          *
      5          *                         (c) Copyright 2007-2008; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                       COMMUNICATION: GENERIC
     18          *
     19          * Filename      : probe_com.c
     20          * Version       : V2.30
     21          * Programmer(s) : BAN
     22          *********************************************************************************************************
     23          * Note(s)       : (1) This file contains code to respond to generic (non protocol-dependent) commands
     24          *                     received by the target.
     25          *********************************************************************************************************
     26          */
     27          
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                            INCLUDE FILES
     32          *********************************************************************************************************
     33          */
     34          
     35          #define   PROBE_COM_MODULE
     36          #include  <probe_com.h>
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                            LOCAL DEFINES
     42          *********************************************************************************************************
     43          */
     44          
     45          /*
     46          *********************************************************************************************************
     47          *                                        DATA FORMATS DEFINES
     48          *********************************************************************************************************
     49          */
     50          
     51          #define  PROBE_COM_FMT_TX_ERR                         0x8000u
     52          
     53          #define  PROBE_COM_FMT_RX_QUERY                       0x0001u   /* Query setup parameter or capability.                 */
     54          #define  PROBE_COM_FMT_TX_QUERY                       0x8001u
     55          
     56          #define  PROBE_COM_FMT_RX_RD                          0x0002u   /* Read data at memory address.                         */
     57          #define  PROBE_COM_FMT_TX_RD                          0x8002u
     58          
     59          #define  PROBE_COM_FMT_RX_WR                          0x0003u   /* Write data at memory address.                        */
     60          #define  PROBE_COM_FMT_TX_WR                          0x8003u
     61          
     62          #define  PROBE_COM_FMT_RX_RD_MULTI                    0x0007u   /* Read data at multiple memory addresses.              */
     63          #define  PROBE_COM_FMT_TX_RD_MULTI                    0x8007u
     64          #define  PROBE_COM_FMT_TX_RD_MULTI_LO                   0x07u
     65          #define  PROBE_COM_FMT_TX_RD_MULTI_HI                   0x80u
     66          
     67          #define  PROBE_COM_FMT_RX_WR_MULTI                    0x0008u   /* Write data at multiple memory addresses.             */
     68          #define  PROBE_COM_FMT_TX_WR_MULTI                    0x8008u
     69          
     70          #define  PROBE_COM_FMT_RX_STR_OUT                     0x0009u   /* Transmit output string to Probe.                     */
     71          #define  PROBE_COM_FMT_TX_STR_OUT                     0x8009u
     72          
     73          #define  PROBE_COM_FMT_RX_STR_IN                      0x000Au   /* Receive input string from Probe.                     */
     74          #define  PROBE_COM_FMT_TX_STR_IN                      0x800Au
     75          
     76          #define  PROBE_COM_FMT_RX_TERMINAL_EXEC               0x000Bu   /* Execute terminal command.                            */
     77          #define  PROBE_COM_FMT_TX_TERMINAL_EXEC               0x800Bu
     78          
     79          #define  PROBE_COM_FMT_RX_TERMINAL_OUT                0x000Cu   /* Transmit output data to Probe.                       */
     80          #define  PROBE_COM_FMT_TX_TERMINAL_OUT                0x800Cu
     81          
     82          #define  PROBE_COM_FMT_RX_TERMINAL_IN                 0x000Du   /* Receive input data from Probe.                       */
     83          #define  PROBE_COM_FMT_TX_TERMINAL_IN                 0x800Du
     84          
     85          /*
     86          *********************************************************************************************************
     87          *                                      STATUS CONSTANTS DEFINES
     88          *********************************************************************************************************
     89          */
     90          
     91          #define  PROBE_COM_STATUS_OK                            0x01u
     92          #define  PROBE_COM_STATUS_TERMINAL_EXEC_NOT_RDY         0xF4u   /* Terminal not rdy to exec new cmd.                    */
     93          #define  PROBE_COM_STATUS_TERMINAL_IN_OVF               0xF5u   /* Terminal in buf ovf'd.                               */
     94          #define  PROBE_COM_STATUS_TERMINAL_OUT_NONE             0xF6u   /* Terminal out buf empty.                              */
     95          #define  PROBE_COM_STATUS_STR_IN_OVF                    0xF7u   /* String in buf ovf'd.                                 */
     96          #define  PROBE_COM_STATUS_STR_OUT_NONE                  0xF8u   /* String out buf empty.                                */
     97          #define  PROBE_COM_STATUS_UNKNOWN_REQUEST               0xF9u   /* Unknown req.                                         */
     98          #define  PROBE_COM_STATUS_QUERY_NOT_SUPPORTED           0xFCu   /* Query not supported.                                 */
     99          #define  PROBE_COM_STATUS_TX_PKT_TOO_LARGE              0xFDu   /* Reply pkt too large for buf.                         */
    100          #define  PROBE_COM_STATUS_RX_PKT_WRONG_SIZE             0xFEu   /* Req pkt not correct size.                            */
    101          #define  PROBE_COM_STATUS_FAIL                          0xFFu   /* Req exec failed (or unknown err).                    */
    102          
    103          /*
    104          *********************************************************************************************************
    105          *                                           QUERIES DEFINES
    106          *********************************************************************************************************
    107          */
    108          
    109                                                                          /* ------------------- CONFIGURATION ------------------ */
    110          #define  PROBE_COM_QUERY_MAX_RX_SIZE                  0x0101u   /* Get data size of largest pkt target can rx.          */
    111          #define  PROBE_COM_QUERY_MAX_TX_SIZE                  0x0102u   /* Get data size of largest pkt target can tx.          */
    112          
    113                                                                          /* ----------------- TARGET PROPERTIES ---------------- */
    114          #define  PROBE_COM_QUERY_ENDIANNESS_TEST              0x0201u   /* Test endianness of target.                           */
    115          #define  PROBE_COM_QUERY_STATUS                       0x0202u   /* Target status.                                       */
    116          
    117                                                                          /* ------------- COMMUNICATION CAPABILITIES ----------- */
    118          #define  PROBE_COM_QUERY_FMT_SUPPORT                  0x1001u   /* Get list of supported req's.                         */
    119          #define  PROBE_COM_QUERY_VERSION                      0x1002u   /* Get target code ver.                                 */
    120          
    121          /*
    122          *********************************************************************************************************
    123          *                                          MODIFIERS DEFINES
    124          *********************************************************************************************************
    125          */
    126          
    127          #define  PROBE_COM_MODIFIER_NONE                  DEF_BIT_NONE
    128          #define  PROBE_COM_MODIFIER_STR_OUT_AVAIL         DEF_BIT_00    /* Str out is avail.                                    */
    129          #define  PROBE_COM_MODIFIER_TERMINAL_EXEC_DONE    DEF_BIT_01    /* Terminal cmd exec done.                              */
    130          #define  PROBE_COM_MODIFIER_TERMINAL_OUT_AVAIL    DEF_BIT_02    /* Terminal out is avail.                               */
    131          
    132          /*
    133          *********************************************************************************************************
    134          *                                        HEADER SIZES DEFINES
    135          *
    136          * Note(s):  (1) The first four bytes in all tx data segments is identical:
    137          *
    138          *               (a) A 2-byte format;
    139          *               (b) A 1-byte status;
    140          *               (c) A 1-byte modifier, currently unused.
    141          *
    142          *           (2) The first two bytes in all rx data segments is identical:
    143          *
    144          *               (a) A 2-byte format.
    145          *********************************************************************************************************
    146          */
    147          
    148          #define  PROBE_COM_SIZE_RX_HDR                             2u
    149          #define  PROBE_COM_SIZE_TX_HDR                             4u
    150          
    151          /*
    152          *********************************************************************************************************
    153          *                                           LOCAL CONSTANTS
    154          *********************************************************************************************************
    155          */
    156          
    157          
    158          /*
    159          *********************************************************************************************************
    160          *                                          LOCAL DATA TYPES
    161          *********************************************************************************************************
    162          */
    163          
    164          typedef  struct  probe_com_buf {
    165              CPU_SIZE_T   Len;
    166              CPU_SIZE_T   IxRd;
    167              CPU_SIZE_T   IxWr;
    168              CPU_INT08U  *DataPtr;
    169          } PROBE_COM_BUF;
    170          
    171          
    172          /*
    173          *********************************************************************************************************
    174          *                                            LOCAL TABLES
    175          *********************************************************************************************************
    176          */
    177          
    178          
    179          /*
    180          *********************************************************************************************************
    181          *                                       LOCAL GLOBAL VARIABLES
    182          *********************************************************************************************************
    183          */
    184          
    185          #if (PROBE_COM_CFG_STR_REQ_EN       == DEF_ENABLED)
    186          static  CPU_CHAR                       ProbeCom_StrInBufData[PROBE_COM_CFG_STR_IN_BUF_SIZE];
    187          static  PROBE_COM_BUF                  ProbeCom_StrInBuf;
    188          
    189          static  CPU_CHAR                       ProbeCom_StrOutBufData[PROBE_COM_CFG_STR_OUT_BUF_SIZE];
    190          static  PROBE_COM_BUF                  ProbeCom_StrOutBuf;
    191          #endif
    192          
    193          #if (PROBE_COM_CFG_TERMINAL_REQ_EN  == DEF_ENABLED)
    194          static  PROBE_COM_TERMINAL_EXEC_FNCT   ProbeCom_TerminalExecHandler;
    195          static  CPU_BOOLEAN                    ProbeCom_TerminalExecuting;
    196          
    197          static  PROBE_COM_TERMINAL_IN_FNCT     ProbeCom_TerminalInHandler;
    198          
    199          static  CPU_INT08U                    *ProbeCom_TerminalOutBufPtr;
    200          static  CPU_SIZE_T                     ProbeCom_TerminalOutBufIx;
    201          static  CPU_SIZE_T                     ProbeCom_TerminalOutBufLen;
    202          #endif
    203          
    204          static  CPU_INT32U                     ProbeCom_EndiannessTest;
    205          
    206          
    207          /*
    208          *********************************************************************************************************
    209          *                                      LOCAL FUNCTION PROTOTYPES
    210          *********************************************************************************************************
    211          */
    212          
    213          static  CPU_INT08U   ProbeCom_PktModifier     (void);
    214          
    215          static  CPU_SIZE_T   ProbeCom_ReqErr          (CPU_INT08U      *ptx_buf,
    216                                                         CPU_INT08U       pcomm_err);
    217          
    218          
    219                                                                          /* ------------------- HANDLE REQ'S ------------------- */
    220          static  CPU_SIZE_T   ProbeCom_ReqQuery        (CPU_INT08U      *prx_buf,
    221                                                         CPU_INT08U      *ptx_buf,
    222                                                         CPU_SIZE_T       rx_pkt_size,
    223                                                         CPU_SIZE_T       tx_buf_size);
    224          
    225          static  CPU_SIZE_T   ProbeCom_ReqRd           (CPU_INT08U      *prx_buf,
    226                                                         CPU_INT08U      *ptx_buf,
    227                                                         CPU_SIZE_T       rx_pkt_size,
    228                                                         CPU_SIZE_T       tx_buf_size);
    229          
    230          static  CPU_SIZE_T   ProbeCom_ReqRdMulti      (CPU_INT08U      *prx_buf,
    231                                                         CPU_INT08U      *ptx_buf,
    232                                                         CPU_SIZE_T       rx_pkt_size,
    233                                                         CPU_SIZE_T       tx_buf_size);
    234          
    235          #if (PROBE_COM_CFG_WR_REQ_EN == DEF_ENABLED)
    236          static  CPU_SIZE_T   ProbeCom_ReqWr           (CPU_INT08U      *prx_buf,
    237                                                         CPU_INT08U      *ptx_buf,
    238                                                         CPU_SIZE_T       rx_pkt_size,
    239                                                         CPU_SIZE_T       tx_buf_size);
    240          
    241          static  CPU_SIZE_T   ProbeCom_ReqWrMulti      (CPU_INT08U      *prx_buf,
    242                                                         CPU_INT08U      *ptx_buf,
    243                                                         CPU_SIZE_T       rx_pkt_size,
    244                                                         CPU_SIZE_T       tx_buf_size);
    245          #endif
    246          
    247          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    248          static  CPU_SIZE_T   ProbeCom_ReqStrIn        (CPU_INT08U      *prx_buf,
    249                                                         CPU_INT08U      *ptx_buf,
    250                                                         CPU_SIZE_T       rx_pkt_size,
    251                                                         CPU_SIZE_T       tx_buf_size);
    252          
    253          static  CPU_SIZE_T   ProbeCom_ReqStrOut       (CPU_INT08U      *prx_buf,
    254                                                         CPU_INT08U      *ptx_buf,
    255                                                         CPU_SIZE_T       rx_pkt_size,
    256                                                         CPU_SIZE_T       tx_buf_size);
    257          #endif
    258          
    259          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    260          static  CPU_SIZE_T   ProbeCom_ReqTerminalExec (CPU_INT08U      *prx_buf,
    261                                                         CPU_INT08U      *ptx_buf,
    262                                                         CPU_SIZE_T       rx_pkt_size,
    263                                                         CPU_SIZE_T       tx_buf_size);
    264          
    265          static  CPU_SIZE_T   ProbeCom_ReqTerminalIn   (CPU_INT08U      *prx_buf,
    266                                                         CPU_INT08U      *ptx_buf,
    267                                                         CPU_SIZE_T       rx_pkt_size,
    268                                                         CPU_SIZE_T       tx_buf_size);
    269          
    270          static  CPU_SIZE_T   ProbeCom_ReqTerminalOut  (CPU_INT08U      *prx_buf,
    271                                                         CPU_INT08U      *ptx_buf,
    272                                                         CPU_SIZE_T       rx_pkt_size,
    273                                                         CPU_SIZE_T       tx_buf_size);
    274          #endif
    275          
    276                                                                          /* ------------------- DYNAMIC BUFFER ----------------- */
    277          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
    278          static  void         ProbeCom_BufInit         (PROBE_COM_BUF   *pbuf,
    279                                                         CPU_INT08U      *pdata,
    280                                                         CPU_SIZE_T       len);
    281          
    282          static  CPU_SIZE_T   ProbeCom_BufRd           (PROBE_COM_BUF   *pbuf,
    283                                                         CPU_INT08U      *pdest,
    284                                                         CPU_SIZE_T       len)
    285          ;
    286          static  CPU_SIZE_T   ProbeCom_BufWr           (PROBE_COM_BUF   *pbuf,
    287                                                         CPU_INT08U      *psrc,
    288                                                         CPU_SIZE_T       len);
    289          
    290          static  CPU_BOOLEAN  ProbeCom_BufIsEmpty      (PROBE_COM_BUF   *pbuf);
    291          #endif
    292          
    293          #if 0
    294          static  CPU_BOOLEAN  ProbeCom_BufIsFull       (PROBE_COM_BUF   *pbuf);
    295          #endif
    296          
    297                                                                          /* ------------------- STATIC BUFFER ------------------ */
    298          static  CPU_INT08U   ProbeCom_GetINT08U       (CPU_INT08U     **pbuf);
    299          
    300          static  CPU_INT16U   ProbeCom_GetINT16U       (CPU_INT08U     **pbuf);
    301          
    302          static  CPU_INT32U   ProbeCom_GetINT32U       (CPU_INT08U     **pbuf);
    303          
    304          static  void         ProbeCom_StoINT08U       (CPU_INT08U     **pbuf,
    305                                                         CPU_INT08U       data);
    306          
    307          static  void         ProbeCom_StoINT16U       (CPU_INT08U     **pbuf,
    308                                                         CPU_INT16U       data);
    309          
    310          #if 0
    311          static  void         ProbeCom_StoINT32U       (CPU_INT08U     **pbuf,
    312                                                         CPU_INT32U       data);
    313          #endif
    314          
    315                                                                          /* -------------- DETERMINE PKT MODIFIER -------------- */
    316          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    317          static  CPU_BOOLEAN  ProbeCom_StrOutAvail     (void);
    318          #endif
    319          
    320          
    321          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    322          static  CPU_BOOLEAN  ProbeCom_TerminalOutAvail(void);
    323          
    324          static  CPU_BOOLEAN  ProbeCom_TerminalExecDone(void);
    325          #endif
    326          
    327          
    328          /*
    329          *********************************************************************************************************
    330          *                                     LOCAL CONFIGURATION ERRORS
    331          *********************************************************************************************************
    332          */
    333          
    334          
    335          /*
    336          *********************************************************************************************************
    337          *                                           ProbeCom_Init()
    338          *
    339          * Description : Initialize the module.
    340          *
    341          * Argument(s) : none.
    342          *
    343          * Return(s)   : DEF_OK,   if initialization successful.
    344          *               DEF_FAIL, otherwise.
    345          *
    346          * Caller(s)   : Application.
    347          *
    348          * Note(s)     : none.
    349          *********************************************************************************************************
    350          */
    351          
    352          CPU_BOOLEAN  ProbeCom_Init (void)
    353          {
    354          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    355              CPU_BOOLEAN  ok;
    356          #endif
    357          
    358          
    359          #if (PROBE_COM_CFG_STR_REQ_EN      == DEF_ENABLED)
    360              Mem_Clr((void     *)&ProbeCom_StrInBufData[0],
    361                      (CPU_SIZE_T) PROBE_COM_CFG_STR_IN_BUF_SIZE);
    362          
    363              ProbeCom_BufInit((PROBE_COM_BUF *)&ProbeCom_StrInBuf,
    364                               (CPU_INT08U    *)&ProbeCom_StrInBufData[0],
    365                               (CPU_SIZE_T     ) PROBE_COM_CFG_STR_IN_BUF_SIZE);
    366          
    367              Mem_Clr((void     *)&ProbeCom_StrOutBufData[0],
    368                      (CPU_SIZE_T) PROBE_COM_CFG_STR_OUT_BUF_SIZE);
    369          
    370              ProbeCom_BufInit((PROBE_COM_BUF *)&ProbeCom_StrOutBuf,
    371                               (CPU_INT08U    *)&ProbeCom_StrOutBufData[0],
    372                               (CPU_SIZE_T     ) PROBE_COM_CFG_STR_OUT_BUF_SIZE);
    373          #endif
    374          
    375          
    376          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    377              ProbeCom_TerminalExecHandler   = (void        *)0;
    378              ProbeCom_TerminalExecuting     = (CPU_BOOLEAN  )DEF_NO;
    379          
    380              ProbeCom_TerminalInHandler     = (void        *)0;
    381          
    382              ProbeCom_TerminalOutBufPtr     = (CPU_INT08U  *)0;
    383              ProbeCom_TerminalOutBufIx      = (CPU_SIZE_T   )0;
    384              ProbeCom_TerminalOutBufLen     = (CPU_SIZE_T   )0;
    385          
    386              ok = ProbeCom_OS_Init();
    387          
    388              if (ok == DEF_FAIL) {
    389                  return (DEF_FAIL);
    390              }
    391          #endif
    392          
    393          
    394          #if (PROBE_COM_CFG_STAT_EN         == DEF_ENABLED)
    395              ProbeCom_RxPktCtr              =  0u;
    396              ProbeCom_TxPktCtr              =  0u;
    397          
    398              ProbeCom_TxSymCtr              =  0u;
    399              ProbeCom_TxSymByteCtr          =  0u;
    400              ProbeCom_ErrPktCtr             =  0u;
    401          
    402          #if (PROBE_COM_CFG_STR_REQ_EN      == DEF_ENABLED)
    403              ProbeCom_StrRxCtr              =  0u;
    404              ProbeCom_StrRxOvfErrCtr        =  0u;
    405          
    406              ProbeCom_StrTxCtr              =  0u;
    407              ProbeCom_StrTxOvfErrCtr        =  0u;
    408          #endif
    409          
    410          #if (PROBE_COM_CFG_WR_REQ_EN       == DEF_ENABLED)
    411              ProbeCom_RxSymCtr              =  0u;
    412              ProbeCom_RxSymByteCtr          =  0u;
    413          #endif
    414          #endif
    415          
    416              ProbeCom_EndiannessTest        =  0x12345678uL;
    417          
    418              return (DEF_OK);
    419          }
    420          
    421          
    422          /*
    423          *********************************************************************************************************
    424          *                                          ProbeCom_StrRd()
    425          *
    426          * Description : Read input data.
    427          *
    428          * Argument(s) : pdest       Pointer to the destination buffer.
    429          *
    430          *               len         Length of the destination buffer, in octets/characters.
    431          *
    432          * Return(s)   : Number of octets/characters read.
    433          *
    434          * Caller(s)   : Application.
    435          *
    436          * Note(s)     : (1) This function implements a non-blocking read.  It will read as much data as fits
    437          *                   into the buffer, up to 'len' bytes/characters.  The calling application should
    438          *                   monitor the return value to see if more data needs to be read.
    439          *
    440          *               (2) Since this function never blocks, it should not be called in a tight loop without a
    441          *                   delay.
    442          *
    443          *               (3) This function MAY be called from an ISR.
    444          *********************************************************************************************************
    445          */
    446          
    447          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    448          CPU_SIZE_T  ProbeCom_StrRd (CPU_CHAR    *pdest,
    449                                      CPU_SIZE_T   len)
    450          {
    451              CPU_SIZE_T  len_rd;
    452          
    453          
    454              len_rd = ProbeCom_BufRd((PROBE_COM_BUF *)&ProbeCom_StrInBuf,
    455                                      (CPU_INT08U    *) pdest,
    456                                      (CPU_SIZE_T     ) len);
    457          
    458              return (len_rd);
    459          }
    460          #endif
    461          
    462          
    463          /*
    464          *********************************************************************************************************
    465          *                                          ProbeCom_StrWr()
    466          *
    467          * Description : Write or buffer data for output.
    468          *
    469          * Argument(s) : psrc        Pointer to the source buffer.
    470          *
    471          *               len         Length of the source buffer, in octets/characters.
    472          *
    473          * Return(s)   : Number of octets/characters written or buffered.
    474          *
    475          * Caller(s)   : Application.
    476          *
    477          * Note(s)     : (1) This function implements a non-blocking write.  It will write as much data as fits
    478          *                   into the buffer, up to 'len' bytes/characters.  The calling application should
    479          *                   monitor the return value to see if more data from the buffer needs to be written.
    480          *
    481          *               (2) Since this function never blocks, it should not be called in a tight loop without a
    482          *                   delay.
    483          *
    484          *               (3) This function MAY be called from an ISR.
    485          *********************************************************************************************************
    486          */
    487          
    488          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    489          CPU_SIZE_T  ProbeCom_StrWr (CPU_CHAR    *psrc,
    490                                      CPU_SIZE_T   len)
    491          {
    492              CPU_SIZE_T  len_wr;
    493          
    494          
    495              len_wr = ProbeCom_BufWr((PROBE_COM_BUF *)&ProbeCom_StrOutBuf,
    496                                      (CPU_INT08U    *) psrc,
    497                                      (CPU_SIZE_T     ) len);
    498          
    499          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
    500              if (len_wr < len) {
    501                  ProbeCom_StrTxOvfErrCtr++;
    502              }
    503          #endif
    504          
    505              return (len_wr);
    506          }
    507          #endif
    508          
    509          
    510          /*
    511          *********************************************************************************************************
    512          *                                       ProbeCom_TerminalOut()
    513          *
    514          * Description : Output data over terminal.
    515          *
    516          * Argument(s) : psrc        Pointer to the source buffer.
    517          *
    518          *               len         Length of source buffer, in octets/characters.
    519          *
    520          * Return(s)   : Number of octets/characters output.
    521          *
    522          * Caller(s)   : Application.
    523          *
    524          * Note(s)     : (1) This function implements a blocking write.  It will queue the request and wait until
    525          *                   all of the data has been buffered or transmitted before returning.
    526          *
    527          *               (2) Terminal data may ONLY be output while a command is being executed.
    528          *
    529          *                   (a) Generic read/write functionality is provided by the string read/write functions
    530          *                       (see 'ProbeCom_StrRd()', 'ProbeCom_StrWr()').
    531          *
    532          *               (3) This function MUST NOT be called from an ISR.
    533          *********************************************************************************************************
    534          */
    535          
    536          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    537          CPU_SIZE_T  ProbeCom_TerminalOut (CPU_CHAR    *psrc,
    538                                            CPU_SIZE_T   len)
    539          {
    540              CPU_SR_ALLOC();
    541          
    542          
    543                                                                          /* ------------------- VALIDATE ARGS ------------------ */
    544              if (psrc == (CPU_CHAR *)0) {                                /* Validate NULL ptr.                                   */
    545                  return ((CPU_SIZE_T)0);
    546              }
    547          
    548              if (len == 0u) {                                            /* Validate NULL len.                                   */
    549                  return ((CPU_SIZE_T)0);
    550              }
    551          
    552          
    553          
    554                                                                          /* ------------------- START OUTPUT ------------------- */
    555              CPU_CRITICAL_ENTER();
    556              if (ProbeCom_TerminalExecuting == DEF_NO) {                 /* Chk if cmd exec'ing.                                 */
    557                  return ((CPU_SIZE_T)0);
    558              }
    559          
    560              if (ProbeCom_TerminalOutBufPtr != (CPU_INT08U *)0) {        /* Chk if out in progress.                              */
    561                  return ((CPU_SIZE_T)0);
    562              }
    563          
    564              ProbeCom_TerminalOutBufPtr = (CPU_INT08U *)psrc;            /* Schedule output.                                     */
    565              ProbeCom_TerminalOutBufIx  = (CPU_SIZE_T  )0;
    566              ProbeCom_TerminalOutBufLen = (CPU_SIZE_T  )len;
    567          
    568              ProbeCom_OS_TerminalOutWait();                              /* Wait for output completion.                          */
    569          
    570              ProbeCom_TerminalOutBufPtr = (CPU_INT08U *)0;
    571              ProbeCom_TerminalOutBufIx  = (CPU_SIZE_T  )0;
    572              ProbeCom_TerminalOutBufLen = (CPU_SIZE_T  )0;
    573              CPU_CRITICAL_EXIT();
    574          
    575          
    576          
    577                                                                          /* ----------------------- RTN ------------------------ */
    578              return (len);
    579          }
    580          #endif
    581          
    582          
    583          /*
    584          *********************************************************************************************************
    585          *                                   ProbeCom_TerminalExecComplete()
    586          *
    587          * Description : Signal completion of command execution.
    588          *
    589          * Argument(s) : none.
    590          *
    591          * Return(s)   : The number of bytes in the data segment of the packet to transmit in response.
    592          *
    593          * Caller(s)   : Application.
    594          *
    595          * Note(s)     : none.
    596          *********************************************************************************************************
    597          */
    598          
    599          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    600          void  ProbeCom_TerminalExecComplete (void)
    601          {
    602              CPU_BOOLEAN  executing;
    603              CPU_SR_ALLOC();
    604          
    605          
    606              CPU_CRITICAL_ENTER();
    607              executing = ProbeCom_TerminalExecuting;
    608              if (executing == DEF_YES) {
    609                  ProbeCom_TerminalExecuting = DEF_NO;
    610              }
    611              CPU_CRITICAL_EXIT()
    612          }
    613          #endif
    614          
    615          
    616          /*
    617          *********************************************************************************************************
    618          *                                     ProbeCom_TerminalExecSet()
    619          *
    620          * Description : Set the handler that will be invoked to process a terminal command.
    621          *
    622          * Argument(s) : handler         The handler that will be invoked.
    623          *
    624          * Return(s)   : none.
    625          *
    626          * Caller(s)   : Application.
    627          *
    628          * Note(s)     : (1) The handler should be a function with the following prototype:
    629          *
    630          *                       void  App_TerminalExecFnct (CPU_CHAR    *pstr,
    631          *                                                   CPU_SIZE_T   len);
    632          *
    633          *                   where 'pstr' is a pointer to the command string, and 'len' is the length of the
    634          *                   command string (in characters) excluding the final NULL byte.  The command string
    635          *                   will NOT include a terminating new line or line feed.
    636          *********************************************************************************************************
    637          */
    638          
    639          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    640          void  ProbeCom_TerminalExecSet (PROBE_COM_TERMINAL_EXEC_FNCT  handler)
    641          {
    642              CPU_SR_ALLOC();
    643          
    644          
    645              CPU_CRITICAL_ENTER();
    646              ProbeCom_TerminalExecHandler = handler;
    647              CPU_CRITICAL_EXIT();
    648          }
    649          #endif
    650          
    651          
    652          /*
    653          *********************************************************************************************************
    654          *                                      ProbeCom_TerminalInSet()
    655          *
    656          * Description : Set the handler that will be invoked to process terminal input.
    657          *
    658          * Argument(s) : handler         The handler that will be invoked.
    659          *
    660          * Return(s)   : none.
    661          *
    662          * Caller(s)   : Application.
    663          *
    664          * Note(s)     : (1) The handler should be a function with the following prototype:
    665          *
    666          *                       void  App_TerminalInFnct (CPU_CHAR    *pstr,
    667          *                                                 CPU_SIZE_T   len);
    668          *
    669          *                   where 'pstr' is a pointer to the input string, and 'len' is the length of the input
    670          *                   string (in characters) excluding the final NULL byte.  The input string will NOT
    671          *                   include a terminating new line or line feed.
    672          *********************************************************************************************************
    673          */
    674          
    675          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    676          void  ProbeCom_TerminalInSet (PROBE_COM_TERMINAL_IN_FNCT  handler)
    677          {
    678          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
    679              CPU_SR  cpu_sr;
    680          #endif
    681          
    682          
    683              CPU_CRITICAL_ENTER();
    684              ProbeCom_TerminalInHandler = handler;
    685              CPU_CRITICAL_EXIT();
    686          }
    687          #endif
    688          
    689          
    690          /*
    691          *********************************************************************************************************
    692          *                                        ProbeCom_ParseRxPkt()
    693          *
    694          * Description : Parse a packet & formulate a response.
    695          *
    696          * Argument(s) : prx_pkt         Pointer to the receive  packet buffer
    697          *
    698          *               ptx_pkt         Pointer to the transmit packet buffer
    699          *
    700          *               rx_pkt_size     Size of the received packet
    701          *
    702          *               tx_pkt_size     Size of the transmit packet buffer
    703          *
    704          * Return(s)   : The number of bytes in the data segment of the packet to transmit in response.
    705          *
    706          * Caller(s)   : Tasks/receive handlers in communications-specific drivers, (e.g., probe_rs232,
    707          *               probe_usb, probe_tcpip, etc.).
    708          *
    709          * Note(s)     : none.
    710          *********************************************************************************************************
    711          */
    712          
    713          CPU_SIZE_T  ProbeCom_ParseRxPkt (void        *prx_pkt,
    714                                           void        *ptx_pkt,
    715                                           CPU_SIZE_T   rx_pkt_size,
    716                                           CPU_SIZE_T   tx_buf_size)
    717          {
    718              CPU_SIZE_T   tx_buf_wr;
    719              CPU_INT16U   format;
    720              CPU_INT08U  *prx_pkt_08;
    721              CPU_INT08U  *ptx_pkt_08;
    722          
    723          
    724              if (rx_pkt_size < 2u) {
    725                  return (0);
    726              }
    727          
    728              prx_pkt_08  = (CPU_INT08U *)prx_pkt;
    729              ptx_pkt_08  = (CPU_INT08U *)ptx_pkt;
    730              format      = (prx_pkt_08[1] << 8) + prx_pkt_08[0];
    731              prx_pkt_08 += 2u;
    732          
    733          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
    734              ProbeCom_RxPktCtr++;
    735              ProbeCom_TxPktCtr++;
    736          #endif
    737          
    738              switch (format) {
    739                  case PROBE_COM_FMT_RX_QUERY:
    740                       tx_buf_wr = ProbeCom_ReqQuery(       prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    741                       break;
    742          
    743                  case PROBE_COM_FMT_RX_RD:
    744                       tx_buf_wr = ProbeCom_ReqRd(          prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    745                       break;
    746          
    747                  case PROBE_COM_FMT_RX_RD_MULTI:
    748                       tx_buf_wr = ProbeCom_ReqRdMulti(     prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    749                       break;
    750          
    751          #if (PROBE_COM_CFG_WR_REQ_EN == DEF_ENABLED)
    752                  case PROBE_COM_FMT_RX_WR:
    753                       tx_buf_wr = ProbeCom_ReqWr(          prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    754                       break;
    755          
    756                  case PROBE_COM_FMT_RX_WR_MULTI:
    757                       tx_buf_wr = ProbeCom_ReqWrMulti(     prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    758                       break;
    759          #endif
    760          
    761          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    762                  case PROBE_COM_FMT_RX_STR_IN:
    763                       tx_buf_wr = ProbeCom_ReqStrIn(       prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    764                       break;
    765          
    766                  case PROBE_COM_FMT_RX_STR_OUT:
    767                       tx_buf_wr = ProbeCom_ReqStrOut(      prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    768                       break;
    769          #endif
    770          
    771          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    772                  case PROBE_COM_FMT_RX_TERMINAL_EXEC:
    773                       tx_buf_wr = ProbeCom_ReqTerminalExec(prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    774                       break;
    775          
    776                  case PROBE_COM_FMT_RX_TERMINAL_IN:
    777                       tx_buf_wr = ProbeCom_ReqTerminalIn(  prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    778                       break;
    779          
    780                  case PROBE_COM_FMT_RX_TERMINAL_OUT:
    781                       tx_buf_wr = ProbeCom_ReqTerminalOut( prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    782                       break;
    783          #endif
    784          
    785                  default:
    786                       tx_buf_wr = ProbeCom_ReqErr(                     ptx_pkt_08, PROBE_COM_STATUS_UNKNOWN_REQUEST);
    787                       break;
    788              }
    789          
    790              return (tx_buf_wr);
    791          }
    792          
    793          
    794          /*
    795          *********************************************************************************************************
    796          *********************************************************************************************************
    797          *                                           LOCAL FUNCTIONS
    798          *********************************************************************************************************
    799          *********************************************************************************************************
    800          */
    801          
    802          /*
    803          *********************************************************************************************************
    804          *                                       ProbeCom_StrOutAvail()
    805          *
    806          * Description : Check if string output is waiting for transmission.
    807          *
    808          * Argument(s) : none.
    809          *
    810          * Return(s)   : DEF_TRUE   if a  string output is waiting for transmission.
    811          *               DEF_FALSE  if no string output is waiting for transmission.
    812          *
    813          * Caller(s)   : ProbeCom_PktModifier().
    814          *
    815          * Note(s)     : (1) See Notes for 'ProbeCom_StrWr()'.
    816          *********************************************************************************************************
    817          */
    818          
    819          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    820          static  CPU_BOOLEAN  ProbeCom_StrOutAvail (void)
    821          {
    822              CPU_BOOLEAN  avail;
    823              CPU_BOOLEAN  empty;
    824          
    825          
    826              empty = ProbeCom_BufIsEmpty(&ProbeCom_StrOutBuf);
    827              avail = (empty == DEF_YES) ? (DEF_FALSE) : (DEF_TRUE);
    828          
    829              return (avail);
    830          }
    831          #endif
    832          
    833          
    834          
    835          /*
    836          *********************************************************************************************************
    837          *                                     ProbeCom_TerminalOutAvail()
    838          *
    839          * Description : Check if terminal output is waiting for transmission.
    840          *
    841          * Argument(s) : none.
    842          *
    843          * Return(s)   : DEF_TRUE   if a  terminal output is waiting for transmission.
    844          *               DEF_FALSE  if no terminal output is waiting for transmission.
    845          *
    846          * Caller(s)   : ProbeCom_PktModifier().
    847          *
    848          * Note(s)     : (1) See Notes for 'ProbeCom_TerminalOut()'.
    849          *********************************************************************************************************
    850          */
    851          
    852          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    853          static  CPU_BOOLEAN  ProbeCom_TerminalOutAvail (void)
    854          {
    855              CPU_SIZE_T   buf_len;
    856              CPU_BOOLEAN  avail;
    857              CPU_SR_ALLOC();
    858          
    859          
    860              CPU_CRITICAL_ENTER();
    861              buf_len = ProbeCom_TerminalOutBufLen;
    862              CPU_CRITICAL_EXIT();
    863          
    864              avail   = (buf_len == 0u) ? (DEF_FALSE) : (DEF_TRUE);
    865          
    866              return (avail);
    867          }
    868          #endif
    869          
    870          
    871          
    872          /*
    873          *********************************************************************************************************
    874          *                                     ProbeCom_TerminalExecDone()
    875          *
    876          * Description : Check if terminal execution is done.
    877          *
    878          * Argument(s) : none.
    879          *
    880          * Return(s)   : DEF_TRUE   if terminal command execution is     done.
    881          *               DEF_FALSE  if terminal command execution is NOT done.
    882          *
    883          * Caller(s)   : ProbeCom_PktModifier().
    884          *
    885          * Note(s)     : (1) See Notes for 'ProbeCom_TerminalOut()'.
    886          *********************************************************************************************************
    887          */
    888          
    889          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    890          static  CPU_BOOLEAN  ProbeCom_TerminalExecDone (void)
    891          {
    892          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
    893              CPU_SR       cpu_sr;
    894          #endif
    895              CPU_BOOLEAN  executing;
    896              CPU_BOOLEAN  done;
    897          
    898          
    899              CPU_CRITICAL_ENTER();
    900              executing = ProbeCom_TerminalExecuting;
    901              CPU_CRITICAL_EXIT();
    902          
    903              done = (executing == DEF_YES) ? (DEF_FALSE) : (DEF_TRUE);
    904          
    905              return (done);
    906          }
    907          #endif
    908          
    909          
    910          /*
    911          *********************************************************************************************************
    912          *                                       ProbeCom_PktModifier()
    913          *
    914          * Description : Get packet modfier byte.
    915          *
    916          * Argument(s) : none.
    917          *
    918          * Return(s)   : The modifier byte.
    919          *
    920          * Caller(s)   : Various command handlers (ProbeCom_Req????()).
    921          *
    922          * Note(s)     : none.
    923          *********************************************************************************************************
    924          */
    925          
    926          static  CPU_INT08U  ProbeCom_PktModifier (void)
    927          {
    928          #if ((PROBE_COM_CFG_STR_REQ_EN      == DEF_ENABLED) || \
    929               (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED))
    930              CPU_BOOLEAN  avail;
    931          #endif
    932          #if  (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    933              CPU_BOOLEAN  done;
    934          #endif
    935              CPU_INT08U   mod;
    936          
    937          
    938              mod = PROBE_COM_MODIFIER_NONE;
    939          
    940          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    941              avail = ProbeCom_StrOutAvail();
    942              if (avail == DEF_TRUE) {
    943                  DEF_BIT_SET(mod, PROBE_COM_MODIFIER_STR_OUT_AVAIL);
    944              }
    945          #endif
    946          
    947          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    948              avail = ProbeCom_TerminalOutAvail();
    949              if (avail == DEF_TRUE) {
    950                  DEF_BIT_SET(mod, PROBE_COM_MODIFIER_TERMINAL_OUT_AVAIL);
    951              }
    952          
    953              done = ProbeCom_TerminalExecDone();
    954              if (done == DEF_TRUE) {
    955                  DEF_BIT_SET(mod, PROBE_COM_MODIFIER_TERMINAL_EXEC_DONE);
    956              }
    957          #endif
    958          
    959              return (mod);
    960          }
    961          
    962          
    963          /*
    964          *********************************************************************************************************
    965          *                                          ProbeCom_ReqErr()
    966          *
    967          * Description : Formulate error response when the target receives a request it cannot handle.
    968          *
    969          * Argument(s) : ptx_buf      Pointer to the transmit buffer
    970          *
    971          *               comm_err     Error that occurred
    972          *
    973          * Return(s)   : The number of bytes written to the tx buffer.
    974          *
    975          * Caller(s)   : Various command handlers (ProbeCom_Req????()).
    976          *
    977          * Note(s)     : (1) The TX format:
    978          *
    979          *                   (A) A 2-byte format  , indicating the data segment format;
    980          *                   (B) A 1-byte constant, PROBE_RS232_OK,   if the location can    be read;
    981          *                       A 1-byte constant, PROBE_RS232_FAIL, if the location cannot be read.
    982          *                   (C) A 1-byte modifier.
    983          *
    984          *                         +-------------------------+------------+------------+
    985          *                         |          Format         |   Status   |  Modifier  |
    986          *                         +-------------------------+------------+------------+
    987          *********************************************************************************************************
    988          */
    989          
    990          static  CPU_SIZE_T  ProbeCom_ReqErr (CPU_INT08U  *ptx_buf,
    991                                               CPU_INT08U   comm_err)
    992          {
    993              CPU_SIZE_T  tx_len;
    994          
    995          
    996          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
    997              ProbeCom_ErrPktCtr++;
    998          #endif
    999          
   1000              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_ERR);         /* Tx pkt fmt.                                          */
   1001              ProbeCom_StoINT08U(&ptx_buf, comm_err);                     /* Target status.                                       */
   1002              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* Modifier.                                            */
   1003          
   1004              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;
   1005              return (tx_len);                                            /* Rtn TX data segment size =  4 (= Tx hdr size).       */
   1006          }
   1007          
   1008          
   1009          /*
   1010          *********************************************************************************************************
   1011          *                                         ProbeCom_ReqQuery()
   1012          *
   1013          * Description : Parse the FMT_QUERY command & formulate response.  This command asks the target
   1014          *               about its capabilities, which are returned in response.
   1015          *
   1016          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1017          *
   1018          *               ptx_buf         Pointer to the transmit buffer
   1019          *
   1020          *               rx_pkt_size     Size of the receive  packet
   1021          *
   1022          *               tx_buf_size     Size of the transmit buffer
   1023          *
   1024          * Return(s)   : The number of bytes written to the tx buffer.
   1025          *
   1026          * Caller(s)   : ProbeCom_ParseRxPkt().
   1027          *
   1028          * Note(s)     : (1) The RX format:
   1029          *
   1030          *                   (A) A 2-byte format, indicating the data segment format;
   1031          *                   (B) A 2-byte query , indicating the query type.
   1032          *
   1033          *                         +-------------------------+-------------------------+
   1034          *                         |          Format         |          Query          |
   1035          *                         +-------------------------+-------------------------+
   1036          *
   1037          *              (2) The TX format:
   1038          *
   1039          *                   (A) A 2-byte format, indicating the data segment format;
   1040          *                   (B) A 1-byte status, indicating the status after the request;
   1041          *                   (C) A 1-byte modifier;
   1042          *                   (E) A n-byte answer, the answer to the query.
   1043          *
   1044          *                         +-------------------------+------------+------------+
   1045          *                         |          Format         |   Status   |  Modifier  |
   1046          *                         +-------------------------+------------+------------+
   1047          *                         |                       Answer                      |
   1048          *                         |                         .                         |
   1049          *                         |                         .                         |
   1050          *                         |                         .                         |
   1051          *                         +---------------------------------------------------+
   1052          *
   1053          *********************************************************************************************************
   1054          */
   1055          
   1056          static  CPU_SIZE_T  ProbeCom_ReqQuery (CPU_INT08U  *prx_buf,
   1057                                                 CPU_INT08U  *ptx_buf,
   1058                                                 CPU_SIZE_T   rx_pkt_size,
   1059                                                 CPU_SIZE_T   tx_buf_size)
   1060          {
   1061              CPU_INT16U  query;
   1062              CPU_INT32U  status;
   1063              CPU_SIZE_T  tx_len;
   1064              CPU_INT32U  version;
   1065          
   1066          
   1067             (void)&tx_buf_size;                                          /* Prevent compiler warning.                            */
   1068          
   1069                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1070                                                                          /* Expected size =  2 (= Rx hdr size)                   */
   1071                                                                          /*               +  2 (= Query      ).                  */
   1072              if (rx_pkt_size != 4u) {
   1073                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1074                  return (tx_len);
   1075              }
   1076          
   1077                                                                          /* ------------------- HANDLE QUERY ------------------- */
   1078              query = ProbeCom_GetINT16U(&prx_buf);                       /* Rd the query.                                        */
   1079          
   1080              switch (query) {                                            /* Determine if query is supported.                     */
   1081                  case PROBE_COM_QUERY_MAX_RX_SIZE:
   1082                  case PROBE_COM_QUERY_MAX_TX_SIZE:
   1083                  case PROBE_COM_QUERY_FMT_SUPPORT:
   1084                  case PROBE_COM_QUERY_ENDIANNESS_TEST:
   1085                  case PROBE_COM_QUERY_STATUS:
   1086                  case PROBE_COM_QUERY_VERSION:
   1087                       break;
   1088          
   1089                  default:
   1090                       tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_QUERY_NOT_SUPPORTED);
   1091                       return (tx_len);
   1092              }
   1093          
   1094                                                                          /* Sto tx pkt hdr :                                     */
   1095              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_QUERY);       /*  (a) TX pkt fmt.                                     */
   1096              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /*  (b) Target status.                                  */
   1097              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /*  (c) Modifier.                                       */
   1098          
   1099                                                                          /* Sto tx data segment data.                            */
   1100              switch (query) {
   1101                  case PROBE_COM_QUERY_MAX_RX_SIZE:
   1102                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_CFG_RX_MAX_SIZE);
   1103                       ProbeCom_StoINT16U(&ptx_buf, 0);
   1104                       tx_len  = 4u;
   1105                       break;
   1106          
   1107          
   1108                  case PROBE_COM_QUERY_MAX_TX_SIZE:
   1109                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_CFG_TX_MAX_SIZE);
   1110                       ProbeCom_StoINT16U(&ptx_buf, 0);
   1111                       tx_len  = 4u;
   1112                       break;
   1113          
   1114          
   1115                  case PROBE_COM_QUERY_FMT_SUPPORT:
   1116                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_QUERY);
   1117                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_RD);
   1118                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_RD_MULTI);
   1119                       tx_len  = 8u;
   1120          #if (PROBE_COM_CFG_WR_REQ_EN == DEF_ENABLED)
   1121                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_WR);
   1122                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_WR_MULTI);
   1123                       tx_len += 4u;
   1124          #endif
   1125          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
   1126                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_STR_IN);
   1127                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_STR_OUT);
   1128                       tx_len += 4u;
   1129          #endif
   1130          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
   1131                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_TERMINAL_EXEC);
   1132                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_TERMINAL_IN);
   1133                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_TERMINAL_OUT);
   1134                       tx_len += 6u;
   1135          #endif
   1136                       break;
   1137          
   1138          
   1139                  case PROBE_COM_QUERY_ENDIANNESS_TEST:
   1140                       ProbeCom_EndiannessTest = 0x12345678;
   1141                       Mem_Copy((void     *) ptx_buf,
   1142                                (void     *)&ProbeCom_EndiannessTest,
   1143                                (CPU_SIZE_T) 4);
   1144                       tx_len  = 4u;
   1145                       break;
   1146          
   1147          
   1148                  case PROBE_COM_QUERY_STATUS:
   1149                       status = (CPU_INT32U)ProbeCom_PktModifier();
   1150                       Mem_Copy((void     *) ptx_buf,
   1151                                (void     *)&status,
   1152                                (CPU_SIZE_T) 4);
   1153                       tx_len = 4u;
   1154                       break;
   1155          
   1156          
   1157                  case PROBE_COM_QUERY_VERSION:
   1158                       version = PROBE_COM_VERSION;
   1159                       Mem_Copy((void     *) ptx_buf,
   1160                                (void     *)&version,
   1161                                (CPU_SIZE_T) 4);
   1162                       tx_len  = 4u;
   1163                       break;
   1164          
   1165          
   1166                  default:
   1167                       tx_len  = 0u;
   1168                       break;
   1169              }
   1170          
   1171                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1172              tx_len += PROBE_COM_SIZE_TX_HDR;
   1173              return (tx_len);                                            /* TX pkt size = nbytes (= Tx data size)                */
   1174                                                                          /*             + 4      (= Tx hdr  size).               */
   1175          }
   1176          
   1177          
   1178          /*
   1179          *********************************************************************************************************
   1180          *                                          ProbeCom_ReqRd()
   1181          *
   1182          * Description : Parse the FMT_RD request & formulate response.  This command causes the target to send
   1183          *               data read from its memory for a certain {memory address, data length} pair (which is
   1184          *               given in the request).
   1185          *
   1186          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1187          *
   1188          *               ptx_buf         Pointer to the transmit buffer
   1189          *
   1190          *               rx_pkt_size     Size of the receive  packet
   1191          *
   1192          *               tx_buf_size     Size of the transmit buffer
   1193          *
   1194          * Return(s)   : The number of bytes written to the tx buffer.
   1195          *
   1196          * Caller(s)   : ProbeCom_ParseRxPkt().
   1197          *
   1198          * Note(s)     : (1) The RX format:
   1199          *
   1200          *                   (A) A 2-byte format , indicating the data segment format;
   1201          *                   (B) A 2-byte length , indicating the number of bytes to read;
   1202          *                   (C) A 4-byte address, the starting address of the data to read.
   1203          *
   1204          *                         +-------------------------+-------------------------+
   1205          *                         |          Format         |     Number of bytes     |
   1206          *                         +-------------------------+-------------------------+
   1207          *                         |                      Address                      |
   1208          *                         +-------------------------+-------------------------+
   1209          *
   1210          *               (2) The TX format:
   1211          *
   1212          *                   (A) A 2-byte format, indicating the data segment format;
   1213          *                   (B) A 1-byte status, indicating the status after the request;
   1214          *                   (C) A 1-byte modifier;
   1215          *                   (D) The memory data.
   1216          *
   1217          *                         +-------------------------+------------+------------+
   1218          *                         |          Format         |   Status   |  Modifier  |
   1219          *                         +-------------------------+------------+------------+
   1220          *                         |                        Data                       |
   1221          *                         |                         .                         |
   1222          *                         |                         .                         |
   1223          *                         |                         .                         |
   1224          *                         +---------------------------------------------------+
   1225          *
   1226          *********************************************************************************************************
   1227          */
   1228          
   1229          static  CPU_SIZE_T  ProbeCom_ReqRd (CPU_INT08U  *prx_buf,
   1230                                              CPU_INT08U  *ptx_buf,
   1231                                              CPU_SIZE_T   rx_pkt_size,
   1232                                              CPU_SIZE_T   tx_buf_size)
   1233          {
   1234              CPU_ADDR    sym_addr;
   1235              CPU_SIZE_T  sym_size;
   1236              CPU_SIZE_T  tx_len;
   1237          
   1238          
   1239                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1240                                                                          /* Expected size = 2 (= Rx hdr size )                   */
   1241                                                                          /*               + 2 (= Sym size    )                   */
   1242                                                                          /*               + 4 (= Sym addr    ).                  */
   1243              if (rx_pkt_size != 8u) {
   1244                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1245                  return (tx_len);
   1246              }
   1247          
   1248          
   1249                                                                          /* -------------------- HANDLE RD --------------------- */
   1250              sym_size = ProbeCom_GetINT16U(&prx_buf);                    /* Get nbr of bytes to rd.                              */
   1251          
   1252                                                                          /* Get rd addr.                                         */
   1253          #if ((!defined(CPU_CFG_ADDR_SIZE)) || \
   1254               ((defined(CPU_CFG_ADDR_SIZE)) && \
   1255                        (CPU_CFG_ADDR_SIZE   != CPU_WORD_SIZE_16)))
   1256              sym_addr = (CPU_ADDR)ProbeCom_GetINT32U(&prx_buf);
   1257          #else
   1258              sym_addr = (CPU_ADDR)ProbeCom_GetINT16U(&prx_buf);
   1259          #endif
   1260          
   1261              if (sym_size + PROBE_COM_SIZE_TX_HDR > tx_buf_size) {       /* If tx pkt will NOT fit in buf, rtn err.              */
   1262                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_TX_PKT_TOO_LARGE);
   1263                  return (tx_len);
   1264              }
   1265          
   1266          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1267              ProbeCom_TxSymCtr++;                                        /* Inc tx sym ctr.                                      */
   1268              ProbeCom_TxSymByteCtr += sym_size;
   1269          #endif
   1270          
   1271                                                                          /* Store tx pkt hdr :                                   */
   1272              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_RD);          /*  (a) Tx pkt fmt.                                     */
   1273              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /*  (b) Target status.                                  */
   1274              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /*  (c) Modifier.                                       */
   1275          
   1276              Mem_Copy((void     *)ptx_buf,                               /* Save tx data segment data.                           */
   1277                       (void     *)sym_addr,
   1278                       (CPU_SIZE_T)sym_size);
   1279          
   1280                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1281              tx_len = sym_size + PROBE_COM_SIZE_TX_HDR;
   1282              return (tx_len);                                            /* Tx pkt size = nbytes (= Tx data   size)              */
   1283                                                                          /*             + 4      (= Tx header size).             */
   1284          }
   1285          
   1286          
   1287          /*
   1288          *********************************************************************************************************
   1289          *                                        ProbeCom_ReqRdMulti()
   1290          *
   1291          * Description : Parse the FMT_RD_MULTI request & formulate respnse.  This command causes the target to
   1292          *               send data read from its memory for a certain set of {memory address, data length} pairs
   1293          *               (which are given in the request).
   1294          *
   1295          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1296          *
   1297          *               ptx_buf         Pointer to the transmit buffer
   1298          *
   1299          *               rx_pkt_size     Size of the receive  packet
   1300          *
   1301          *               tx_buf_size     Size of the transmit buffer
   1302          *
   1303          * Return(s)   : The number of bytes written to the tx buffer.
   1304          *
   1305          * Caller(s)   : ProbeCom_ParseRxPkt().
   1306          *
   1307          * Note(s)     : (1) The RX format:
   1308          *
   1309          *                   (A) A 2-byte format,          indicating the data segment format;
   1310          *                   (B) A 5-byte item descriptor, for each item in the list, consisting of:
   1311          *
   1312          *                       (1) A 4-byte address, the starting address of the data to read;
   1313          *                       (2) A 1-byte length,  indicating the number of bytes to read.
   1314          *
   1315          *                         +-------------------------+------------+------------+
   1316          *                         |          Format         | Num. bytes |         Addr       ---
   1317          *                         +-------------------------+------------+------------+        |    Item 1
   1318          *                         ress                                   | Num. bytes |       ---
   1319          *                         +--------------------------------------+------------+        |
   1320          *                         |                      Address                      |        |    Item 2
   1321          *                         +------------+--------------------------------------+       ---
   1322          *                         | Num. bytes |                                   Addr        |    Item 3
   1323          *                         +------------+--------------------------------------+        .
   1324          *                         |                         .                         |        .
   1325          *                         |                         .                         |        .
   1326          *                         |                         .                         |        .
   1327          *                         |                         .                         |        .
   1328          *                         +--------------------------------------+------------+        .
   1329          *                         ress                                   | Num. bytes |       ---
   1330          *                         ---------------------------------------+------------+        |   Item n
   1331          *                         |                      Address                      |        |
   1332          *                         +---------------------------------------------------+       ---
   1333          *
   1334          *               (2) The TX format:
   1335          *
   1336          *                   (A) A 2-byte format, indicating the data segment format;
   1337          *                   (B) A 1-byte status, indicating the status after the request;
   1338          *                   (C) A 1-byte modifier;
   1339          *                   (D) For each item, the following is sent:
   1340          *
   1341          *                       (1) The memory data.
   1342          *
   1343          *                         +-------------------------+------------+------------+
   1344          *                         |          Format         |   Status   |  Modifier  |
   1345          *                         +-------------------------+------------+------------+       ---
   1346          *                         |                        Data                       |        |    Item 1
   1347          *                         |                         .                         |        |
   1348          *                         |                         .                         |        |
   1349          *                         |                         .                         |        |
   1350          *                         +---------------------------------------------------+       ---
   1351          *                         |                         .                         |        .
   1352          *                         |                         .                         |        .
   1353          *                         |                         .                         |        .
   1354          *                         |                         .                         |        .
   1355          *                         |                         .                         |        .
   1356          *                         +---------------------------------------------------+       ---
   1357          *                         |                        Data                       |        |    Item n
   1358          *                         |                         .                         |        |
   1359          *                         |                         .                         |        |
   1360          *                         |                         .                         |        |
   1361          *                         +---------------------------------------------------+       ---
   1362          *
   1363          *********************************************************************************************************
   1364          */
   1365          
   1366          static  CPU_SIZE_T  ProbeCom_ReqRdMulti (CPU_INT08U  *prx_buf,
   1367                                                   CPU_INT08U  *ptx_buf,
   1368                                                   CPU_SIZE_T   rx_pkt_size,
   1369                                                   CPU_SIZE_T   tx_buf_size)
   1370          {
   1371              CPU_SIZE_T   rx_pkt_ix;
   1372          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1373              CPU_INT32U   sym_byte_ctr;
   1374              CPU_INT32U   sym_ctr;
   1375          #endif
   1376              CPU_ADDR     sym_addr;
   1377              CPU_SIZE_T   sym_size;
   1378              CPU_SIZE_T   tx_len;
   1379              CPU_INT08U  *ptx_buf_start;
   1380          
   1381          
   1382                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1383                                                                          /* Expected size >= 2 (= Rx hdr size)                   */
   1384                                                                          /*                + 5 (= 1 item desc).                  */
   1385              if (rx_pkt_size  < 7u) {
   1386                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1387                  return (tx_len);
   1388              }
   1389          
   1390                                                                          /* -------------------- HANDLE RD --------------------- */
   1391              ptx_buf_start = ptx_buf;                                    /* Save ptr to tx buf in case pkt is too long for buf.  */
   1392              tx_len        = PROBE_COM_SIZE_TX_HDR;                      /* Init tx pkt len = 4 = size of hdr.                   */
   1393          
   1394                                                                          /* Store TX pkt hdr :                                   */
   1395              ptx_buf[0]    = PROBE_COM_FMT_TX_RD_MULTI_LO;               /* (a) TX pkt fmt.                                      */
   1396              ptx_buf[1]    = PROBE_COM_FMT_TX_RD_MULTI_HI;
   1397              ptx_buf[2]    = PROBE_COM_STATUS_OK;                        /* (b) Target status.                                   */
   1398              ptx_buf[3]    = ProbeCom_PktModifier();                     /* (c) Modifier.                                        */
   1399              ptx_buf      += PROBE_COM_SIZE_TX_HDR;
   1400          
   1401              rx_pkt_ix     = 7u;                                         /* Tx pkt ix after 1st item = 2 (= Rx hdr size)         */
   1402                                                                          /*                          + 5 (= 1 item desc).        */
   1403          
   1404          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1405              sym_ctr      = 0;
   1406              sym_byte_ctr = 0;
   1407          #endif
   1408                                                                          /* Sto data for each item.                              */
   1409              while (rx_pkt_ix <= rx_pkt_size) {
   1410                  sym_size   =  prx_buf[0];                               /* (a) Get nbr of bytes to rd.                          */
   1411          
   1412                                                                          /* (b) Get rd addr.                                     */
   1413          #if ((!defined(CPU_CFG_ADDR_SIZE)) || \
   1414               ((defined(CPU_CFG_ADDR_SIZE)) && \
   1415                        (CPU_CFG_ADDR_SIZE   != CPU_WORD_SIZE_16)))
   1416                  sym_addr   = ((CPU_ADDR)prx_buf[4] << 8) + prx_buf[3];
   1417                  sym_addr   = ((CPU_ADDR)sym_addr   << 8) + prx_buf[2];
   1418                  sym_addr   = ((CPU_ADDR)sym_addr   << 8) + prx_buf[1];
   1419          #else
   1420                  sym_addr   = ((CPU_ADDR)prx_buf[2] << 8) + prx_buf[1];
   1421          #endif
   1422          
   1423                  prx_buf   += 5u;
   1424                  rx_pkt_ix += 5u;
   1425          
   1426                  tx_len    += sym_size;                                  /* (c) Add nbr of bytes to pkt len.                     */
   1427          
   1428                  if (tx_len > tx_buf_size) {                             /* (d) Will pkt be too long for TX buf? ...             */
   1429                      ptx_buf = ptx_buf_start;                            /*     ... rtn err.                                     */
   1430                      tx_len  = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_TX_PKT_TOO_LARGE);
   1431                      return (tx_len);
   1432                  }
   1433          
   1434          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1435                  sym_ctr++;                                              /* (e) Inc local sym ctr.                               */
   1436                  sym_byte_ctr += sym_size;
   1437          #endif
   1438                                                                          /* (f) Otherwise, save TX data.                         */
   1439                  Mem_Copy((void     *)ptx_buf,
   1440                           (void     *)sym_addr,
   1441                           (CPU_SIZE_T)sym_size);
   1442          
   1443                  ptx_buf += sym_size;
   1444              }
   1445          
   1446          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1447              ProbeCom_TxSymCtr     += sym_ctr;                           /* Inc global sym ctr.                                  */
   1448              ProbeCom_TxSymByteCtr += sym_byte_ctr;
   1449          #endif
   1450          
   1451                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1452              return (tx_len);
   1453          }
   1454          
   1455          
   1456          /*
   1457          *********************************************************************************************************
   1458          *                                          ProbeCom_ReqWr()
   1459          *
   1460          * Description : Parse the FMT_WR request & formulate response.  This command causes the target to write
   1461          *               into its memory data from a certain {memory address, data length, data} triplet which is
   1462          *               given in the request.
   1463          *
   1464          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1465          *
   1466          *               ptx_buf         Pointer to the transmit buffer
   1467          *
   1468          *               rx_pkt_size     Size of the receive  packet
   1469          *
   1470          *               tx_buf_size     Size of the transmit buffer
   1471          *
   1472          * Return(s)   : The number of bytes written to the tx buffer.
   1473          *
   1474          * Caller(s)   : ProbeCom_ParseRxPkt().
   1475          *
   1476          * Note(s)     : (1) The RX format:
   1477          *
   1478          *                   (A) A 2-byte format,  indicating the data segment format;
   1479          *                   (B) A 2-byte length,  indicating the number of bytes to write;
   1480          *                   (C) A 4-byte address, the starting address at which the data should be written;
   1481          *                   (D) The memory data.
   1482          *
   1483          *                         +-------------------------+-------------------------+
   1484          *                         |          Format         |      Number of bytes    |
   1485          *                         +-------------------------+-------------------------+
   1486          *                         |                      Address                      |
   1487          *                         +---------------------------------------------------+
   1488          *                         |                        Data                       |
   1489          *                         |                         .                         |
   1490          *                         |                         .                         |
   1491          *                         |                         .                         |
   1492          *                         +---------------------------------------------------+
   1493          *
   1494          *               (2) The TX format:
   1495          *
   1496          *                   (A) A 2-byte format, indicating the data segment format;
   1497          *                   (B) A 1-byte status, indicating the status after the request;
   1498          *                   (C) A 1-byte modifier.
   1499          *
   1500          *                         +-------------------------+------------+------------+
   1501          *                         |          Format         |   Status   |  Modifier  |
   1502          *                         +-------------------------+------------+------------+
   1503          *
   1504          *********************************************************************************************************
   1505          */
   1506          
   1507          #if (PROBE_COM_CFG_WR_REQ_EN == DEF_ENABLED)
   1508          static  CPU_SIZE_T  ProbeCom_ReqWr (CPU_INT08U  *prx_buf,
   1509                                              CPU_INT08U  *ptx_buf,
   1510                                              CPU_SIZE_T   rx_pkt_size,
   1511                                              CPU_SIZE_T   tx_buf_size)
   1512          {
   1513              CPU_SIZE_T  sym_size;
   1514              CPU_ADDR    sym_addr;
   1515              CPU_SIZE_T  tx_len;
   1516              CPU_SR_ALLOC();
   1517          
   1518          
   1519             (void)&tx_buf_size;                                          /* Prevent compiler warning.                            */
   1520          
   1521          
   1522                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1523                                                                          /* Expected size >= 2      (= Rx hdr size)              */
   1524                                                                          /*                + 2      (= Sym size   )              */
   1525                                                                          /*                + 4      (= Sym addr   )              */
   1526                                                                          /*                + nbytes (= Data       ).             */
   1527              if (rx_pkt_size < 8u) {
   1528                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1529                  return (tx_len);
   1530              }
   1531          
   1532          
   1533          
   1534                                                                          /* -------------------- HANDLE WR --------------------- */
   1535              sym_size = ProbeCom_GetINT16U(&prx_buf);                    /* Get nbr of bytes to wr.                              */
   1536          
   1537                                                                          /* Get wr addr.                                         */
   1538          #if ((!defined(CPU_CFG_ADDR_SIZE)) || \
   1539               ((defined(CPU_CFG_ADDR_SIZE)) && \
   1540                        (CPU_CFG_ADDR_SIZE   != CPU_WORD_SIZE_16)))
   1541              sym_addr = (CPU_ADDR)ProbeCom_GetINT32U(&prx_buf);
   1542          #else
   1543              sym_addr = (CPU_ADDR)ProbeCom_GetINT16U(&prx_buf);
   1544              prx_buf += 2;
   1545          #endif
   1546          
   1547              if (rx_pkt_size != (8 + sym_size)) {                        /* If rx data segment is NOT expected size ... rtn err. */
   1548                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1549                  return (tx_len);
   1550              }
   1551          
   1552                                                                          /* Copy data into mem.                                  */
   1553              CPU_CRITICAL_ENTER();
   1554              Mem_Copy((void     *)sym_addr,
   1555                       (void     *)prx_buf,
   1556                       (CPU_SIZE_T)sym_size);
   1557              CPU_CRITICAL_EXIT();
   1558          
   1559          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1560              ProbeCom_RxSymCtr++;                                        /* Inc global sym ctr.                                  */
   1561              ProbeCom_RxSymByteCtr += sym_size;
   1562          #endif
   1563          
   1564                                                                          /* Store TX pkt hdr :                                   */
   1565              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_WR);          /* (a) TX pkt fmt.                                      */
   1566              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   1567              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   1568          
   1569          
   1570          
   1571                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1572              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;                 /* Tx pkt size = 4 (= Tx hdr size).                     */
   1573              return (tx_len);
   1574          }
   1575          #endif
   1576          
   1577          
   1578          /*
   1579          *********************************************************************************************************
   1580          *                                        ProbeCom_ReqWrMulti()
   1581          *
   1582          * Description : Parse the FMT_WR_MULTI request & formulate response.  This command causes the target to
   1583          *               write certain data into its memroy, for a certain number of {memory address, data length,
   1584          *               data} triplets (which are given in the request).
   1585          *
   1586          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1587          *
   1588          *               ptx_buf         Pointer to the transmit buffer
   1589          *
   1590          *               rx_pkt_size     Size of the receive  packet
   1591          *
   1592          *               tx_buf_size     Size of the transmit buffer
   1593          *
   1594          * Return(s)   : The number of bytes written to the tx buffer.
   1595          *
   1596          * Caller(s)   : ProbeCom_ParseRxPkt().
   1597          *
   1598          * Note(s)     : (1) The RX format:
   1599          *
   1600          *                   (A) A 2-byte format,  indicating the data segment format;
   1601          *                   (B) A n-byte item descriptor, for each item in the list, consiting of the following:
   1602          *
   1603          *                       (1) A 1-byte length,  indicating the number of bytes to write;
   1604          *                       (2) A 4-byte address, the starting address at which the data should be written;
   1605          *                       (3) The memory data.
   1606          *
   1607          *                         +-------------------------+------------+------------+
   1608          *                         |          Format         | Num. bytes |         Addr       ---
   1609          *                         +-------------------------+------------+------------+        |
   1610          *                         ress                                   |            |        |
   1611          *                         +--------------------------------------+            |        |    Item 1
   1612          *                         |                       Data                        |        |
   1613          *                         |                         .                         |        |
   1614          *                         |                         .                         |        |
   1615          *                         +------------+--------------------------------------+       ---
   1616          *                         | Num. bytes |                                   Addr        |    Item 2
   1617          *                         +------------+--------------------------------------+        .
   1618          *                         |                         .                         |        .
   1619          *                         |                         .                         |        .
   1620          *                         |                         .            +------------+        .
   1621          *                         |                         .            | Num. bytes |       ---
   1622          *                         ---------------------------------------+------------+        |
   1623          *                         |                      Address                      |        |
   1624          *                         +---------------------------------------------------+        |    Item n
   1625          *                         |                       Data                        |        |
   1626          *                         |                         .                         |        |
   1627          *                         |                         .                         |        |
   1628          *                         +------------+--------------------------------------+       ---
   1629          *
   1630          *               (2) The TX format:
   1631          *
   1632          *                   (A) A 2-byte format, indicating the data segment format;
   1633          *                   (B) A 1-byte status, indicating the status after the request;
   1634          *                   (C) A 1-byte modifier.
   1635          *
   1636          *                         +-------------------------+------------+------------+
   1637          *                         |          Format         |   Status   |  Modifier  |
   1638          *                         +-------------------------+------------+------------+
   1639          *
   1640          *********************************************************************************************************
   1641          */
   1642          
   1643          #if (PROBE_COM_CFG_WR_REQ_EN == DEF_ENABLED)
   1644          static  CPU_SIZE_T  ProbeCom_ReqWrMulti (CPU_INT08U  *prx_buf,
   1645                                                   CPU_INT08U  *ptx_buf,
   1646                                                   CPU_SIZE_T   rx_pkt_size,
   1647                                                   CPU_SIZE_T   tx_buf_size)
   1648          {
   1649              CPU_SIZE_T  rx_pkt_ix;
   1650          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1651              CPU_INT32U  sym_ctr;
   1652              CPU_INT32U  sym_byte_ctr;
   1653          #endif
   1654              CPU_ADDR    sym_addr;
   1655              CPU_SIZE_T  sym_size;
   1656              CPU_SIZE_T  tx_len;
   1657              CPU_SR_ALLOC();
   1658          
   1659          
   1660             (void)&tx_buf_size;                                          /* Prevent compiler warning.                            */
   1661          
   1662          
   1663                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1664                                                                          /* Expected size >= 2      (= Rx hdr size )             */
   1665                                                                          /*                + 1      (= Nbr of bytes)             */
   1666                                                                          /*                + 4      (= Addr        )             */
   1667                                                                          /*                + nbytes (= Data        ).            */
   1668              if (rx_pkt_size < 7) {
   1669                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1670                  return (tx_len);
   1671              }
   1672          
   1673                                                                          /* -------------------- HANDLE WR --------------------- */
   1674              rx_pkt_ix  = 7;                                             /* Rx pkt ix after 1st item = 2 (= Rx hdr size)         */
   1675                                                                          /*                          + 5 (= 1 item desc).        */
   1676          
   1677          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1678              sym_ctr      = 0;
   1679              sym_byte_ctr = 0;
   1680          #endif
   1681                                                                          /* Sto data for each item.                              */
   1682              while (rx_pkt_ix <= rx_pkt_size) {
   1683                  sym_size = prx_buf[0];                                  /* (a) Get nbr of bytes to wr.                          */
   1684          
   1685                                                                          /* (b) Get wr addr.                                     */
   1686          #if ((!defined(CPU_CFG_ADDR_SIZE)) || \
   1687               ((defined(CPU_CFG_ADDR_SIZE)) && \
   1688                        (CPU_CFG_ADDR_SIZE   != CPU_WORD_SIZE_16)))
   1689                  sym_addr = ((CPU_ADDR)prx_buf[4] << 8) + prx_buf[3];
   1690                  sym_addr = ((CPU_ADDR)sym_addr   << 8) + prx_buf[2];
   1691                  sym_addr = ((CPU_ADDR)sym_addr   << 8) + prx_buf[1];
   1692          #else
   1693                  sym_addr = ((CPU_ADDR)prx_buf[2] << 8) + prx_buf[1];
   1694          #endif
   1695          
   1696                  prx_buf += 5u;
   1697          
   1698                  if (rx_pkt_ix + sym_size > rx_pkt_size) {
   1699                      tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1700                      return (tx_len);
   1701                  }
   1702          
   1703          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1704                  sym_ctr++;                                              /* (c) Inc local sym ctr.                               */
   1705                  sym_byte_ctr += sym_size;
   1706          #endif
   1707                                                                          /* (d) Sto data into pkt.                               */
   1708                  CPU_CRITICAL_ENTER();
   1709                  Mem_Copy((void     *)sym_addr,
   1710                           (void     *)prx_buf,
   1711                           (CPU_SIZE_T)sym_size);
   1712                  CPU_CRITICAL_EXIT();
   1713          
   1714                  prx_buf   += sym_size;
   1715                  rx_pkt_ix += 5u + sym_size;
   1716              }
   1717          
   1718          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1719              ProbeCom_RxSymCtr     += sym_ctr;                           /* Inc global sym ctr.                                  */
   1720              ProbeCom_RxSymByteCtr += sym_byte_ctr;
   1721          #endif
   1722          
   1723                                                                          /* Sto tx pkt hdr :                                     */
   1724              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_WR_MULTI);    /* (a) tx pkt fmt.                                      */
   1725              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   1726              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   1727          
   1728                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1729              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;                 /* Tx pkt size = 4 (= Tx hdr size).                     */
   1730              return (tx_len);
   1731          }
   1732          #endif
   1733          
   1734          
   1735          /*
   1736          *********************************************************************************************************
   1737          *                                         ProbeCom_ReqStrIn()
   1738          *
   1739          * Description : Parse the FMT_STR_IN command & formulate response.  This command sends a string to the
   1740          *               target.
   1741          *
   1742          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1743          *
   1744          *               ptx_buf         Pointer to the transmit buffer
   1745          *
   1746          *               rx_pkt_size     Size of the receive  packet
   1747          *
   1748          *               tx_buf_size     Size of the transmit buffer
   1749          *
   1750          * Return(s)   : The number of bytes written to the tx buffer.
   1751          *
   1752          * Caller(s)   : ProbeCom_ParseRxPkt().
   1753          *
   1754          * Note(s)     : (1) The RX format:
   1755          *
   1756          *                   (A) A 2-byte format, indicating the data segment format;
   1757          *                   (B) A 2-byte padding;
   1758          *                   (C) A n-byte string.
   1759          *
   1760          *                         +-------------------------+-------------------------+
   1761          *                         |          Format         |         Padding         |
   1762          *                         +-------------------------+-------------------------+
   1763          *                         |                       String                      |
   1764          *                         |                         .                         |
   1765          *                         |                         .                         |
   1766          *                         |                         .                         |
   1767          *                         +---------------------------------------------------+
   1768          *
   1769          *               (2) The TX format:
   1770          *
   1771          *                   (A) A 2-byte format, indicating the data segment format;
   1772          *                   (B) A 1-byte status, indicating the status after the request;
   1773          *                   (C) A 1-byte modifier.
   1774          *
   1775          *                         +-------------------------+------------+------------+
   1776          *                         |          Format         |   Status   |  Modifier  |
   1777          *                         +-------------------------+------------+------------+
   1778          *
   1779          *********************************************************************************************************
   1780          */
   1781          
   1782          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
   1783          static  CPU_SIZE_T  ProbeCom_ReqStrIn (CPU_INT08U  *prx_buf,
   1784                                                 CPU_INT08U  *ptx_buf,
   1785                                                 CPU_SIZE_T   rx_pkt_size,
   1786                                                 CPU_SIZE_T   tx_buf_size)
   1787          {
   1788              CPU_SIZE_T   len;
   1789              CPU_SIZE_T   len_wr;
   1790              CPU_SIZE_T   tx_len;
   1791              CPU_INT08U  *pstr;
   1792          
   1793          
   1794             (void)&tx_buf_size;                                          /* Prevent compiler warning.                            */
   1795          
   1796          
   1797                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1798                                                                          /* Expected size = 2 (= Rx hdr size)                    */
   1799                                                                          /*               + 2 (= Padding    ).                   */
   1800              if (rx_pkt_size <= 4u) {
   1801                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1802                  return (tx_len);
   1803              }
   1804          
   1805          
   1806          
   1807                                                                          /* ------------------- HANDLE STR --------------------- */
   1808              pstr   = prx_buf     + 2u;                                   /* Ignore padding.                                      */
   1809              len    = rx_pkt_size - 4u;
   1810          
   1811              len_wr = ProbeCom_BufWr(&ProbeCom_StrInBuf,                 /* Rd str from buf.                                     */
   1812                                       pstr,
   1813                                       len);
   1814          
   1815          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1816              if (len_wr < len) {
   1817                  ProbeCom_StrRxOvfErrCtr++;
   1818              }
   1819          
   1820              ProbeCom_StrRxCtr += len_wr;
   1821          #endif
   1822          
   1823          
   1824                                                                          /* ------------------ STORE RESPONSE ------------------ */
   1825                                                                          /* Sto tx pkt hdr :                                     */
   1826              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_STR_IN);      /* (a) Tx pkt fmt.                                      */
   1827              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   1828              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   1829          
   1830          
   1831          
   1832                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1833              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;                 /* Tx pkt size = 4 (= Tx hdr size).                     */
   1834              return (tx_len);
   1835          }
   1836          #endif
   1837          
   1838          
   1839          /*
   1840          *********************************************************************************************************
   1841          *                                        ProbeCom_ReqStrOut()
   1842          *
   1843          * Description : Parse the FMT_STR_OUT command & formulate response.  This command asks the target to send
   1844          *               a string that it is currently storing.
   1845          *
   1846          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1847          *
   1848          *               ptx_buf         Pointer to the transmit buffer
   1849          *
   1850          *               rx_pkt_size     Size of the receive  packet
   1851          *
   1852          *               tx_buf_size     Size of the transmit buffer
   1853          *
   1854          * Return(s)   : The number of bytes written to the tx buffer.
   1855          *
   1856          * Caller(s)   : ProbeCom_ParseRxPkt().
   1857          *
   1858          * Note(s)     : (1) The RX format:
   1859          *
   1860          *                   (A) A 2-byte format, indicating the data segment format;
   1861          *                   (B) A 2-byte padding.
   1862          *
   1863          *                         +-------------------------+-------------------------+
   1864          *                         |          Format         |         Padding         |
   1865          *                         +-------------------------+-------------------------+
   1866          *
   1867          *               (2) The TX format:
   1868          *
   1869          *                   (A) A 2-byte format, indicating the data segment format;
   1870          *                   (B) A 1-byte status, indicating the status after the request;
   1871          *                   (C) A 1-byte modifier;
   1872          *                   (D) A n-byte string, the string which is stored in the target's buffer.
   1873          *
   1874          *                         +-------------------------+------------+------------+
   1875          *                         |          Format         |   Status   |  Modifier  |
   1876          *                         +-------------------------+------------+------------+
   1877          *                         |                       String                      |
   1878          *                         |                         .                         |
   1879          *                         |                         .                         |
   1880          *                         |                         .                         |
   1881          *                         +---------------------------------------------------+
   1882          *
   1883          *               (3) See Notes for 'ProbeCom_StrWr()'.
   1884          *
   1885          *               (4) Probe requires that a NULL byte ends the string.  Consequently, if the data
   1886          *                   section of the TX packet is n bytes long, then only (n - 1) bytes have been read from
   1887          *                   the string buffer.
   1888          *********************************************************************************************************
   1889          */
   1890          
   1891          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
   1892          static  CPU_SIZE_T  ProbeCom_ReqStrOut (CPU_INT08U  *prx_buf,
   1893                                                  CPU_INT08U  *ptx_buf,
   1894                                                  CPU_SIZE_T   rx_pkt_size,
   1895                                                  CPU_SIZE_T   tx_buf_size)
   1896          {
   1897              CPU_SIZE_T  len_rd;
   1898              CPU_SIZE_T  tx_len;
   1899              CPU_SIZE_T  tx_max;
   1900          
   1901          
   1902             (void)&prx_buf;                                              /* Prevent compiler warning.                            */
   1903          
   1904          
   1905                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1906                                                                          /* Expected size = 2 (= Rx hdr size)                    */
   1907                                                                          /*               + 2 (= Padding    ).                   */
   1908              if (rx_pkt_size != 4u) {
   1909                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1910                  return (tx_len);
   1911              }
   1912          
   1913                                                                          /* --------------------- STORE STR -------------------- */
   1914                                                                          /* Sto TX pkt hdr :                                     */
   1915              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_STR_OUT);     /* (a) TX pkt fmt.                                      */
   1916              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   1917              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   1918          
   1919              tx_max = (tx_buf_size - PROBE_COM_SIZE_TX_HDR) - 1;         /* Calc size of largest tx str.                         */
   1920          
   1921              len_rd = ProbeCom_BufRd(&ProbeCom_StrOutBuf,                /* Rd str from buf.                                     */
   1922                                       ptx_buf,
   1923                                       tx_max);
   1924          
   1925              if (len_rd == 0u) {                                         /* If there is NO str ... rtn err.                      */
   1926                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_STR_OUT_NONE);
   1927                  return (tx_len);
   1928              }
   1929          
   1930             *(ptx_buf + len_rd) = (CPU_INT08U)0;                         /* Wr NULL byte.                                        */
   1931          
   1932          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1933              ProbeCom_StrTxCtr += len_rd;
   1934          #endif
   1935          
   1936          
   1937                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1938              tx_len = PROBE_COM_SIZE_TX_HDR + len_rd + 1u;
   1939              return (tx_len);                                            /* Tx pkt size = 4      (= Tx hdr size)                 */
   1940                                                                          /*             + nbytes (= Str    size)                 */
   1941                                                                          /*             + 1      (= NULL byte  ).                */
   1942          }
   1943          #endif
   1944          
   1945          
   1946          /*
   1947          *********************************************************************************************************
   1948          *                                     ProbeCom_ReqTerminalExec()
   1949          *
   1950          * Description : Parse the FMT_TERMINAL_EXEC command & formulate response.  This command sends a terminal
   1951          *               command to the target for execution.
   1952          *
   1953          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1954          *
   1955          *               ptx_buf         Pointer to the transmit buffer
   1956          *
   1957          *               rx_pkt_size     Size of the receive  packet
   1958          *
   1959          *               tx_buf_size     Size of the transmit buffer
   1960          *
   1961          * Return(s)   : The number of bytes written to the tx buffer.
   1962          *
   1963          * Caller(s)   : ProbeCom_ParseRxPkt().
   1964          *
   1965          * Note(s)     : (1) The RX format:
   1966          *
   1967          *                   (A) A 2-byte format, indicating the data segment format;
   1968          *                   (B) A 2-byte padding;
   1969          *                   (C) A n-byte string.
   1970          *
   1971          *                         +-------------------------+-------------------------+
   1972          *                         |          Format         |         Padding         |
   1973          *                         +-------------------------+-------------------------+
   1974          *                         |                  Terminal Command                 |
   1975          *                         |                         .                         |
   1976          *                         |                         .                         |
   1977          *                         |                         .                         |
   1978          *                         +---------------------------------------------------+
   1979          *
   1980          *               (2) The TX format:
   1981          *
   1982          *                   (A) A 2-byte format, indicating the data segment format;
   1983          *                   (B) A 1-byte status, indicating the status after the request;
   1984          *                   (C) A 1-byte modifier.
   1985          *
   1986          *                         +-------------------------+------------+------------+
   1987          *                         |          Format         |   Status   |  Modifier  |
   1988          *                         +-------------------------+------------+------------+
   1989          *
   1990          *********************************************************************************************************
   1991          */
   1992          
   1993          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
   1994          static  CPU_SIZE_T  ProbeCom_ReqTerminalExec (CPU_INT08U  *prx_buf,
   1995                                                        CPU_INT08U  *ptx_buf,
   1996                                                        CPU_SIZE_T   rx_pkt_size,
   1997                                                        CPU_SIZE_T   tx_buf_size)
   1998          {
   1999              PROBE_COM_TERMINAL_EXEC_FNCT   handler;
   2000              CPU_SIZE_T                     len;
   2001              CPU_SIZE_T                     tx_len;
   2002              CPU_INT08U                    *pstr;
   2003              CPU_SR_ALLOC();
   2004          
   2005          
   2006             (void)&tx_buf_size;                                          /* Prevent compiler warning.                            */
   2007          
   2008          
   2009                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   2010                                                                          /* Expected size = 2 (= Rx hdr size)                    */
   2011                                                                          /*               + 2 (= Padding    ).                   */
   2012              if (rx_pkt_size <= 4u) {
   2013                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   2014                  return (tx_len);
   2015              }
   2016          
   2017          
   2018          
   2019                                                                          /* -------------------- HANDLE STR -------------------- */
   2020              CPU_CRITICAL_ENTER();
   2021              handler = ProbeCom_TerminalExecHandler;
   2022              CPU_CRITICAL_EXIT();
   2023          
   2024              if (handler != (PROBE_COM_TERMINAL_EXEC_FNCT)0) {           /* If handler assigned ...                              */
   2025                  pstr = prx_buf     + 2u;                                /* ... ignore padding  ...                              */
   2026                  len  = rx_pkt_size - 2u;
   2027          
   2028                  ProbeCom_TerminalExecuting = DEF_YES;
   2029          
   2030                  handler((CPU_CHAR *)pstr,                               /* ... exec handler.                                    */
   2031                          (CPU_SIZE_T)len);
   2032              }
   2033          
   2034          
   2035          
   2036                                                                          /* ------------------ STORE RESPONSE ------------------ */
   2037                                                                          /* Sto tx pkt hdr :                                     */
   2038                                                                          /* (a) Tx pkt fmt.                                      */
   2039              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_TERMINAL_EXEC);
   2040              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   2041              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   2042          
   2043          
   2044          
   2045                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   2046              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;                 /* Tx pkt size = 4 (= Tx hdr size).                     */
   2047              return (tx_len);
   2048          }
   2049          #endif
   2050          
   2051          
   2052          /*
   2053          *********************************************************************************************************
   2054          *                                      ProbeCom_ReqTerminalIn()
   2055          *
   2056          * Description : Parse the FMT_TERMINAL_IN command & formulate response.  This command sends a terminal
   2057          *               input to the target.
   2058          *
   2059          * Argument(s) : prx_buf         Pointer to the receive  buffer
   2060          *
   2061          *               ptx_buf         Pointer to the transmit buffer
   2062          *
   2063          *               rx_pkt_size     Size of the receive  packet
   2064          *
   2065          *               tx_buf_size     Size of the transmit buffer
   2066          *
   2067          * Return(s)   : The number of bytes written to the tx buffer.
   2068          *
   2069          * Caller(s)   : ProbeCom_ParseRxPkt().
   2070          *
   2071          * Note(s)     : (1) The RX format:
   2072          *
   2073          *                   (A) A 2-byte format, indicating the data segment format;
   2074          *                   (B) A 2-byte padding;
   2075          *                   (C) A n-byte string.
   2076          *
   2077          *                         +-------------------------+-------------------------+
   2078          *                         |          Format         |         Padding         |
   2079          *                         +-------------------------+-------------------------+
   2080          *                         |                   Terminal Input                  |
   2081          *                         |                         .                         |
   2082          *                         |                         .                         |
   2083          *                         |                         .                         |
   2084          *                         +---------------------------------------------------+
   2085          *
   2086          *               (2) The TX format:
   2087          *
   2088          *                   (A) A 2-byte format, indicating the data segment format;
   2089          *                   (B) A 1-byte status, indicating the status after the request;
   2090          *                   (C) A 1-byte modifier.
   2091          *
   2092          *                         +-------------------------+------------+------------+
   2093          *                         |          Format         |   Status   |  Modifier  |
   2094          *                         +-------------------------+------------+------------+
   2095          *
   2096          *********************************************************************************************************
   2097          */
   2098          
   2099          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
   2100          static  CPU_SIZE_T  ProbeCom_ReqTerminalIn (CPU_INT08U  *prx_buf,
   2101                                                      CPU_INT08U  *ptx_buf,
   2102                                                      CPU_SIZE_T   rx_pkt_size,
   2103                                                      CPU_SIZE_T   tx_buf_size)
   2104          {
   2105              PROBE_COM_TERMINAL_IN_FNCT   handler;
   2106              CPU_SIZE_T                   len;
   2107              CPU_SIZE_T                   tx_len;
   2108              CPU_INT08U                  *pstr;
   2109              CPU_SR_ALLOC();
   2110          
   2111          
   2112             (void)&tx_buf_size;                                          /* Prevent compiler warning.                            */
   2113          
   2114          
   2115                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   2116                                                                          /* Expected size = 2 (= Rx hdr size)                    */
   2117                                                                          /*               + 2 (= Padding    ).                   */
   2118              if (rx_pkt_size <= 4u) {
   2119                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   2120                  return (tx_len);
   2121              }
   2122          
   2123          
   2124          
   2125                                                                          /* -------------------- HANDLE STR -------------------- */
   2126              CPU_CRITICAL_ENTER();
   2127              handler = ProbeCom_TerminalInHandler;
   2128              CPU_CRITICAL_EXIT();
   2129          
   2130              if (handler != (PROBE_COM_TERMINAL_IN_FNCT)0) {             /* If handler assigned.                                 */
   2131                  pstr = prx_buf     + 4u;
   2132                  len  = rx_pkt_size - 4u;
   2133          
   2134                  handler((CPU_CHAR *)pstr,
   2135                          (CPU_SIZE_T)len);
   2136              }
   2137          
   2138          
   2139          
   2140                                                                          /* ------------------ STORE RESPONSE ------------------ */
   2141                                                                          /* Sto tx pkt hdr :                                     */
   2142              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_TERMINAL_IN); /* (a) Tx pkt fmt.                                      */
   2143              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   2144              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   2145          
   2146          
   2147          
   2148                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   2149              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;                 /* Tx pkt size = 4 (= Tx hdr size).                     */
   2150              return (tx_len);
   2151          }
   2152          #endif
   2153          
   2154          
   2155          /*
   2156          *********************************************************************************************************
   2157          *                                      ProbeCom_ReqTerminalOut()
   2158          *
   2159          * Description : Parse the FMT_TERMINAL_OUT command & formulate response.  This command asks the target to
   2160          *               send terminal output that it is currently storing.
   2161          *
   2162          * Argument(s) : prx_buf         Pointer to the receive  buffer
   2163          *
   2164          *               ptx_buf         Pointer to the transmit buffer
   2165          *
   2166          *               rx_pkt_size     Size of the receive  packet
   2167          *
   2168          *               tx_buf_size     Size of the transmit buffer
   2169          *
   2170          * Return(s)   : The number of bytes written to the tx buffer.
   2171          *
   2172          * Caller(s)   : ProbeCom_ParseRxPkt().
   2173          *
   2174          * Note(s)     : (1) The RX format:
   2175          *
   2176          *                   (A) A 2-byte format, indicating the data segment format;
   2177          *                   (B) A 2-byte padding.
   2178          *
   2179          *                         +-------------------------+-------------------------+
   2180          *                         |          Format         |         Padding         |
   2181          *                         +-------------------------+-------------------------+
   2182          *
   2183          *               (2) The TX format:
   2184          *
   2185          *                   (A) A 2-byte format, indicating the data segment format;
   2186          *                   (B) A 1-byte status, indicating the status after the request;
   2187          *                   (C) A 1-byte modifier;
   2188          *                   (D) A n-byte string, the string which is stored in the target's buffer.
   2189          *
   2190          *                         +-------------------------+------------+------------+
   2191          *                         |          Format         |   Status   |  Modifier  |
   2192          *                         +-------------------------+------------+------------+
   2193          *                         |                  Terminal Output                  |
   2194          *                         |                         .                         |
   2195          *                         |                         .                         |
   2196          *                         |                         .                         |
   2197          *                         +---------------------------------------------------+
   2198          *
   2199          *               (3) See Notes for 'ProbeCom_StrWr()'.
   2200          *
   2201          *               (4) Probe requires that a NULL byte ends the string.  Consequently, if the data
   2202          *                   section of the TX packet is n bytes long, then only (n - 1) bytes have been read from
   2203          *                   the string buffer.
   2204          *
   2205          *               (5) A NULL modifier is returned so that string transmission will not monopolize the
   2206          *                   transmission channel.  If more string is queued in the string buffer, additional
   2207          *                   string bytes will be sent following the response to the next received packet.
   2208          *********************************************************************************************************
   2209          */
   2210          
   2211          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_TRUE)
   2212          static  CPU_SIZE_T  ProbeCom_ReqTerminalOut (CPU_INT08U  *prx_buf,
   2213                                                       CPU_INT08U  *ptx_buf,
   2214                                                       CPU_SIZE_T   rx_pkt_size,
   2215                                                       CPU_SIZE_T   tx_buf_size)
   2216          {
   2217              CPU_SIZE_T   buf_ix;
   2218              CPU_SIZE_T   buf_len;
   2219              CPU_SIZE_T   tx_len;
   2220              CPU_SIZE_T   tx_max;
   2221              CPU_INT08U  *pbuf;
   2222              CPU_SR_ALLOC();
   2223          
   2224          
   2225             (void)&prx_buf;                                              /* Prevent compiler warning.                            */
   2226          
   2227          
   2228                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   2229                                                                          /* Expected size = 2 (= Rx hdr size)                    */
   2230                                                                          /*               + 2 (= Padding    ).                   */
   2231              if (rx_pkt_size != 4u) {
   2232                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   2233                  return (tx_len);
   2234              }
   2235          
   2236              CPU_CRITICAL_ENTER();
   2237              pbuf    = ProbeCom_TerminalOutBufPtr;
   2238              buf_ix  = ProbeCom_TerminalOutBufIx;
   2239              buf_len = ProbeCom_TerminalOutBufLen;
   2240              CPU_CRITICAL_EXIT();
   2241          
   2242              if (pbuf == (CPU_INT08U *)0) {
   2243                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_TERMINAL_OUT_NONE);
   2244                  return (tx_len);
   2245              }
   2246          
   2247              if (buf_ix == buf_len) {
   2248                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_TERMINAL_OUT_NONE);
   2249                  return (tx_len);
   2250              }
   2251          
   2252              tx_max = buf_len - buf_ix;
   2253              if (tx_max > (tx_buf_size - PROBE_COM_SIZE_TX_HDR) - 1) {
   2254                  tx_max = (tx_buf_size - PROBE_COM_SIZE_TX_HDR) - 1;
   2255              }
   2256          
   2257          
   2258                                                                          /* --------------------- STORE OUT -------------------- */
   2259                                                                          /* Sto TX pkt hdr :                                     */
   2260              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_TERMINAL_OUT);/* (a) TX pkt fmt.                                      */
   2261              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   2262              ProbeCom_StoINT08U(&ptx_buf, 0);                            /* (c) Modifier (see Notes #5).                         */
   2263          
   2264              Mem_Copy((void       *) ptx_buf,                            /* Copy str from buf.                                   */
   2265                       (void       *)&pbuf[buf_ix],
   2266                       (CPU_SIZE_T  ) tx_max);
   2267          
   2268             *(ptx_buf + tx_max)        = (CPU_INT08U)0;                  /* Wr NULL byte.                                        */
   2269          
   2270              CPU_CRITICAL_ENTER();
   2271              ProbeCom_TerminalOutBufIx = buf_ix + tx_max;                /* Update buf ix.                                       */
   2272              CPU_CRITICAL_EXIT();
   2273          
   2274              if (buf_ix + tx_max >= buf_len) {
   2275                  ProbeCom_OS_TerminalOutSignal();
   2276              }
   2277          
   2278          
   2279                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   2280              tx_len = PROBE_COM_SIZE_TX_HDR + tx_max + 1u;
   2281              return (tx_len);                                            /* Tx pkt size = 4      (= Tx hdr size)                 */
   2282                                                                          /*             + nbytes (= Str    size)                 */
   2283                                                                          /*             + 1      (= NULL byte  ).                */
   2284          }
   2285          #endif
   2286          
   2287          
   2288          /*
   2289          *********************************************************************************************************
   2290          *                                         ProbeCom_BufInit()
   2291          *
   2292          * Description : Initialize buffer.
   2293          *
   2294          * Argument(s) : pbuf            Pointer to buffer.
   2295          *
   2296          *               pdata           Pointer to buffer data.
   2297          *
   2298          *               len             Buffer length.
   2299          *
   2300          * Return(s)   : none.
   2301          *
   2302          * Caller(s)   : Application.
   2303          *
   2304          * Note(s)     : (1) The string buffer is implemented as a circular buffer.  This function is one of two
   2305          *                   points of access for this buffer, the other being in the task or ISR which forms the
   2306          *                   tx packets.  Only this function should modify the global current write index
   2307          *                   (pbuf->IxWr); only the task or ISR which forms the packets should modify the global
   2308          *                   current read index (pbuf->IxRd).
   2309          *
   2310          *               (2) The global current write index (pbuf->IxWr) is the index of the next location in the
   2311          *                   buffer to write.  The global current read index (pbuf->IxRd) is the index of the next
   2312          *                   location in the buffer to read.
   2313          *
   2314          *               (3) The string buffer, an array of pbuf->Len bytes, can only hold (pbuf->Len - 1) bytes
   2315          *                   so that the condition
   2316          *
   2317          *                                        pbuf->IxWr == pbuf->IxRd
   2318          *
   2319          *                   will be true if and only if the buffer is empty.  Consequently, this function
   2320          *                   always leaves an empty space in the buffer.
   2321          *********************************************************************************************************
   2322          */
   2323          
   2324          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
   2325          static  void  ProbeCom_BufInit (PROBE_COM_BUF  *pbuf,
   2326                                          CPU_INT08U     *pdata,
   2327                                          CPU_SIZE_T      len)
   2328          {
   2329              pbuf->Len      = len;
   2330              pbuf->IxRd     = 0;
   2331              pbuf->IxWr     = 0;
   2332              pbuf->DataPtr  = pdata;
   2333          }
   2334          #endif
   2335          
   2336          
   2337          /*
   2338          *********************************************************************************************************
   2339          *                                          ProbeCom_BufRd()
   2340          *
   2341          * Description : Read from buffer.
   2342          *
   2343          * Argument(s) : pbuf            Pointer to buffer.
   2344          *
   2345          *               pdest           Pointer to destination buffer.
   2346          *
   2347          *               len             Number of octets to read.
   2348          *
   2349          * Return(s)   : The number of octets read from buffer.
   2350          *
   2351          * Caller(s)   : Application.
   2352          *
   2353          * Note(s)     : none.
   2354          *********************************************************************************************************
   2355          */
   2356          
   2357          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
   2358          static  CPU_SIZE_T  ProbeCom_BufRd (PROBE_COM_BUF  *pbuf,
   2359                                              CPU_INT08U     *pdest,
   2360                                              CPU_SIZE_T      len)
   2361          {
   2362              CPU_SIZE_T  cnt_copy;
   2363              CPU_SIZE_T  cnt_full;
   2364              CPU_SIZE_T  cnt_rem;
   2365              CPU_SIZE_T  ix_rd;
   2366              CPU_SIZE_T  ix_wr;
   2367              CPU_SIZE_T  len_buf;
   2368              CPU_SR_ALLOC();
   2369          
   2370          
   2371              CPU_CRITICAL_ENTER();
   2372              ix_rd   = pbuf->IxRd;
   2373              ix_wr   = pbuf->IxWr;
   2374              len_buf = pbuf->Len;
   2375          
   2376              if (ix_wr == ix_rd) {                                       /* Buf is empty.                                        */
   2377                  CPU_CRITICAL_EXIT();
   2378                  return ((CPU_SIZE_T)0);
   2379              }
   2380          
   2381          
   2382          
   2383                                                                          /* -------------- COPY DATA FROM BUF END -------------- */
   2384              if (ix_wr > ix_rd) {                                        /* Get str at buf interval [rd_ix, wr_ix).              */
   2385                  cnt_full = ix_wr - ix_rd;
   2386              } else {                                                    /* Get str at buf interval [rd_ix, end_ix).             */
   2387                  cnt_full = len_buf - ix_rd;
   2388              }
   2389          
   2390              cnt_copy  = DEF_MIN(cnt_full, len);                         /* Copy data.                                           */
   2391              Mem_Copy((void *)pdest, (void *)&pbuf->DataPtr[ix_rd], cnt_copy);
   2392          
   2393          
   2394              if ((ix_wr > ix_rd) || (ix_wr == 0u)) {
   2395                  ix_rd += cnt_copy;
   2396                  if (ix_rd == len_buf) {
   2397                      pbuf->IxRd = 0u;
   2398                  } else {
   2399                      pbuf->IxRd = ix_rd;
   2400                  }
   2401                  CPU_CRITICAL_EXIT();
   2402          
   2403                  return (cnt_copy);
   2404              }
   2405          
   2406          
   2407          
   2408                                                                          /* -------------- COPY DATA AT BUF START -------------- */
   2409              ix_rd    += cnt_copy;
   2410              pdest    += cnt_copy;                                       /* Adj buf ptr.                                         */
   2411              cnt_rem   = len - cnt_copy;                                 /* Calc nbr data octets to copy from buf start.         */
   2412              cnt_copy  = DEF_MIN(ix_wr, cnt_rem);
   2413          
   2414              if (cnt_copy > 0u) {
   2415                                                                          /* Copy data.                                           */
   2416                  Mem_Copy((void *)pdest, (void *)&pbuf->DataPtr[0], cnt_copy);
   2417                  pbuf->IxRd = cnt_copy;
   2418              } else {
   2419                  if (ix_rd == len_buf) {
   2420                      pbuf->IxRd = 0u;
   2421                  } else {
   2422                      pbuf->IxRd = ix_rd;
   2423                  }
   2424              }
   2425              CPU_CRITICAL_EXIT();
   2426          
   2427              return ((len - cnt_rem) + cnt_copy);
   2428          }
   2429          #endif
   2430          
   2431          
   2432          /*
   2433          *********************************************************************************************************
   2434          *                                          ProbeCom_BufWr()
   2435          *
   2436          * Description : Write to buffer.
   2437          *
   2438          * Argument(s) : pbuf            Pointer to buffer.
   2439          *
   2440          *               psrc            Pointer to source buffer.
   2441          *
   2442          *               len             Number of octets to write.
   2443          *
   2444          *
   2445          * Return(s)   : Number of octets stored in buffer.
   2446          *
   2447          * Caller(s)   : Hardware Port's ISR.
   2448          *
   2449          * Note(s)     : none.
   2450          *********************************************************************************************************
   2451          */
   2452          
   2453          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
   2454          static  CPU_SIZE_T  ProbeCom_BufWr (PROBE_COM_BUF  *pbuf,
   2455                                              CPU_INT08U     *psrc,
   2456                                              CPU_SIZE_T      len)
   2457          {
   2458              CPU_SIZE_T  cnt_copy;
   2459              CPU_SIZE_T  cnt_empty;
   2460              CPU_SIZE_T  cnt_rem;
   2461              CPU_SIZE_T  ix_rd;
   2462              CPU_SIZE_T  ix_wr;
   2463              CPU_SIZE_T  len_buf;
   2464              CPU_SR_ALLOC();
   2465          
   2466          
   2467              CPU_CRITICAL_ENTER();
   2468              ix_rd   = pbuf->IxRd;
   2469              ix_wr   = pbuf->IxWr;
   2470              len_buf = pbuf->Len;
   2471          
   2472                                                                          /* --------------- COPY DATA AT BUF END --------------- */
   2473              if (ix_rd > ix_wr) {                                        /* Sto str at buf interval [wr_ix, rd_ix - 1).          */
   2474                  cnt_empty = (ix_rd   - ix_wr) - 1u;
   2475              } else if (ix_rd == 0u) {                                   /* Sto str at buf interval [wr_ix, end_ix - 1).         */
   2476                  cnt_empty = (len_buf - ix_wr) - 1u;
   2477              } else {                                                    /* Sto str at buf interval [wr_ix, end_ix).             */
   2478                  cnt_empty =  len_buf - ix_wr;
   2479              }
   2480          
   2481              cnt_copy  = DEF_MIN(cnt_empty, len);                        /* Copy data.                                           */
   2482              Mem_Copy((void *)&pbuf->DataPtr[ix_wr], (void *)psrc, cnt_copy);
   2483          
   2484          
   2485              if ((ix_rd > ix_wr) || (ix_rd == 0u)) {
   2486                  pbuf->IxWr = ix_wr + cnt_copy;
   2487                  CPU_CRITICAL_EXIT();
   2488          
   2489                  return (cnt_copy);
   2490              }
   2491          
   2492          
   2493          
   2494                                                                          /* -------------- COPY DATA AT BUF START -------------- */
   2495              ix_wr    += cnt_copy;
   2496              psrc     += cnt_copy;                                       /* Adj buf ptr.                                         */
   2497              cnt_rem   = len - cnt_copy;                                 /* Calc nbr data octets to copy from buf start.         */
   2498              cnt_copy  = DEF_MIN(ix_rd - 1u, cnt_rem);
   2499          
   2500              if (cnt_copy > 0u) {
   2501                                                                          /* Copy data.                                           */
   2502                  Mem_Copy((void *)&pbuf->DataPtr[0], (void *)psrc, cnt_copy);
   2503                  pbuf->IxWr = cnt_copy;
   2504              } else {
   2505                  if (ix_wr == len_buf) {
   2506                      pbuf->IxWr = 0u;
   2507                  } else {
   2508                      pbuf->IxWr = ix_wr;
   2509                  }
   2510              }
   2511              CPU_CRITICAL_EXIT();
   2512          
   2513              return ((len - cnt_rem) + cnt_copy);
   2514          }
   2515          #endif
   2516          
   2517          
   2518          /*
   2519          *********************************************************************************************************
   2520          *                                        ProbeCom_BufIsEmpty()
   2521          *
   2522          * Description : Determine whether buffer is empty.
   2523          *
   2524          * Argument(s) : pbuf            Pointer to buffer.
   2525          *
   2526          * Return(s)   : DEF_YES, if buffer is empty.
   2527          *               DEF_NO,  if buffer contains any data.
   2528          *
   2529          * Caller(s)   : Application.
   2530          *
   2531          * Note(s)     : none.
   2532          *********************************************************************************************************
   2533          */
   2534          
   2535          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
   2536          static  CPU_BOOLEAN  ProbeCom_BufIsEmpty  (PROBE_COM_BUF  *pbuf)
   2537          {
   2538              CPU_BOOLEAN  empty;
   2539              CPU_SR_ALLOC();
   2540          
   2541          
   2542              CPU_CRITICAL_ENTER();
   2543              empty = ((pbuf->IxRd == pbuf->IxWr) ? (DEF_YES) : (DEF_NO));
   2544              CPU_CRITICAL_EXIT();
   2545          
   2546              return (empty);
   2547          }
   2548          #endif
   2549          
   2550          
   2551          /*
   2552          *********************************************************************************************************
   2553          *                                        ProbeCom_BufIsFull()
   2554          *
   2555          * Description : Determine whether buffer is full.
   2556          *
   2557          * Argument(s) : pbuf            Pointer to buffer.
   2558          *
   2559          * Return(s)   : DEF_YES, if buffer is full.
   2560          *               DEF_NO,  otherwise.
   2561          *
   2562          * Caller(s)   : Application.
   2563          *
   2564          * Note(s)     : none.
   2565          *********************************************************************************************************
   2566          */
   2567          
   2568          #if 0
   2569          static  CPU_BOOLEAN  ProbeCom_BufIsFull  (PROBE_COM_BUF  *pbuf)
   2570          {
   2571              CPU_BOOLEAN  full;
   2572              CPU_SR_ALLOC();
   2573          
   2574          
   2575              CPU_CRITICAL_ENTER();
   2576              if (pbuf->IxWr == 0) {
   2577                  full = ((pbuf->IxRd == pbuf->Len  - 1) ? (DEF_YES) : (DEF_NO));
   2578              } else {
   2579                  full = ((pbuf->IxRd == pbuf->IxWr - 1) ? (DEF_YES) : (DEF_NO));
   2580              }
   2581              CPU_CRITICAL_EXIT();
   2582          
   2583              return (full);
   2584          }
   2585          #endif
   2586          
   2587          
   2588          /*
   2589          *********************************************************************************************************
   2590          *                                        ProbeCom_GetINT08U()
   2591          *                                        ProbeCom_GetINT16U()
   2592          *                                        ProbeCom_GetINT32U()
   2593          *
   2594          * Description : Retrieve data from a buffer and increment buffer pointer.
   2595          *
   2596          * Argument(s) : pbuf            The pointer to the buffer pointer.
   2597          *
   2598          * Return(s)   : A 8-, 16-, or 32-bit datum, respectively.
   2599          *
   2600          * Caller(s)   : various.
   2601          *
   2602          * Note(s)     : none.
   2603          *********************************************************************************************************
   2604          */
   2605          
   2606          static  CPU_INT08U  ProbeCom_GetINT08U (CPU_INT08U **pbuf)
   2607          {
   2608              return (*((*pbuf)++));
   2609          }
   2610          
   2611          
   2612          static  CPU_INT16U  ProbeCom_GetINT16U (CPU_INT08U **pbuf)
   2613          {
   2614              CPU_INT16U  lowbyte;
   2615              CPU_INT16U  highbyte;
   2616          
   2617          
   2618              lowbyte  = ProbeCom_GetINT08U(pbuf);
   2619              highbyte = ProbeCom_GetINT08U(pbuf);
   2620              return ((CPU_INT16U)((CPU_INT16U)(highbyte << 8) | (CPU_INT16U)lowbyte));
   2621          }
   2622          
   2623          static  CPU_INT32U  ProbeCom_GetINT32U (CPU_INT08U **pbuf)
   2624          {
   2625              CPU_INT32U  highword;
   2626              CPU_INT32U  lowword;
   2627          
   2628          
   2629              lowword  = ProbeCom_GetINT16U(pbuf);
   2630              highword = ProbeCom_GetINT16U(pbuf);
   2631              return ((CPU_INT32U)((highword << 16) | lowword));
   2632          }
   2633          
   2634          
   2635          /*
   2636          *********************************************************************************************************
   2637          *                                        ProbeCom_StoINT08U()
   2638          *                                        ProbeCom_StoINT16U()
   2639          *                                        ProbeCom_StoINT32U()
   2640          *
   2641          * Description : Store data into a buffer and increment the buffer pointer.
   2642          *
   2643          * Argument(s) : pbuf            The pointer to the buffer pointer.
   2644          *
   2645          *               data            A 8-, 16-, or 32-bit datum, respectively.
   2646          *
   2647          * Return(s)   : none.
   2648          *
   2649          * Caller(s)   : various.
   2650          *
   2651          * Note(s)     : none.
   2652          *********************************************************************************************************
   2653          */
   2654          
   2655          static  void  ProbeCom_StoINT08U (CPU_INT08U **pbuf, CPU_INT08U data)
   2656          {
   2657              *((*pbuf)++) = data;
   2658          }
   2659          
   2660          
   2661          static  void  ProbeCom_StoINT16U (CPU_INT08U **pbuf, CPU_INT16U data)
   2662          {
   2663              ProbeCom_StoINT08U(pbuf, (CPU_INT08U)(data & 0x00FF));
   2664              ProbeCom_StoINT08U(pbuf, (CPU_INT08U)(data >> 8));
   2665          }
   2666          
   2667          
   2668          #if 0
   2669          static  void  ProbeCom_StoINT32U (CPU_INT08U **pbuf, CPU_INT32U data)
   2670          {
   2671              ProbeCom_StoINT16U(pbuf, (CPU_INT16U)(data & 0x0000FFFFL));
   2672              ProbeCom_StoINT16U(pbuf, (CPU_INT16U)(data >> 16));
   2673          }
   2674          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ProbeCom_BufInit
      16   ProbeCom_BufIsEmpty
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      48   ProbeCom_BufRd
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> Mem_Copy
      48   ProbeCom_BufWr
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> Mem_Copy
       0   ProbeCom_GetINT08U
      16   ProbeCom_GetINT16U
        16   -> ProbeCom_GetINT08U
      16   ProbeCom_GetINT32U
        16   -> ProbeCom_GetINT16U
       8   ProbeCom_Init
         8   -> Mem_Clr
         8   -> ProbeCom_BufInit
         8   -> ProbeCom_OS_Init
      40   ProbeCom_ParseRxPkt
        40   -> ProbeCom_ReqErr
        40   -> ProbeCom_ReqQuery
        40   -> ProbeCom_ReqRd
        40   -> ProbeCom_ReqRdMulti
        40   -> ProbeCom_ReqStrIn
        40   -> ProbeCom_ReqStrOut
        40   -> ProbeCom_ReqTerminalExec
        40   -> ProbeCom_ReqTerminalIn
        40   -> ProbeCom_ReqTerminalOut
        40   -> ProbeCom_ReqWr
        40   -> ProbeCom_ReqWrMulti
      16   ProbeCom_PktModifier
        16   -> ProbeCom_StrOutAvail
        16   -> ProbeCom_TerminalExecDone
        16   -> ProbeCom_TerminalOutAvail
      16   ProbeCom_ReqErr
        16   -> ProbeCom_PktModifier
        16   -> ProbeCom_StoINT08U
        16   -> ProbeCom_StoINT16U
      40   ProbeCom_ReqQuery
        40   -> Mem_Copy
        40   -> ProbeCom_GetINT16U
        40   -> ProbeCom_PktModifier
        40   -> ProbeCom_ReqErr
        40   -> ProbeCom_StoINT08U
        40   -> ProbeCom_StoINT16U
      32   ProbeCom_ReqRd
        32   -> Mem_Copy
        32   -> ProbeCom_GetINT16U
        32   -> ProbeCom_GetINT32U
        32   -> ProbeCom_PktModifier
        32   -> ProbeCom_ReqErr
        32   -> ProbeCom_StoINT08U
        32   -> ProbeCom_StoINT16U
      48   ProbeCom_ReqRdMulti
        48   -> Mem_Copy
        48   -> ProbeCom_PktModifier
        48   -> ProbeCom_ReqErr
      40   ProbeCom_ReqStrIn
        40   -> ProbeCom_BufWr
        40   -> ProbeCom_PktModifier
        40   -> ProbeCom_ReqErr
        40   -> ProbeCom_StoINT08U
        40   -> ProbeCom_StoINT16U
      32   ProbeCom_ReqStrOut
        32   -> ProbeCom_BufRd
        32   -> ProbeCom_PktModifier
        32   -> ProbeCom_ReqErr
        32   -> ProbeCom_StoINT08U
        32   -> ProbeCom_StoINT16U
      40   ProbeCom_ReqTerminalExec
        40   -- Indirect call
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> ProbeCom_PktModifier
        40   -> ProbeCom_ReqErr
        40   -> ProbeCom_StoINT08U
        40   -> ProbeCom_StoINT16U
      40   ProbeCom_ReqTerminalIn
        40   -- Indirect call
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> ProbeCom_PktModifier
        40   -> ProbeCom_ReqErr
        40   -> ProbeCom_StoINT08U
        40   -> ProbeCom_StoINT16U
      48   ProbeCom_ReqTerminalOut
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> Mem_Copy
        48   -> ProbeCom_OS_TerminalOutSignal
        48   -> ProbeCom_ReqErr
        48   -> ProbeCom_StoINT08U
        48   -> ProbeCom_StoINT16U
      40   ProbeCom_ReqWr
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> Mem_Copy
        40   -> ProbeCom_GetINT16U
        40   -> ProbeCom_GetINT32U
        40   -> ProbeCom_PktModifier
        40   -> ProbeCom_ReqErr
        40   -> ProbeCom_StoINT08U
        40   -> ProbeCom_StoINT16U
      48   ProbeCom_ReqWrMulti
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> Mem_Copy
        48   -> ProbeCom_PktModifier
        48   -> ProbeCom_ReqErr
        48   -> ProbeCom_StoINT08U
        48   -> ProbeCom_StoINT16U
       0   ProbeCom_StoINT08U
      16   ProbeCom_StoINT16U
        16   -> ProbeCom_StoINT08U
      16   ProbeCom_StrOutAvail
        16   -> ProbeCom_BufIsEmpty
      16   ProbeCom_StrRd
        16   -> ProbeCom_BufRd
      16   ProbeCom_StrWr
        16   -> ProbeCom_BufWr
      16   ProbeCom_TerminalExecComplete
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   ProbeCom_TerminalExecDone
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   ProbeCom_TerminalExecSet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   ProbeCom_TerminalInSet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   ProbeCom_TerminalOut
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> ProbeCom_OS_TerminalOutWait
      16   ProbeCom_TerminalOutAvail
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable19
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
      28  ProbeCom_BufInit
      72  ProbeCom_BufIsEmpty
     336  ProbeCom_BufRd
     332  ProbeCom_BufWr
       4  ProbeCom_EndiannessTest
       4  ProbeCom_ErrPktCtr
      20  ProbeCom_GetINT08U
      52  ProbeCom_GetINT16U
      44  ProbeCom_GetINT32U
     320  ProbeCom_Init
     460  ProbeCom_ParseRxPkt
     112  ProbeCom_PktModifier
      96  ProbeCom_ReqErr
     708  ProbeCom_ReqQuery
     228  ProbeCom_ReqRd
     312  ProbeCom_ReqRdMulti
     200  ProbeCom_ReqStrIn
     208  ProbeCom_ReqStrOut
     200  ProbeCom_ReqTerminalExec
     188  ProbeCom_ReqTerminalIn
     332  ProbeCom_ReqTerminalOut
     256  ProbeCom_ReqWr
     336  ProbeCom_ReqWrMulti
       4  ProbeCom_RxPktCtr
       4  ProbeCom_RxSymByteCtr
       4  ProbeCom_RxSymCtr
      20  ProbeCom_StoINT08U
      60  ProbeCom_StoINT16U
      16  ProbeCom_StrInBuf
     128  ProbeCom_StrInBufData
      60  ProbeCom_StrOutAvail
      16  ProbeCom_StrOutBuf
    2048  ProbeCom_StrOutBufData
      44  ProbeCom_StrRd
       4  ProbeCom_StrRxCtr
       4  ProbeCom_StrRxOvfErrCtr
       4  ProbeCom_StrTxCtr
       4  ProbeCom_StrTxOvfErrCtr
      72  ProbeCom_StrWr
      72  ProbeCom_TerminalExecComplete
      76  ProbeCom_TerminalExecDone
       4  ProbeCom_TerminalExecHandler
      44  ProbeCom_TerminalExecSet
       1  ProbeCom_TerminalExecuting
       4  ProbeCom_TerminalInHandler
      40  ProbeCom_TerminalInSet
     192  ProbeCom_TerminalOut
      72  ProbeCom_TerminalOutAvail
       4  ProbeCom_TerminalOutBufIx
       4  ProbeCom_TerminalOutBufLen
       4  ProbeCom_TerminalOutBufPtr
       4  ProbeCom_TxPktCtr
       4  ProbeCom_TxSymByteCtr
       4  ProbeCom_TxSymCtr

 
 2 277 bytes in section .bss
 5 712 bytes in section .text
 
 5 712 bytes of CODE memory
 2 277 bytes of DATA memory

Errors: none
Warnings: none
