###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Aug/2014  09:36:59
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Shell\commands.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Shell\commands.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\FLASH\List\commands.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\commands.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Shell\commands.c
      1          
      2          #include <includes.h>
      3          
      4          
      5          SHELL_CMD ShellComms[ MAX_COMMAND_NUM ];
      6          
      7          
      8          void InitCommands( void )
      9          {
     10              SHELL_CMD *pShell = ShellComms ;
     11              unsigned char cmd_index = 1;
     12              
     13          	pShell->num  = cmd_index++;
     14          	pShell->name = "help";
     15          	pShell->CommandFunc = HelpFunc;
     16              pShell->help = "Show descrptions on commands .";
     17              pShell++;
     18              
     19          	pShell->num  = cmd_index++;
     20          	pShell->name = "hostname";
     21          	pShell->CommandFunc = HostNameFunc;
     22              pShell->help = "Print the title and argcs followed.";
     23              pShell++;
     24            
     25              pShell->num  = cmd_index++;
     26          	pShell->name = "setgpio";
     27          	pShell->CommandFunc = WriteGPIOFunc;
     28              pShell->help = "Set Noah defined GPIO.{cmd nGPIO state(0/1/2)} \n\reg: setgpio 1 0";  
     29              pShell++;
     30              
     31              pShell->num  = cmd_index++;
     32          	pShell->name = "initi2c";
     33          	pShell->CommandFunc = InitI2CFunc;
     34              pShell->help = "Re-initialize board I2C port{cmd i2c_speed} \n\reg: initi2c 400";
     35              pShell++;
     36                 
     37              pShell->num  = cmd_index++;
     38          	pShell->name = "ls";
     39          	pShell->CommandFunc = LsFunc;
     40              pShell->help = "List all command supported.";
     41              pShell++;
     42              
     43              pShell->num  = cmd_index++;
     44          	pShell->name = "task";
     45          	pShell->CommandFunc = TaskFunc;
     46              pShell->help = "List all task information.";
     47              pShell++;
     48              
     49              pShell->num  = cmd_index++;
     50          	pShell->name = "reboot";
     51          	pShell->CommandFunc = RebootFunc;
     52              pShell->help = "Reboot the MCU.";
     53              pShell++;
     54              
     55              
     56              
     57              pShell->num  = cmd_index++;
     58          	pShell->name = "readdm";
     59          	pShell->CommandFunc = ReadDMFunc;
     60              pShell->help = "Read DSP DM. {cmd address}\n\reg: readdm 0x2300";
     61              pShell++;
     62              
     63              pShell->num  = cmd_index++;
     64          	pShell->name = "writedm";
     65          	pShell->CommandFunc = WriteDMFunc;
     66              pShell->help = "Write DSP DM.{cmd address data} \n\reg: writedm 0x2300 0x5555";
     67              pShell++;
     68              
     69              pShell->num  = cmd_index++;
     70          	pShell->name = "readpm";
     71          	pShell->CommandFunc = ReadPMFunc;
     72              pShell->help = "Read DSP PM.{cmd address} \n\reg: readpm 0x1000";
     73              pShell++;
     74              
     75              pShell->num  = cmd_index++;
     76          	pShell->name = "writepm";
     77          	pShell->CommandFunc = WritePMFunc;
     78              pShell->help = "Write DSP PM.{cmd address data} \n\reg: writepm 0x1000 0x555555";
     79              pShell++;
     80              
     81              pShell->num  = cmd_index++;
     82          	pShell->name = "readcm";
     83          	pShell->CommandFunc = ReadCMFunc;
     84              pShell->help = "Read DSP CM. {cmd address}\n\reg: readcm 0x37FF";
     85              pShell++;
     86              
     87              pShell->num  = cmd_index++;
     88          	pShell->name = "writecm";
     89          	pShell->CommandFunc = WriteCMFunc;
     90              pShell->help = "Write DSP CM.{cmd address data} \n\reg: writecm 0x3800 0x5555";
     91              pShell++;
     92             
     93              pShell->num  = cmd_index++;
     94          	pShell->name = "readdsp";
     95          	pShell->CommandFunc = ReadDSPREGFunc;
     96              pShell->help = "Read DSP register.{cmd address} \n\reg: readdsp 0x20";
     97              pShell++;
     98              
     99              pShell->num  = cmd_index++;
    100          	pShell->name = "writedsp";
    101          	pShell->CommandFunc = WriteDSPREGFunc;
    102              pShell->help = "Write DSP register.{cmd address data} \n\reg: writedsp 0x20 0x55\n\reg: writedsp 0x30 0x55aa";
    103              pShell++;
    104              
    105              pShell->num  = cmd_index++;
    106          	pShell->name = "readhost";
    107          	pShell->CommandFunc = ReadHostREGFunc;
    108              pShell->help = "Read Host register.{cmd address} \n\reg: readhost 0x80";
    109              pShell++;
    110              
    111              pShell->num  = cmd_index++;
    112          	pShell->name = "writehost";
    113          	pShell->CommandFunc = WriteHostREGFunc;
    114              pShell->help = "Write Host register.{cmd address data} \n\reg: writehost 0x20 0x55\n\reg: writehost 0x30 0x55aa";
    115              pShell++;
    116              
    117              pShell->num  = cmd_index++;
    118          	pShell->name = "ver";
    119          	pShell->CommandFunc = Get_Ver_Info;
    120              pShell->help = "List MCU firmware version info.";
    121              pShell++;
    122              
    123              pShell->num  = cmd_index++;
    124          	pShell->name = "rulerfw";
    125          	pShell->CommandFunc = Write_Ruler_FW;
    126              pShell->help = "Update ruler firmware. {cmd ruler_id}\n\reg: rulerfw 0";
    127              pShell++;
    128          }
    129          
    130          
    131          CPU_INT08U LsFunc( CPU_INT08U argc,CPU_CHAR **argv )
    132          {
    133             
    134              CPU_INT08U i;
    135              
    136              UART_SHELL_SEND_STR(("\n\rCommand list :"));	    
    137              for(i=0;i<MAX_COMMAND_NUM;i++){
    138                  UART_SHELL_SEND_STR(("\n\r %2d. %s",ShellComms[i].num,ShellComms[i].name));
    139                      
    140              } 
    141              return 0;
    142              
    143          }
    144          
    145          
    146          CPU_INT08U TaskFunc( CPU_INT08U argc,CPU_CHAR **argv )
    147          {   
    148              CPU_INT32U temp ;
    149              
    150              temp = 1;
    151              if(argc == 1)  {  
    152                  temp =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    153                  temp =  temp % 10 ;        
    154              }
    155              
    156              Head_Info(); 
    157              
    158              Buzzer_OnOff(1); //buzzer on   
    159              OSTimeDly(10 * temp);  
    160              Buzzer_OnOff(0); //buzzer off
    161              OSTimeDly(30* temp);
    162              Buzzer_OnOff(1); //buzzer on   
    163              OSTimeDly(10* temp);  
    164              Buzzer_OnOff(0); //buzzer off
    165              
    166              return 0;    
    167          }
    168          
    169          
    170          
    171          CPU_INT08U HelpFunc( CPU_INT08U argc,CPU_CHAR **argv )
    172          {
    173            
    174          	CPU_INT08U i;
    175              
    176              if(argc==0){ 
    177                
    178                  UART_SHELL_SEND_STR(("Genieshell only support the following command now. If you wanna use \n\r more functions, pls contact PQ, thx !"));	
    179          	    LsFunc( 0,NULL );
    180                  UART_SHELL_SEND_STR(("\n\r\n\rFor detailed info, pls use command: help [command]\n\r"));	
    181                  UART_SHELL_SEND_STR(("e.g.: help readdm\n\r"));	
    182                  
    183              } else {
    184                
    185                  for( i=0; i<MAX_COMMAND_NUM; i++){           
    186                      if(Str_CmpIgnoreCase(argv[0],ShellComms[i].name) == 0 ){               
    187                          break; //find the command number
    188                      }	
    189                  }						
    190          	    if (i == MAX_COMMAND_NUM ) {
    191                      return 2; //not find it
    192                  }
    193          	    UART_SHELL_SEND_STR((ShellComms[i].help));	
    194                  
    195              }
    196              
    197              return 0;
    198              
    199          }
    200          
    201          
    202          
    203          CPU_INT08U HostNameFunc( CPU_INT08U argc,CPU_CHAR **argv )
    204          {
    205            
    206          	CPU_INT08U i ;
    207              UART_SHELL_SEND_STR(("Hostname is Genies ^_<  : "));	
    208              
    209          	if(argc>0){      
    210                  for(i=0;i<argc;i++){
    211                      UART_SHELL_SEND_STR(("\n\r"));
    212                      UART_SHELL_SEND_STR((argv[i]));	            
    213                  }
    214            	}
    215          	return 0;
    216              
    217          }
    218          
    219          
    220          
    221          
    222          CPU_INT08U WriteGPIOFunc(CPU_INT08U argc,CPU_CHAR **argv)
    223          {
    224              CPU_INT32U temp1, temp2;    
    225          
    226              if(argc != 2)  {
    227                  return 1 ;
    228              }    
    229              temp1 =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    230              temp2 =  Str_ParseNbr_Int32U (argv[1],argv, 16) ;   
    231                
    232              if( temp1 <= 32 && temp2 <= 2) {  
    233                
    234                  if(temp2 == 2) {          
    235                      GPIODIR_FLOAT( temp1  ) ;
    236                      UART_SHELL_SEND_STR(("\n\rSet GPIO %d to Float",temp1));
    237                      
    238                  } else {
    239                      GPIOPIN_Set(temp1  , temp2 );
    240                      UART_SHELL_SEND_STR(("\n\rSet GPIO %d = %d",temp1,temp2));
    241                  }       
    242                  
    243              } else {
    244                return 2 ;
    245                
    246              }  
    247              
    248          	return 0;
    249          
    250           
    251          }
    252          
    253          
    254          CPU_INT08U InitI2CFunc(CPU_INT08U argc,CPU_CHAR **argv)
    255          {
    256              CPU_INT32U temp1;    
    257          
    258              if(argc != 1)  {
    259                  return 1 ;
    260              }    
    261              temp1 =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;      
    262               
    263              if( temp1 <= 400 && temp1 >= 10) { 
    264                  TWI_Init( temp1 * 1000 );     
    265                  UART_SHELL_SEND_STR(("\n\rI2C port is re-initialized to %d kHz",temp1));     
    266                  
    267              }  else {
    268                return 2 ;
    269                
    270              }     
    271          	return 0;
    272           
    273          }
    274          
    275          
    276          CPU_INT08U RebootFunc(CPU_INT08U argc,CPU_CHAR **argv)
    277          {
    278               
    279              UART_SHELL_SEND_STR((">>User cmd reset triggered... \r\n"));     
    280              UART_SHELL_SEND_STR((">>That's all folks !\r\n\r\n>> Rebooting...\r\n"));      
    281              OSTimeDly(1000);
    282              Beep(3); 
    283              AT91C_BASE_RSTC->RSTC_RCR = MCU_SW_RESET_PATTERN ; // do reset processor and peripherals
    284              //while(1);
    285              
    286          	return 0;
    287           
    288          }         
    289          
    290          
    291          
    292          /////////////////////     DSP debug use     ////////////////////////////////////
    293          
    294          
    295          CPU_INT08U ReadDMFunc( CPU_INT08U argc,CPU_CHAR **argv )	
    296          {
    297          	CPU_INT08U errcode  ;
    298              CPU_INT16U address ;
    299              CPU_INT16U data ;
    300              CPU_INT32U temp ;    
    301           
    302              if(argc != 1)  {
    303                  return 1 ;
    304              }    
    305              temp =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    306              if( temp <= 0xFFFF) {  
    307                  address =  temp ;    
    308                  errcode =  DM_LegacyRead(0xC0, address,(unsigned char *)&data);    
    309                  if(errcode == 0) {
    310                      UART_SHELL_SEND_STR(("\n\rRead DM[0x%X] = 0x%X",address,data));	           	
    311                  } else {
    312                      return 3 ;
    313                  }
    314                  
    315              } else {
    316                return 2 ;
    317                
    318              }
    319          	return 0;
    320              
    321          }
    322          
    323          
    324          CPU_INT08U WriteDMFunc( CPU_INT08U argc,CPU_CHAR **argv )	
    325          {
    326          	CPU_INT08U errcode  ;
    327              CPU_INT16U address ;
    328              CPU_INT16U data ;
    329              CPU_INT32U temp1, temp2;
    330              
    331              errcode  = 0 ;
    332              if(argc != 2)  {
    333                  return 1 ;
    334              }    
    335              temp1 =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    336              temp2 =  Str_ParseNbr_Int32U (argv[1],argv, 16) ;
    337              if( temp1 <= 0xFFFF && temp2 <= 0xFFFF) {  
    338                  address =  temp1 ;   
    339                  data    =  temp2 ;
    340                  errcode =  DM_SingleWrite(0xC0,  address, data);      
    341                  if(errcode == 0) {
    342                      UART_SHELL_SEND_STR(("\n\rWrite DM[0x%X] = 0x%X",address,data));	
    343                     	
    344                  }  else {   
    345                      return 3 ;   
    346                      
    347                  }
    348                  
    349              } else {
    350                return 2 ;
    351                
    352              }
    353          	return 0;
    354          }
    355          
    356          
    357           
    358          CPU_INT08U ReadCMFunc( CPU_INT08U argc,CPU_CHAR **argv )	
    359          {
    360          	CPU_INT08U errcode  ;
    361              CPU_INT16U address ;
    362              CPU_INT16U data ;
    363              CPU_INT32U temp ;    
    364           
    365              if(argc != 1)  {
    366                  return 1 ;
    367              }    
    368              temp =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    369              if( temp <= 0xFFFF) {  
    370                  address =  temp ;    
    371                  errcode = CM_LegacyRead( 0xC0, address, (unsigned char *)&data);      
    372                  if(errcode == 0) {
    373                      UART_SHELL_SEND_STR(("\n\rRead CM[0x%X] = 0x%X",address,data));	           	
    374                  } else {
    375                      return 3 ;
    376                  }
    377                  
    378              } else {
    379                return 2 ;
    380                
    381              }
    382          	return 0;
    383              
    384          }
    385          
    386          
    387          CPU_INT08U WriteCMFunc( CPU_INT08U argc,CPU_CHAR **argv )	
    388          {
    389          	CPU_INT08U errcode  ;
    390              CPU_INT16U address ;
    391              CPU_INT16U data ;
    392              CPU_INT32U temp1, temp2;
    393              
    394              errcode  = 0 ;
    395              if(argc != 2)  {
    396                  return 1 ;
    397              }    
    398              temp1 =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    399              temp2 =  Str_ParseNbr_Int32U (argv[1],argv, 16) ;
    400              if( temp1 <= 0xFFFF && temp2 <= 0xFFFF) {  
    401                  address =  temp1 ;   
    402                  data    =  temp2 ;
    403                  errcode =  CM_SingleWrite( 0xC0, address, (unsigned char *)&data);      
    404                  if(errcode == 0) {
    405                      UART_SHELL_SEND_STR(("\n\rWrite CM[0x%X] = 0x%X",address,data));	
    406                     	
    407                  }  else {   
    408                      return 3 ;   
    409                      
    410                  }
    411                  
    412              } else {
    413                return 2 ;
    414                
    415              }
    416          	return 0;
    417          }
    418          
    419           
    420          CPU_INT08U ReadPMFunc( CPU_INT08U argc,CPU_CHAR **argv )	
    421          {
    422          	CPU_INT08U errcode  ;
    423              CPU_INT16U address ;
    424              CPU_INT32U data ;
    425              CPU_INT32U temp ;
    426              
    427              errcode  = 0 ;
    428              if(argc != 1)  {
    429                  return 1 ;
    430              }    
    431              temp =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    432              if( temp <= 0xFFFF) {  
    433                  address =  temp ;    
    434                  errcode =   PM_LegacyRead(0xC0, address,  (CPU_INT08U *)&data ) ;    
    435                  if(errcode == 0) {
    436                      UART_SHELL_SEND_STR(("\n\rRead PM[0x%X] = 0x%X",address,data));	
    437                     	
    438                  } else {
    439                      return 3 ;
    440                
    441                  }
    442                  
    443              } else {
    444                return 2 ;
    445                
    446              }
    447          	return 0;
    448              
    449          }
    450          
    451          
    452          CPU_INT08U WritePMFunc( CPU_INT08U argc,CPU_CHAR **argv )	
    453          {
    454          	CPU_INT08U errcode  ;
    455              CPU_INT16U address ;
    456              CPU_INT32U data ;
    457              CPU_INT32U temp1, temp2;
    458              
    459              errcode  = 0 ;
    460              if(argc != 2)  {
    461                  return 1 ;
    462              }    
    463              temp1 =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    464              temp2 =  Str_ParseNbr_Int32U (argv[1],argv, 16) ;
    465              if( temp1 <= 0xFFFF && temp2 <= 0xFFFFFF) {  
    466                  address =  temp1 ;   
    467                  data    =  temp2 ;          
    468                  errcode = PM_SingleWrite(0xC0, address,  (CPU_INT08U *)&data,0) ;
    469                  if(errcode == 0) {
    470                      UART_SHELL_SEND_STR(("\n\rWrite PM[0x%X] = 0x%X",address,data));	
    471                     	
    472                  } else {
    473                      return 3 ;
    474                
    475                  }
    476                  
    477              } else {
    478                return 2 ;
    479                
    480              }
    481              
    482          	return 0;
    483          }
    484          
    485          
    486          
    487          CPU_INT08U ReadDSPREGFunc( CPU_INT08U argc,CPU_CHAR **argv )	
    488          {
    489          	CPU_INT08U errcode  ;
    490              CPU_INT08U address ;
    491              CPU_INT16U data ;
    492              CPU_INT32U temp ;
    493              
    494              errcode  = 0 ;
    495              if(argc != 1)  {
    496                  return 1 ;
    497              }    
    498              temp =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    499              if( temp <= 0xFF) {  
    500                  address =  temp ;       
    501                  errcode =   DSP_LegacyRead(0xC0, address,(CPU_INT08U *)&data) ;
    502                  if(errcode == 0) {
    503                      UART_SHELL_SEND_STR(("\n\rRead DSP REG[0x%X] = 0x%X",address,data));	
    504                     	
    505                  } else {
    506                      return 3 ;
    507                
    508                  }
    509                  
    510              } else {
    511                return 2 ;
    512                
    513              }
    514          	return 0;
    515              
    516          }
    517          
    518          
    519          
    520          CPU_INT08U WriteDSPREGFunc( CPU_INT08U argc,CPU_CHAR **argv )	
    521          {
    522          	CPU_INT08U errcode  ;
    523              CPU_INT16U address ;
    524              CPU_INT16U data ;
    525              CPU_INT32U temp1, temp2;
    526              
    527              errcode  = 0 ;
    528              if(argc != 2)  {
    529                  return 1 ;
    530              }    
    531              temp1 =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    532              temp2 =  Str_ParseNbr_Int32U (argv[1],argv, 16) ;
    533              
    534              if( temp1 <= 0xFF && temp2 <= 0xFFFF) {  
    535                  address =  temp1 ;   
    536                  data    =  temp2 ; 
    537                  if( data&0xFF00 ) {
    538                      errcode = DSP_SingleWrite_2(0xC0, address, data) ;
    539                  } else {
    540                      errcode = DSP_SingleWrite_1(0xC0, address, (CPU_INT08U)data) ;
    541                  }
    542                  
    543                  if(errcode == 0) {
    544                      UART_SHELL_SEND_STR(("\n\rWrite DSP REG[0x%X] = 0x%X",address,data));	
    545                     	
    546                  } else {
    547                      return 3 ;
    548                
    549                  }
    550                  
    551              } else {
    552                return 2 ;
    553                
    554              }
    555              
    556          	return 0;
    557          }
    558          
    559          
    560          
    561          CPU_INT08U ReadHostREGFunc( CPU_INT08U argc,CPU_CHAR **argv )	
    562          {
    563          	CPU_INT08U errcode  ;
    564              CPU_INT08U address  ;
    565              CPU_INT16U data ;
    566              CPU_INT32U temp ;
    567              
    568              errcode  = 0 ;
    569              if(argc != 1)  {
    570                  return 1 ;
    571              }    
    572              temp =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    573              if( temp <= 0xFF) {  
    574                  address =  temp ;       
    575                  errcode =   HOST_LegacyRead(0xC0, address,(CPU_INT08U *)&data) ;
    576                  if(errcode == 0) {
    577                      UART_SHELL_SEND_STR(("\n\rRead Host REG[0x%X] = 0x%X",address,data));	
    578                     	
    579                  } else {
    580                      return 3 ;
    581                
    582                  }
    583                  
    584              } else {
    585                return 2 ;
    586                
    587              }
    588          	return 0;
    589              
    590          }
    591          
    592          
    593          
    594          CPU_INT08U WriteHostREGFunc( CPU_INT08U argc,CPU_CHAR **argv )	
    595          {
    596              
    597          	CPU_INT08U errcode  ;
    598              CPU_INT16U address ;
    599              CPU_INT16U data ;
    600              CPU_INT32U temp1, temp2;
    601              
    602              errcode  = 0 ;
    603              if(argc != 2)  {
    604                  return 1 ;
    605              }    
    606              temp1 =  Str_ParseNbr_Int32U (argv[0],argv, 16) ;
    607              temp2 =  Str_ParseNbr_Int32U (argv[1],argv, 16) ;
    608              
    609              if( temp1 <= 0xFF && temp2 <= 0xFFFF) {  
    610                  address =  temp1 ;   
    611                  data    =  temp2 ; 
    612                  if( data&0xFF00 ) {
    613                      errcode = HOST_SingleWrite_2(0xC0, address, data) ;
    614                  } else {
    615                      errcode = HOST_SingleWrite_1(0xC0, address, (CPU_INT08U)data) ;
    616                  }
    617                  
    618                  if(errcode == 0) {
    619                      UART_SHELL_SEND_STR(("\n\rWrite Host REG[0x%X] = 0x%X",address,data));	
    620                     	
    621                  } else {
    622                      return 3 ;
    623                
    624                  }
    625                  
    626              } else {
    627                return 2 ;
    628                
    629              }
    630              
    631          	return 0;
    632          }
    633          
    634          CPU_INT08U Write_Ruler_FW( CPU_INT08U argc,CPU_CHAR **argv )	
    635          {   
    636              CPU_INT08U errcode  ;
    637              CPU_INT32U temp;
    638              
    639              errcode  = 0 ;
    640              if(argc != 1)  {
    641                  return 1 ;
    642              }    
    643              
    644              temp =  Str_ParseNbr_Int32U (argv[0],argv, 16) ; 
    645              
    646              if( temp <= 3 ) {      
    647                  errcode = Update_Ruler_FW( temp );        
    648                  if(errcode != 0) {           
    649                      return 3 ;
    650                  }   
    651                  
    652              } else {
    653                  
    654                return 2 ;
    655                
    656              }
    657              
    658          	return 0;
    659          }
    660          
    661          
    662          CPU_INT08U Get_Ver_Info( CPU_INT08U argc,CPU_CHAR **argv )	
    663          {
    664              
    665              UART_SHELL_SEND_STR(("\n\rHost  MCU Version : %s",fw_version));
    666              UART_SHELL_SEND_STR(("\n\rAudio MCU Version : %s",Audio_Version));	 
    667          
    668              return 0;
    669          }
    670          
    671          
    672          
    673          
    674          
    675          CPU_INT08U CommandParse( CPU_CHAR *Buf, CPU_INT08U *p_argc, CPU_CHAR *argv[] )
    676          {
    677            
    678          	CPU_INT08U i;
    679          	CPU_INT08U pointer;
    680          	CPU_INT08U num;
    681              CPU_INT08U argc;
    682          	CPU_CHAR   name[MAX_COMMAND_NAME_LENGTH+1];		//SHELL_CMD name length <20
    683          
    684          	argc    = 0;            
    685          	pointer = 0;
    686          	num     = 0;
    687              
    688          	UART_SHELL_SEND_STR(("\n\r"));
    689          
    690          	while((Buf[pointer]!=' ') && (Buf[pointer]!='\0') && (pointer < MAX_COMMAND_NAME_LENGTH) ) {
    691          		name[pointer]=Buf[pointer];
    692          		pointer++;
    693          	}    
    694          	name[pointer] = '\0';	//now got the command name, and pointer is to the first space in the Buf
    695              pointer = 0;
    696              
    697          	for( i=0; i<MAX_COMMAND_NUM; i++){
    698          		//if(!strcmp(name,ShellComms[i].name)){
    699                  if(Str_CmpIgnoreCase(name,ShellComms[i].name) == 0 ){
    700          			num = i;
    701          			break; //find the command number
    702          		}	
    703          	}						
    704          	if (i == MAX_COMMAND_NUM ) return ERRORCOMMAND; //not find it
    705          					
    706          	while( Buf[pointer]!='\0') {
    707                
    708          		if(Buf[pointer]==' ') {
    709          			if(argc>0){
    710          				Buf[pointer] = '\0';			//end of last argv
    711          			}
    712          			pointer++;
    713          			argv[argc] = &Buf[pointer];			//add a parameter for every space
    714          			argc++;
    715                      
    716          		} else {          
    717          			pointer++;
    718                      
    719          		}
    720          	}//while
    721              
    722              *p_argc = argc ;    
    723          	return ( num );
    724              
    725          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   CommandParse
        56   -> BSP_Ser_Printf
        56   -> Str_CmpIgnoreCase
      16   Get_Ver_Info
        16   -> BSP_Ser_Printf
      16   HelpFunc
        16   -> BSP_Ser_Printf
        16   -> LsFunc
        16   -> Str_CmpIgnoreCase
      16   HostNameFunc
        16   -> BSP_Ser_Printf
       0   InitCommands
      16   InitI2CFunc
        16   -> BSP_Ser_Printf
        16   -> Str_ParseNbr_Int32U
        16   -> TWI_Init
      16   LsFunc
        16   -> BSP_Ser_Printf
      32   ReadCMFunc
        32   -> BSP_Ser_Printf
        32   -> CM_LegacyRead
        32   -> Str_ParseNbr_Int32U
      32   ReadDMFunc
        32   -> BSP_Ser_Printf
        32   -> DM_LegacyRead
        32   -> Str_ParseNbr_Int32U
      32   ReadDSPREGFunc
        32   -> BSP_Ser_Printf
        32   -> DSP_LegacyRead
        32   -> Str_ParseNbr_Int32U
      32   ReadHostREGFunc
        32   -> BSP_Ser_Printf
        32   -> HOST_LegacyRead
        32   -> Str_ParseNbr_Int32U
      32   ReadPMFunc
        32   -> BSP_Ser_Printf
        32   -> PM_LegacyRead
        32   -> Str_ParseNbr_Int32U
      16   RebootFunc
        16   -> BSP_Ser_Printf
        16   -> Beep
        16   -> OSTimeDly
      16   TaskFunc
        16   -> Buzzer_OnOff
        16   -> Head_Info
        16   -> OSTimeDly
        16   -> Str_ParseNbr_Int32U
        16   -> __aeabi_uidivmod
      32   WriteCMFunc
        32   -> BSP_Ser_Printf
        32   -> CM_SingleWrite
        32   -> Str_ParseNbr_Int32U
      32   WriteDMFunc
        32   -> BSP_Ser_Printf
        32   -> DM_SingleWrite
        32   -> Str_ParseNbr_Int32U
      32   WriteDSPREGFunc
        32   -> BSP_Ser_Printf
        32   -> DSP_SingleWrite_1
        32   -> DSP_SingleWrite_2
        32   -> Str_ParseNbr_Int32U
      24   WriteGPIOFunc
        24   -> BSP_Ser_Printf
        24   -> GPIODIR_FLOAT
        24   -> GPIOPIN_Set
        24   -> Str_ParseNbr_Int32U
      32   WriteHostREGFunc
        32   -> BSP_Ser_Printf
        32   -> HOST_SingleWrite_1
        32   -> HOST_SingleWrite_2
        32   -> Str_ParseNbr_Int32U
      32   WritePMFunc
        32   -> BSP_Ser_Printf
        32   -> PM_SingleWrite
        32   -> Str_ParseNbr_Int32U
      24   Write_Ruler_FW
        24   -> Str_ParseNbr_Int32U
        24   -> Update_Ruler_FW


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      44  ?<Constant ">>That\'s all folks !\r...">
      36  ?<Constant ">>User cmd reset trig...">
     112  ?<Constant "Genieshell only suppo...">
      28  ?<Constant "Hostname is Genies ^_...">
      32  ?<Constant "List MCU firmware ver...">
      28  ?<Constant "List all command supp...">
      28  ?<Constant "List all task informa...">
      36  ?<Constant "Print the title and a...">
      64  ?<Constant "Re-initialize board I...">
      48  ?<Constant "Read DSP CM. {cmd add...">
      48  ?<Constant "Read DSP DM. {cmd add...">
      48  ?<Constant "Read DSP PM.{cmd addr...">
      52  ?<Constant "Read DSP register.{cm...">
      56  ?<Constant "Read Host register.{c...">
      16  ?<Constant "Reboot the MCU.">
      68  ?<Constant "Set Noah defined GPIO...">
      32  ?<Constant "Show descrptions on c...">
      56  ?<Constant "Update ruler firmware...">
      60  ?<Constant "Write DSP CM.{cmd add...">
      60  ?<Constant "Write DSP DM.{cmd add...">
      64  ?<Constant "Write DSP PM.{cmd add...">
      92  ?<Constant "Write DSP register.{c...">
      92  ?<Constant "Write Host register.{...">
      12  ?<Constant "\n\r %2d. %s">
       4  ?<Constant "\n\r">
      28  ?<Constant "\n\rAudio MCU Version : %s">
      20  ?<Constant "\n\rCommand list :">
      28  ?<Constant "\n\rHost  MCU Version : %s">
      40  ?<Constant "\n\rI2C port is re-init...">
      24  ?<Constant "\n\rRead CM[0x%X] = 0x%X">
      24  ?<Constant "\n\rRead DM[0x%X] = 0x%X">
      28  ?<Constant "\n\rRead DSP REG[0x%X] ...">
      32  ?<Constant "\n\rRead Host REG[0x%X]...">
      24  ?<Constant "\n\rRead PM[0x%X] = 0x%X">
      20  ?<Constant "\n\rSet GPIO %d = %d">
      24  ?<Constant "\n\rSet GPIO %d to Float">
      24  ?<Constant "\n\rWrite CM[0x%X] = 0x%X">
      24  ?<Constant "\n\rWrite DM[0x%X] = 0x%X">
      32  ?<Constant "\n\rWrite DSP REG[0x%X]...">
      32  ?<Constant "\n\rWrite Host REG[0x%X...">
      24  ?<Constant "\n\rWrite PM[0x%X] = 0x%X">
      60  ?<Constant "\n\r\n\rFor detailed info...">
      20  ?<Constant "e.g.: help readdm\n\r">
       8  ?<Constant "help">
      12  ?<Constant "hostname">
       8  ?<Constant "initi2c">
       4  ?<Constant "ls">
       8  ?<Constant "readcm">
       8  ?<Constant "readdm">
       8  ?<Constant "readdsp">
      12  ?<Constant "readhost">
       8  ?<Constant "readpm">
       8  ?<Constant "reboot">
       8  ?<Constant "rulerfw">
       8  ?<Constant "setgpio">
       8  ?<Constant "task">
       4  ?<Constant "ver">
       8  ?<Constant "writecm">
       8  ?<Constant "writedm">
      12  ?<Constant "writedsp">
      12  ?<Constant "writehost">
       8  ?<Constant "writepm">
       4  ??DataTable0
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_18
       4  ??DataTable17_19
       4  ??DataTable17_2
       4  ??DataTable17_20
       4  ??DataTable17_21
       4  ??DataTable17_22
       4  ??DataTable17_23
       4  ??DataTable17_24
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_15
       4  ??DataTable18_16
       4  ??DataTable18_17
       4  ??DataTable18_18
       4  ??DataTable18_19
       4  ??DataTable18_2
       4  ??DataTable18_20
       4  ??DataTable18_21
       4  ??DataTable18_22
       4  ??DataTable18_23
       4  ??DataTable18_24
       4  ??DataTable18_25
       4  ??DataTable18_26
       4  ??DataTable18_27
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
       4  ??DataTable4
       4  ??DataTable8
     420  CommandParse
      48  Get_Ver_Info
     204  HelpFunc
     108  HostNameFunc
     696  InitCommands
     124  InitI2CFunc
     116  LsFunc
     172  ReadCMFunc
     172  ReadDMFunc
     172  ReadDSPREGFunc
     172  ReadHostREGFunc
     180  ReadPMFunc
      76  RebootFunc
     304  ShellComms
     156  TaskFunc
     208  WriteCMFunc
     228  WriteDMFunc
     264  WriteDSPREGFunc
     172  WriteGPIOFunc
     264  WriteHostREGFunc
     212  WritePMFunc
     132  Write_Ruler_FW

 
   304 bytes in section .bss
 1 884 bytes in section .rodata
 4 632 bytes in section .text
 
 4 632 bytes of CODE  memory
 1 884 bytes of CONST memory
   304 bytes of DATA  memory

Errors: none
Warnings: none
