###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        05/Sep/2014  09:57:04
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\gpio.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\gpio.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\gpio.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\gpio.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\Driver\gpio.c
      1          #include <includes.h>
      2          
      3          GPIOPIN   GpioPin  ;
      4          GPIODIR   GpioDir  ;
      5          GPIOPORT  GpioPort ;
      6          
      7          unsigned int MonitCount = 0;
      8          unsigned char setdir    = 0;
      9          
     10          
     11          //inner use
     12          static Pin pinsGpios[]  = {   
     13              
     14              UART1_SEL0,   UART1_SEL1,   UART2_SEL0,   UART2_SEL1, // 0 ~ 3
     15              GPIO_PDM_OE,  GPIO_PWR_CTR, GPIO_SPK_OFF, GPIO_AUDIO_RST, GPIO_FM_RST, // 4 ~ 8
     16              PORT_DETECT0, PORT_DETECT1, PORT_DETECT2, PORT_DETECT3, // 9 ~ 12 
     17              LED1,         LED2, // 13 ~ 14
     18              PORT_LED0,    PORT_LED1,    PORT_LED2,    PORT_LED3, // 15 ~18
     19              BUZZER,       FPGA_CS,      FPGA_DAT,     FPGA_CLK    // 19 ~ 22
     20                                            
     21                                     };
     22          
     23          //switch pins
     24          static const Pin pinsSwitches[] = {   SW0,  SW1  };
     25          
     26          
     27          static const unsigned int numGpios = PIO_LISTSIZE(pinsGpios);
     28          
     29          
     30          
     31          
     32          void GPIO_Init(void)
     33          {  
     34            
     35              PIO_Configure( pinsSwitches,  PIO_LISTSIZE(pinsSwitches) );
     36              PIO_Configure( pinsGpios,    PIO_LISTSIZE(pinsGpios)     );          
     37              //PIO_InitializeInterrupts( AT91C_AIC_PRIOR_LOWEST );     
     38              //LED_Configure(LED_DS1);
     39              //LED_Configure(LED_DS2);
     40              
     41          }
     42          
     43          
     44          
     45          void GPIODIR_FLOAT( unsigned int pin  ) // 
     46          {  
     47               unsigned int i; 
     48               
     49               for(i=0; i<numGpios; i++)
     50               {       
     51                 if( pin>>i & 0x01 )
     52                 {             
     53                     pinsGpios[i].attribute  = PIO_DEFAULT ; 
     54                     pinsGpios[i].type       = PIO_INPUT   ;            
     55                     PIO_Configure(&pinsGpios[i], 1);
     56                 }
     57                 
     58               }
     59          
     60             
     61          }
     62          
     63          ////ranfunc for a faster execution 
     64          //void GPIOPIN_Set(unsigned int pin , unsigned int dat)
     65          //{  
     66          //    unsigned int i; 
     67          //    
     68          //    for( i=0; i < numGpios; i++ ) {       
     69          //        if( (pin >> i) & 0x01 ) { 
     70          //            pinsGpios[i].attribute  = PIO_PULLUP ;                   
     71          //            if( (dat >> i) & 0x01 ) {
     72          //              pinsGpios[i].type    = PIO_OUTPUT_1   ;  
     73          //              
     74          //            } else {
     75          //              pinsGpios[i].type    = PIO_OUTPUT_0   ; 
     76          //              
     77          //            }
     78          //            PIO_Configure(&pinsGpios[i], 1);
     79          //            
     80          //       }
     81          //       
     82          //     } 
     83          //    
     84          //}
     85          
     86          
     87          //ranfunc for a faster execution 
     88          void GPIOPIN_Set(unsigned int pin , unsigned int dat)
     89          {  
     90          
     91          
     92          
     93          
     94              pinsGpios[pin].attribute  = PIO_PULLUP ;                   
     95              if( dat  & 0x01 ) {
     96                   PIO_Set(&pinsGpios[pin]);
     97                        
     98              } else {
     99                  PIO_Clear(&pinsGpios[pin]);
    100                        
    101              }
    102                   
    103          
    104              
    105          }
    106          
    107          //// additional time delay :  +10us
    108          //// so, the critical time delay is 11us
    109          void  __ramfunc GPIOPIN_Set_Session( unsigned int pin , unsigned int dat )
    110          {    
    111              unsigned int i; 
    112              
    113              for( i=0; i < 28; i++ ) {  //here 28 is used instead of numGpios for speed up !
    114                
    115                  if( pin & 0x01<<i ) { 
    116                                      
    117                      if( dat  & 0x01<<i ) {
    118                          //PIO_Set( &pinsGpios[i]);
    119                          pinsGpios[i].pio->PIO_SODR = pinsGpios[i].mask;
    120                      } else {
    121                          //PIO_Clear( &pinsGpios[i]);
    122                          pinsGpios[i].pio->PIO_CODR = pinsGpios[i].mask;              
    123                      }              
    124                  }         
    125               }     
    126          }
    127          
    128          
    129          typedef struct __MONITCTR 
    130          {
    131              unsigned char DataType ;
    132              unsigned short  DataNum ;
    133              
    134          }MONITCTR ;
    135          
    136          
    137          unsigned int GPIOPIN_Read(void)
    138          {
    139            /*pq
    140              GpioPin.portStt.porta = GPIO_ReadPin(PA) ;
    141              GpioPin.portStt.portc = GPIO_ReadPin(PC) ;
    142              GpioPin.portStt.portg = GPIO_ReadPin(PG) ;
    143              GpioPin.portStt.portj = GPIO_ReadPin(PJ) ;
    144              
    145              return(GpioPin.pinStt & PINMASK) ;
    146            */
    147            return 0;
    148          }
    149          
    150          
    151          void  RecordGpio(
    152                         unsigned char pTime,  /*读取数据的时间间隔,单位为uS*/
    153                         unsigned short  dTime,  /*记录数据时间长度,单位为mS*/
    154                         void *p               /*存放数据位置*/
    155                         )
    156          {
    157            
    158              /*pq
    159              MONITCTR *pMonitCtr = (MONITCTR *)DataBufCtr.pBufTop ;
    160              unsigned char *pDataSt ;
    161              unsigned short tdelay ;
    162              DataBufCtr.pBufTop += 3 ;
    163              pMonitCtr->DataType = DATA_TYPE_MONIT ;
    164          
    165              pDataSt  = DataBufCtr.pBufTop ;
    166              MonitCount = 0;
    167              pinb = 0x76;
    168              
    169              TIMER_Open_8bit(0,T_INT_EN|T_PRS_8, pTime-2) ;
    170          
    171              while(dTime)
    172              {
    173                  tdelay = ((dTime>4000)? 4000:dTime) ;
    174                  dTime -= tdelay ;
    175                  CtrFlage.Time3Over = 0 ;
    176                  
    177                  TIMER_Open_16bit(3,T_INT_EN|T_PRS_1024, tdelay) ;
    178                  
    179                  while(!CtrFlage.Time3Over) ;
    180              }
    181          
    182              TCCR0B &= 0xf8 ;      // 关闭定时器0
    183              OCR0A = 0;            
    184              OCR0B = 0;    
    185              *(unsigned int *)DataBufCtr.pBufTop = MonitCount ;
    186              DataBufCtr.pBufTop += 4 ;
    187              *(DataBufCtr.pBufTop++) = PINB ;
    188              *(DataBufCtr.pBufTop++) = PINC ;
    189              *(DataBufCtr.pBufTop++) = PIND ;
    190                DataBufCtr.pBufTop++ ;
    191              pMonitCtr->DataNum = (DataBufCtr.pBufTop - pDataSt)/8 ;
    192            
    193              */
    194          }
    195          
    196          
    197          
    198          
    199          
    200          
    201          void Ruler_Power_Switch( unsigned char onoff )
    202          {
    203          
    204              pinsGpios[5].type = (onoff == 0) ? PIO_OUTPUT_0 : PIO_OUTPUT_1 ;
    205              PIO_Configure(&pinsGpios[5], 1);   
    206              
    207          }
    208          
    209          
    210          
    211          
    212          //Ruler MCU selector
    213          void UART1_Mixer( unsigned char index )
    214          {      
    215              unsigned char i; 
    216              //OSTimeDly(1000);
    217              if( index<= 3) {      
    218                  for( i=0; i<=1; i++) {        
    219                      pinsGpios[i].type = (index & (1<<i) ) == 0 ? PIO_OUTPUT_0 : PIO_OUTPUT_1 ;
    220                      PIO_Configure(&pinsGpios[i], 1);   
    221                
    222                  }      
    223              
    224              }   
    225              //OSTimeDly(50);
    226            
    227          }
    228          
    229          
    230          //Audio MCU selector
    231          void UART2_Mixer( unsigned char index )
    232          {  
    233              
    234          #ifdef BOARD_TYPE_AB01     
    235              unsigned char i; 
    236            
    237              if( index<= 3) {      
    238                  for( i=2; i<=3; i++) {        
    239                      pinsGpios[i].type = (index & (1<<(i-2)) ) == 0 ? PIO_OUTPUT_0 : PIO_OUTPUT_1 ;
    240                      PIO_Configure(&pinsGpios[i], 1);   
    241                
    242                  }      
    243              
    244              }   
    245          #endif  
    246          }
    247          
    248          
    249          unsigned int Get_Switches( void )
    250          {
    251                
    252              unsigned char i     =   0 ;
    253              unsigned int  value =   0 ;
    254            
    255              for( i=0; i<PIO_LISTSIZE( pinsSwitches ); i++ ) {      
    256                  value <<= 1;
    257                  value +=PIO_Get( &pinsSwitches[i] );
    258              }
    259              
    260              return value;
    261            
    262          }
    263          
    264          
    265          
    266          unsigned int Get_Port_Detect( void )
    267          {
    268              
    269              unsigned char i     =   0 ;
    270              unsigned int  value =   0 ;   
    271          
    272              for( i=9; i<=12; i++ ) {      
    273                  value <<= 1;
    274                  value +=PIO_Get( &pinsGpios[i] );
    275              }
    276                     
    277              return value;   
    278          
    279          }
    280          
    281          
    282          
    283          //note: turn off and on to update a ruler firmware, hwo about other ruler connections , issue ???
    284          void Ruler_PowerOnOff( unsigned char switches ) 
    285          {
    286              
    287              if( switches == 0 ) { //power off
    288                  PIO_Clear(&pinsGpios[5]);  
    289              } else { //power on
    290                  PIO_Set(&pinsGpios[5]);  
    291              }
    292               
    293          }
    294          
    295          
    296          void Pin_Reset_FM36( void )
    297          {
    298          
    299              PIO_Clear(&pinsGpios[8]);
    300              OSTimeDly(20) ;
    301              PIO_Set(&pinsGpios[8]);
    302              OSTimeDly(50) ;
    303               
    304          }
    305          
    306          
    307          void Pin_Reset_Audio_MCU( void )
    308          {
    309          
    310              PIO_Clear(&pinsGpios[7]);
    311              OSTimeDly(20) ;
    312              PIO_Set(&pinsGpios[7]);
    313              OSTimeDly(20) ;
    314               
    315          }
    316          
    317          void Enable_FPGA( void )
    318          {
    319              
    320              PIO_Set(&pinsGpios[4]);   
    321               
    322          }
    323          
    324          
    325          void Disable_FPGA( void )
    326          {
    327              
    328              PIO_Clear(&pinsGpios[4]);    
    329               
    330          }
    331          
    332          
    333          
    334          //Note: This routine do NOT support reentrance
    335          //SPI simulation for FPGA control timing requirement
    336          //31 bits control 31 mics on 4 rulers, 1- enable, 0- disable
    337          //channels[7..0]   : ruler0_mic[7..0]
    338          //channels[15..8]  : ruler1_mic[7..0]
    339          //channels[23..16] : ruler2_mic[7..0]
    340          //channels[31..24] : ruler3_mic[7..0]
    341          void Init_FPGA( unsigned int channels )
    342          {
    343             
    344              unsigned int i ;
    345              APP_TRACE_DBG(("Init FPGA...[0x%0X] \r\n",channels));
    346              PIO_Set(&pinsGpios[20]); //cs 
    347              PIO_Set(&pinsGpios[21]); //data 
    348              PIO_Set(&pinsGpios[22]); //clock
    349              for ( i = 0; i < 32; i++ ) {        
    350                 PIO_Clear(&pinsGpios[20]); //cs, delay compensation
    351                 PIO_Clear(&pinsGpios[22]); //clock       
    352                 if( (channels<<i) & 0x80000000 ) {
    353                     PIO_Set(&pinsGpios[21]); //data 
    354                 } else {
    355                     PIO_Clear(&pinsGpios[21]); //data 
    356                 }
    357                 PIO_Set(&pinsGpios[22]); //clock
    358              }    
    359              PIO_Set(&pinsGpios[20]); //cs 
    360              
    361          }
    362          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Disable_FPGA
         8   -> PIO_Clear
       8   Enable_FPGA
         8   -> PIO_Set
      16   GPIODIR_FLOAT
        16   -> PIO_Configure
       0   GPIOPIN_Read
      16   GPIOPIN_Set
        16   -> PIO_Clear
        16   -> PIO_Set
       4   GPIOPIN_Set_Session
       8   GPIO_Init
         8   -> PIO_Configure
      16   Get_Port_Detect
        16   -> PIO_Get
      16   Get_Switches
        16   -> PIO_Get
      16   Init_FPGA
        16   -> PIO_Clear
        16   -> PIO_Set
       8   Pin_Reset_Audio_MCU
         8   -> OSTimeDly
         8   -> PIO_Clear
         8   -> PIO_Set
       8   Pin_Reset_FM36
         8   -> OSTimeDly
         8   -> PIO_Clear
         8   -> PIO_Set
       0   RecordGpio
       8   Ruler_PowerOnOff
         8   -> PIO_Clear
         8   -> PIO_Set
       8   Ruler_Power_Switch
         8   -> PIO_Configure
      16   UART1_Mixer
        16   -> PIO_Configure
       0   UART2_Mixer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      20  Disable_FPGA
      20  Enable_FPGA
     120  GPIODIR_FLOAT
       8  GPIOPIN_Read
      84  GPIOPIN_Set
     132  GPIOPIN_Set_Session
      36  GPIO_Init
      92  Get_Port_Detect
      92  Get_Switches
       4  GpioDir
       4  GpioPin
       4  GpioPort
     128  Init_FPGA
       4  MonitCount
      44  Pin_Reset_Audio_MCU
      44  Pin_Reset_FM36
       4  RecordGpio
      52  Ruler_PowerOnOff
      64  Ruler_Power_Switch
     148  UART1_Mixer
       4  UART2_Mixer
       4  numGpios
     276  pinsGpios
      24  pinsSwitches
       1  setdir

 
    17 bytes in section .bss
   276 bytes in section .data
    28 bytes in section .rodata
 1 000 bytes in section .text
   132 bytes in section .textrw
 
 1 132 bytes of CODE  memory
    28 bytes of CONST memory
   293 bytes of DATA  memory

Errors: none
Warnings: none
