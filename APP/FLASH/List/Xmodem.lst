###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        13/Jun/2014  16:27:51
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\BSP\Xmodem.c
#    Command line =  
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\BSP\Xmodem.c" -lcN
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -lb
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\" -o
#        "E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=ARM7TDMI -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\BSP\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Driver\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Noah\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\Shell\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uCOS-II\Source\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uC-CPU\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-LIB\" -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-CPU\ARM\IAR\" -I "E:\SVN Dir\PQ\iSAM
#        Test Bench\Bridge_Host_OS\APP\..\uCOS-II\Ports\ARM\Generic\IAR\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\Atmel\AT91SAM7X\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Communication\Generic\Source\"
#        -I "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Plugins\uCOS-II\" -I
#        "E:\SVN Dir\PQ\iSAM Test
#        Bench\Bridge_Host_OS\APP\..\uC-Probe\Target\Demos\Intro\Source\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\List\Xmodem.lst
#    Object file  =  
#        E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\APP\FLASH\Obj\Xmodem.o
#
###############################################################################

E:\SVN Dir\PQ\iSAM Test Bench\Bridge_Host_OS\BSP\Xmodem.c
      1          /*
      2          *********************************************************************************************************
      3          *                               iSAM TEST BENCH AUDIO BRIDGE BOARD APP PACKAGE
      4          *
      5          *                            (c) Copyright 2013 - 2016; Fortemedia Inc.; Nanjing, China
      6          *
      7          *                   All rights reserved.  Protected by international copyright laws.
      8          *                   Knowledge of the source code may not be used to write a similar
      9          *                   product.  This file may only be used in accordance with a license
     10          *                   and should not be redistributed in any way.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                            APP PACKAGE
     18          *
     19          *                                          Atmel AT91SAM7A3
     20          *                                               on the
     21          *                                      iSAM Audio Bridge Board
     22          *
     23          * Filename      : Xmodem.c
     24          * Version       : V1.0.0
     25          * Programmer(s) : PQ
     26          *********************************************************************************************************
     27          * Note(s)       :
     28          *********************************************************************************************************
     29          */
     30          
     31          #include <includes.h>
     32           
     33          /*
     34          *********************************************************************************************************
     35          *                                       calc_crc()
     36          *
     37          * Description :  calculate CRC16 data
     38          *               
     39          * Argument(s) :  *ptr :  pointer to data need to calculate CRC   
     40          *                count:  data size 
     41          *
     42          * Return(s)   : CRC data
     43          *
     44          * Note(s)     : None.
     45          *********************************************************************************************************
     46          */
     47          static unsigned short calc_crc(unsigned char *ptr, signed short count)
     48          {
     49              
     50              unsigned short crc = 0;
     51              unsigned char  i;
     52              while (--count >= 0)
     53              {
     54                  crc = crc ^ (int) *ptr++ << 8;
     55                  i = 8;
     56                  do
     57                  {
     58                      if (crc & 0x8000)
     59                          crc = crc << 1 ^ 0x1021;
     60                      else
     61                          crc = crc << 1;
     62                  } while(--i);
     63              }
     64              return (crc);
     65              
     66          }
     67          
     68          
     69          static void flushinput(void)
     70          {
     71          	//while (_inbyte(((DLY_1S)*3)>>1) >= 0);
     72              //unsigned char c;
     73              //while( USART_Read_Timeout( RULER_UART, &c, 1, 100 ) ==0 );
     74              
     75          }
     76          
     77          /*
     78          *********************************************************************************************************
     79          *                                       Xmodem_Transmit()
     80          *
     81          * Description :  Xmodem data transfer function.
     82          *               
     83          * Argument(s) :  *src :  pointer to data need to transmit 
     84          *                srcsz:  data szie to be transmit 
     85          *
     86          * Return(s)   : NO_ERR :   execute successfully
     87          *               others :   =error code .  
     88          *
     89          * Note(s)     : None.
     90          *********************************************************************************************************
     91          */
     92          unsigned char Xmodem_Transmit( unsigned char *src, int srcsz )
     93          {
     94          	unsigned char  xbuff[XMODEM_PACK_SIZE+5]; //xModem  1SOH + 2PACK_NO + 128 DATA + 2CRC = 133
     95              unsigned short crc;
     96          	unsigned char  packetno = 1;
     97          	int c, len = 0;
     98              unsigned char  temp;
     99          	unsigned char  i;
    100              unsigned char  err;
    101              
    102              err = 0; //no err
    103          
    104          	for(;;) {   
    105                  
    106          		for( i = 0; i < MAX_RETRANS; ++i) {
    107                      temp = 0 ;
    108                      if( USART_Read_Timeout( RULER_UART, &temp, 1, 1000 ) == 0 ) {	
    109          				switch (temp) {
    110          				case 'C':				
    111          					goto start_trans;
    112          				case NAK:			
    113          					goto start_trans;
    114          				case CAN:
    115                              temp  = 0 ;
    116                              USART_Read_Timeout( RULER_UART, &temp, 1, 1000 );
    117          					if (temp == CAN) {
    118          						USART_SendByte( RULER_UART, ACK);
    119          						flushinput();
    120          						return XMODEM_CANCEL_ERR; /* canceled by remote */
    121          					}
    122          					break;
    123          				default:
    124          					break;
    125          				}
    126          			}
    127          		}
    128          		USART_SendByte( RULER_UART, CAN);
    129          		USART_SendByte( RULER_UART, CAN);
    130          		USART_SendByte( RULER_UART, CAN);
    131          		flushinput();
    132          		return XMODEM_SYNC_ERR; /* no sync */
    133          
    134          		while(1) {
    135                      
    136          		start_trans:
    137                      Buzzer_Toggle();          
    138          			xbuff[0] = SOH; 
    139          			xbuff[1] = packetno;
    140          			xbuff[2] = ~packetno;
    141                      
    142          			if ( len < srcsz ) {
    143                          
    144                          c = srcsz - len;
    145                          c = c > XMODEM_PACK_SIZE ? XMODEM_PACK_SIZE : c ;               
    146          				memset (&xbuff[3], 0, XMODEM_PACK_SIZE); //padding 0			
    147          				memcpy (&xbuff[3], src+len, c);
    148          			    crc = calc_crc(&xbuff[3], XMODEM_PACK_SIZE);
    149          				xbuff[XMODEM_PACK_SIZE+3] = (crc>>8) & 0xFF;
    150          				xbuff[XMODEM_PACK_SIZE+4] = crc & 0xFF;				
    151          	
    152          				for (i = 0; i < MAX_RETRANS; ++i) {                   
    153                              USART_SendBuf( RULER_UART, xbuff,  sizeof(xbuff));  
    154                              temp  = 0 ;
    155                              if( USART_Read_Timeout( RULER_UART, &temp, 1, 5000 ) == 0 ) {
    156          						switch (temp) {
    157          						case ACK:
    158          							packetno++;
    159          							len += c;
    160                                      APP_TRACE_INFO(("> "));                             
    161          							goto start_trans;
    162                                      
    163          						case CAN:
    164                                      APP_TRACE_INFO(("CAN "));                  
    165                                      temp  = 0 ;
    166                                      USART_Read_Timeout( RULER_UART, &temp, 1, 1000 );
    167                                      if (temp == CAN) {
    168                                          USART_SendByte( RULER_UART, ACK);
    169          								flushinput();
    170                                          Buzzer_OnOff(0);                                
    171          								return XMODEM_CANCEL_ERR; /* canceled by remote */
    172          							}
    173          							break;
    174          						case NAK:
    175                                      APP_TRACE_INFO(("NAK ")); 
    176          						default:
    177                                      APP_TRACE_INFO(("DEFAULT ")); 
    178          							break;
    179          						}
    180          					}
    181                              
    182          				}
    183          	            USART_SendByte( RULER_UART, CAN);
    184          		        USART_SendByte( RULER_UART, CAN);
    185          		        USART_SendByte( RULER_UART, CAN);
    186          				flushinput();
    187                          Buzzer_OnOff(0);
    188          				return XMODEM_TRANS_ERR; /* xmit error */
    189                          
    190          			} else {
    191                          err = XMODEM_TRANS_END_ERR;
    192                          temp  = 0 ;
    193          				for (i = 0; i < MAX_RETRANS; ++i) {
    194          					USART_SendByte( RULER_UART,EOT);                   
    195                              USART_Read_Timeout( RULER_UART, &temp, 1, 1000 );
    196                              if (temp == ACK) {
    197                                  err = 0;
    198                                  break;
    199                              } 
    200          				}           
    201                          flushinput();
    202                          Buzzer_OnOff(0);                
    203          				return err;
    204          			}
    205                      
    206          		}
    207                  
    208                  
    209          	}
    210              
    211              
    212          }
    213          
    214          
    215          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     176   Xmodem_Transmit
       176   -> BSP_Ser_Printf
       176   -> Buzzer_OnOff
       176   -> Buzzer_Toggle
       176   -> USART_Read_Timeout
       176   -> USART_SendBuf
       176   -> USART_SendByte
       176   -> calc_crc
       176   -> flushinput
       176   -> memcpy
       176   -> memset
       0   calc_crc
       0   flushinput


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "> ">
       8  ?<Constant "CAN ">
      12  ?<Constant "DEFAULT ">
       8  ?<Constant "NAK ">
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
     816  Xmodem_Transmit
     116  calc_crc
       4  flushinput

 
  32 bytes in section .rodata
 952 bytes in section .text
 
 952 bytes of CODE  memory
  32 bytes of CONST memory

Errors: none
Warnings: none
